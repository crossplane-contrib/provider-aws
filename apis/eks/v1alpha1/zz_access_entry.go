/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// AccessEntryParameters defines the desired state of AccessEntry
type AccessEntryParameters struct {
	// Region is which region the AccessEntry will be created.
	// +kubebuilder:validation:Required
	Region string `json:"region"`
	// A unique, case-sensitive identifier that you provide to ensure the idempotency
	// of the request.
	ClientRequestToken *string `json:"clientRequestToken,omitempty"`
	// The name of your cluster.
	// +kubebuilder:validation:Required
	ClusterName *string `json:"clusterName"`
	// The value for name that you've specified for kind: Group as a subject in
	// a Kubernetes RoleBinding or ClusterRoleBinding object. Amazon EKS doesn't
	// confirm that the value for name exists in any bindings on your cluster. You
	// can specify one or more names.
	//
	// Kubernetes authorizes the principalArn of the access entry to access any
	// cluster objects that you've specified in a Kubernetes Role or ClusterRole
	// object that is also specified in a binding's roleRef. For more information
	// about creating Kubernetes RoleBinding, ClusterRoleBinding, Role, or ClusterRole
	// objects, see Using RBAC Authorization in the Kubernetes documentation (https://kubernetes.io/docs/reference/access-authn-authz/rbac/).
	//
	// If you want Amazon EKS to authorize the principalArn (instead of, or in addition
	// to Kubernetes authorizing the principalArn), you can associate one or more
	// access policies to the access entry using AssociateAccessPolicy. If you associate
	// any access policies, the principalARN has all permissions assigned in the
	// associated access policies and all permissions in any Kubernetes Role or
	// ClusterRole objects that the group names are bound to.
	KubernetesGroups []*string `json:"kubernetesGroups,omitempty"`
	// The ARN of the IAM principal for the AccessEntry. You can specify one ARN
	// for each access entry. You can't specify the same ARN in more than one access
	// entry. This value can't be changed after access entry creation.
	//
	// The valid principals differ depending on the type of the access entry in
	// the type field. The only valid ARN is IAM roles for the types of access entries
	// for nodes: . You can use every IAM principal type for STANDARD access entries.
	// You can't use the STS session principal type with access entries because
	// this is a temporary principal for each session and not a permanent identity
	// that can be assigned permissions.
	//
	// IAM best practices (https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#bp-users-federation-idp)
	// recommend using IAM roles with temporary credentials, rather than IAM users
	// with long-term credentials.
	// +kubebuilder:validation:Required
	PrincipalARN *string `json:"principalARN"`
	// Metadata that assists with categorization and organization. Each tag consists
	// of a key and an optional value. You define both. Tags don't propagate to
	// any other cluster or Amazon Web Services resources.
	Tags map[string]*string `json:"tags,omitempty"`
	// The type of the new access entry. Valid values are Standard, FARGATE_LINUX,
	// EC2_LINUX, and EC2_WINDOWS.
	//
	// If the principalArn is for an IAM role that's used for self-managed Amazon
	// EC2 nodes, specify EC2_LINUX or EC2_WINDOWS. Amazon EKS grants the necessary
	// permissions to the node for you. If the principalArn is for any other purpose,
	// specify STANDARD. If you don't specify a value, Amazon EKS sets the value
	// to STANDARD. It's unnecessary to create access entries for IAM roles used
	// with Fargate profiles or managed Amazon EC2 nodes, because Amazon EKS creates
	// entries in the aws-auth ConfigMap for the roles. You can't change this value
	// once you've created the access entry.
	//
	// If you set the value to EC2_LINUX or EC2_WINDOWS, you can't specify values
	// for kubernetesGroups, or associate an AccessPolicy to the access entry.
	Type *string `json:"type_,omitempty"`
	// The username to authenticate to Kubernetes with. We recommend not specifying
	// a username and letting Amazon EKS specify it for you. For more information
	// about the value Amazon EKS specifies for you, or constraints before specifying
	// your own username, see Creating access entries (https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#creating-access-entries)
	// in the Amazon EKS User Guide.
	Username                    *string `json:"username,omitempty"`
	CustomAccessEntryParameters `json:",inline"`
}

// AccessEntrySpec defines the desired state of AccessEntry
type AccessEntrySpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       AccessEntryParameters `json:"forProvider"`
}

// AccessEntryObservation defines the observed state of AccessEntry
type AccessEntryObservation struct {
	// The ARN of the access entry.
	AccessEntryARN *string `json:"accessEntryARN,omitempty"`
	// The Unix epoch timestamp at object creation.
	CreatedAt *metav1.Time `json:"createdAt,omitempty"`
	// The Unix epoch timestamp for the last modification to the object.
	ModifiedAt *metav1.Time `json:"modifiedAt,omitempty"`

	CustomAccessEntryObservation `json:",inline"`
}

// AccessEntryStatus defines the observed state of AccessEntry.
type AccessEntryStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          AccessEntryObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AccessEntry is the Schema for the AccessEntries API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type AccessEntry struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AccessEntrySpec   `json:"spec"`
	Status            AccessEntryStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AccessEntryList contains a list of AccessEntries
type AccessEntryList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AccessEntry `json:"items"`
}

// Repository type metadata.
var (
	AccessEntryKind             = "AccessEntry"
	AccessEntryGroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AccessEntryKind}.String()
	AccessEntryKindAPIVersion   = AccessEntryKind + "." + GroupVersion.String()
	AccessEntryGroupVersionKind = GroupVersion.WithKind(AccessEntryKind)
)

func init() {
	SchemeBuilder.Register(&AccessEntry{}, &AccessEntryList{})
}
