/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Hack to avoid import errors during build...
var (
	_ = &metav1.Time{}
)

// +kubebuilder:skipversion
type AcceleratorCount struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type AcceleratorCountRequest struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type AcceleratorTotalMemoryMiB struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type AcceleratorTotalMemoryMiBRequest struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type AccountAttribute struct {
	AttributeName *string `json:"attributeName,omitempty"`
}

// +kubebuilder:skipversion
type AccountAttributeValue struct {
	AttributeValue *string `json:"attributeValue,omitempty"`
}

// +kubebuilder:skipversion
type ActiveInstance struct {
	InstanceID *string `json:"instanceID,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	SpotInstanceRequestID *string `json:"spotInstanceRequestID,omitempty"`
}

// +kubebuilder:skipversion
type AddPrefixListEntry struct {
	CIDR *string `json:"cidr,omitempty"`

	Description *string `json:"description,omitempty"`
}

// +kubebuilder:skipversion
type Address struct {
	AllocationID *string `json:"allocationID,omitempty"`

	AssociationID *string `json:"associationID,omitempty"`

	CarrierIP *string `json:"carrierIP,omitempty"`

	CustomerOwnedIP *string `json:"customerOwnedIP,omitempty"`

	CustomerOwnedIPv4Pool *string `json:"customerOwnedIPv4Pool,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	NetworkBorderGroup *string `json:"networkBorderGroup,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	NetworkInterfaceOwnerID *string `json:"networkInterfaceOwnerID,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	PublicIP *string `json:"publicIP,omitempty"`

	PublicIPv4Pool *string `json:"publicIPv4Pool,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type AddressAttribute struct {
	PtrRecord *string `json:"ptrRecord,omitempty"`
}

// +kubebuilder:skipversion
type AllowedPrincipal struct {
	Principal *string `json:"principal,omitempty"`
}

// +kubebuilder:skipversion
type AlternatePathHint struct {
	ComponentARN *string `json:"componentARN,omitempty"`

	ComponentID *string `json:"componentID,omitempty"`
}

// +kubebuilder:skipversion
type AnalysisACLRule struct {
	CIDR *string `json:"cidr,omitempty"`

	Egress *bool `json:"egress,omitempty"`

	Protocol *string `json:"protocol,omitempty"`

	RuleAction *string `json:"ruleAction,omitempty"`

	RuleNumber *int64 `json:"ruleNumber,omitempty"`
}

// +kubebuilder:skipversion
type AnalysisComponent struct {
	ARN *string `json:"arn,omitempty"`

	ID *string `json:"id,omitempty"`
}

// +kubebuilder:skipversion
type AnalysisLoadBalancerTarget struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
}

// +kubebuilder:skipversion
type AnalysisPacketHeader struct {
	Protocol *string `json:"protocol,omitempty"`
}

// +kubebuilder:skipversion
type AnalysisRouteTableRoute struct {
	DestinationCIDR *string `json:"destinationCIDR,omitempty"`

	DestinationPrefixListID *string `json:"destinationPrefixListID,omitempty"`

	EgressOnlyInternetGatewayID *string `json:"egressOnlyInternetGatewayID,omitempty"`

	GatewayID *string `json:"gatewayID,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	NATGatewayID *string `json:"natGatewayID,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	Origin *string `json:"origin,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`

	VPCPeeringConnectionID *string `json:"vpcPeeringConnectionID,omitempty"`
}

// +kubebuilder:skipversion
type AnalysisSecurityGroupRule struct {
	CIDR *string `json:"cidr,omitempty"`

	Direction *string `json:"direction,omitempty"`

	PrefixListID *string `json:"prefixListID,omitempty"`

	Protocol *string `json:"protocol,omitempty"`

	SecurityGroupID *string `json:"securityGroupID,omitempty"`
}

// +kubebuilder:skipversion
type AssignedPrivateIPAddress struct {
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
}

// +kubebuilder:skipversion
type AssociatedRole struct {
	CertificateS3BucketName *string `json:"certificateS3BucketName,omitempty"`

	CertificateS3ObjectKey *string `json:"certificateS3ObjectKey,omitempty"`

	EncryptionKMSKeyID *string `json:"encryptionKMSKeyID,omitempty"`
}

// +kubebuilder:skipversion
type AssociatedTargetNetwork struct {
	NetworkID *string `json:"networkID,omitempty"`
}

// +kubebuilder:skipversion
type AssociationStatus struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type AthenaIntegration struct {
	IntegrationResultS3DestinationARN *string `json:"integrationResultS3DestinationARN,omitempty"`

	PartitionEndDate *metav1.Time `json:"partitionEndDate,omitempty"`

	PartitionStartDate *metav1.Time `json:"partitionStartDate,omitempty"`
}

// +kubebuilder:skipversion
type AttributeBooleanValue struct {
	Value *bool `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type AttributeValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type AuthorizationRule struct {
	AccessAll *bool `json:"accessAll,omitempty"`

	ClientVPNEndpointID *string `json:"clientVPNEndpointID,omitempty"`

	Description *string `json:"description,omitempty"`

	DestinationCIDR *string `json:"destinationCIDR,omitempty"`

	GroupID *string `json:"groupID,omitempty"`
}

// +kubebuilder:skipversion
type AvailabilityZone struct {
	GroupName *string `json:"groupName,omitempty"`

	NetworkBorderGroup *string `json:"networkBorderGroup,omitempty"`

	ParentZoneID *string `json:"parentZoneID,omitempty"`

	ParentZoneName *string `json:"parentZoneName,omitempty"`

	RegionName *string `json:"regionName,omitempty"`

	ZoneID *string `json:"zoneID,omitempty"`

	ZoneName *string `json:"zoneName,omitempty"`

	ZoneType *string `json:"zoneType,omitempty"`
}

// +kubebuilder:skipversion
type AvailabilityZoneMessage struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type AvailableCapacity struct {
	AvailableVCPUs *int64 `json:"availableVCPUs,omitempty"`
}

// +kubebuilder:skipversion
type BaselineEBSBandwidthMbps struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type BaselineEBSBandwidthMbpsRequest struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type BlockDeviceMapping struct {
	DeviceName *string `json:"deviceName,omitempty"`

	NoDevice *string `json:"noDevice,omitempty"`

	VirtualName *string `json:"virtualName,omitempty"`
}

// +kubebuilder:skipversion
type BundleTask struct {
	BundleID *string `json:"bundleID,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	Progress *string `json:"progress,omitempty"`

	StartTime *metav1.Time `json:"startTime,omitempty"`

	UpdateTime *metav1.Time `json:"updateTime,omitempty"`
}

// +kubebuilder:skipversion
type BundleTaskError struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type ByoipCIDR struct {
	CIDR *string `json:"cidr,omitempty"`

	Description *string `json:"description,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`
}

// +kubebuilder:skipversion
type CIDRAuthorizationContext struct {
	Message *string `json:"message,omitempty"`

	Signature *string `json:"signature,omitempty"`
}

// +kubebuilder:skipversion
type CIDRBlock struct {
	CIDRBlock *string `json:"cidrBlock,omitempty"`
}

// +kubebuilder:skipversion
type CPUOptions struct {
	CoreCount *int64 `json:"coreCount,omitempty"`

	ThreadsPerCore *int64 `json:"threadsPerCore,omitempty"`
}

// +kubebuilder:skipversion
type CPUOptionsRequest struct {
	CoreCount *int64 `json:"coreCount,omitempty"`

	ThreadsPerCore *int64 `json:"threadsPerCore,omitempty"`
}

// +kubebuilder:skipversion
type CancelSpotFleetRequestsError struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type CancelSpotFleetRequestsErrorItem struct {
	SpotFleetRequestID *string `json:"spotFleetRequestID,omitempty"`
}

// +kubebuilder:skipversion
type CancelSpotFleetRequestsSuccessItem struct {
	SpotFleetRequestID *string `json:"spotFleetRequestID,omitempty"`
}

// +kubebuilder:skipversion
type CancelledSpotInstanceRequest struct {
	SpotInstanceRequestID *string `json:"spotInstanceRequestID,omitempty"`
}

// +kubebuilder:skipversion
type CapacityReservation struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	AvailabilityZoneID *string `json:"availabilityZoneID,omitempty"`

	AvailableInstanceCount *int64 `json:"availableInstanceCount,omitempty"`

	CapacityReservationARN *string `json:"capacityReservationARN,omitempty"`

	CapacityReservationFleetID *string `json:"capacityReservationFleetID,omitempty"`

	CapacityReservationID *string `json:"capacityReservationID,omitempty"`

	CreateDate *metav1.Time `json:"createDate,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	EndDate *metav1.Time `json:"endDate,omitempty"`

	EphemeralStorage *bool `json:"ephemeralStorage,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	StartDate *metav1.Time `json:"startDate,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TotalInstanceCount *int64 `json:"totalInstanceCount,omitempty"`
}

// +kubebuilder:skipversion
type CapacityReservationFleet struct {
	AllocationStrategy *string `json:"allocationStrategy,omitempty"`

	CapacityReservationFleetARN *string `json:"capacityReservationFleetARN,omitempty"`

	CreateTime *metav1.Time `json:"createTime,omitempty"`

	EndDate *metav1.Time `json:"endDate,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TotalFulfilledCapacity *float64 `json:"totalFulfilledCapacity,omitempty"`

	TotalTargetCapacity *int64 `json:"totalTargetCapacity,omitempty"`
}

// +kubebuilder:skipversion
type CapacityReservationGroup struct {
	GroupARN *string `json:"groupARN,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`
}

// +kubebuilder:skipversion
type CapacityReservationSpecification struct {
	CapacityReservationPreference *string `json:"capacityReservationPreference,omitempty"`
	// Describes a target Capacity Reservation or Capacity Reservation group.
	CapacityReservationTarget *CapacityReservationTarget `json:"capacityReservationTarget,omitempty"`
}

// +kubebuilder:skipversion
type CapacityReservationSpecificationResponse struct {
	CapacityReservationPreference *string `json:"capacityReservationPreference,omitempty"`
	// Describes a target Capacity Reservation or Capacity Reservation group.
	CapacityReservationTarget *CapacityReservationTargetResponse `json:"capacityReservationTarget,omitempty"`
}

// +kubebuilder:skipversion
type CapacityReservationTarget struct {
	CapacityReservationID *string `json:"capacityReservationID,omitempty"`

	CapacityReservationResourceGroupARN *string `json:"capacityReservationResourceGroupARN,omitempty"`
}

// +kubebuilder:skipversion
type CapacityReservationTargetResponse struct {
	CapacityReservationID *string `json:"capacityReservationID,omitempty"`

	CapacityReservationResourceGroupARN *string `json:"capacityReservationResourceGroupARN,omitempty"`
}

// +kubebuilder:skipversion
type CarrierGateway struct {
	CarrierGatewayID *string `json:"carrierGatewayID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type CertificateAuthentication struct {
	ClientRootCertificateChain *string `json:"clientRootCertificateChain,omitempty"`
}

// +kubebuilder:skipversion
type CertificateAuthenticationRequest struct {
	ClientRootCertificateChainARN *string `json:"clientRootCertificateChainARN,omitempty"`
}

// +kubebuilder:skipversion
type ClassicLinkDNSSupport struct {
	ClassicLinkDNSSupported *bool `json:"classicLinkDNSSupported,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type ClassicLinkInstance struct {
	InstanceID *string `json:"instanceID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type ClassicLoadBalancer struct {
	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type ClientCertificateRevocationListStatus struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type ClientConnectOptions struct {
	Enabled *bool `json:"enabled,omitempty"`

	LambdaFunctionARN *string `json:"lambdaFunctionARN,omitempty"`
}

// +kubebuilder:skipversion
type ClientConnectResponseOptions struct {
	Enabled *bool `json:"enabled,omitempty"`

	LambdaFunctionARN *string `json:"lambdaFunctionARN,omitempty"`
}

// +kubebuilder:skipversion
type ClientData struct {
	Comment *string `json:"comment,omitempty"`

	UploadEnd *metav1.Time `json:"uploadEnd,omitempty"`

	UploadSize *float64 `json:"uploadSize,omitempty"`

	UploadStart *metav1.Time `json:"uploadStart,omitempty"`
}

// +kubebuilder:skipversion
type ClientVPNAuthorizationRuleStatus struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type ClientVPNConnection struct {
	ClientIP *string `json:"clientIP,omitempty"`

	ClientVPNEndpointID *string `json:"clientVPNEndpointID,omitempty"`

	CommonName *string `json:"commonName,omitempty"`

	ConnectionEndTime *string `json:"connectionEndTime,omitempty"`

	ConnectionEstablishedTime *string `json:"connectionEstablishedTime,omitempty"`

	ConnectionID *string `json:"connectionID,omitempty"`

	EgressBytes *string `json:"egressBytes,omitempty"`

	EgressPackets *string `json:"egressPackets,omitempty"`

	IngressBytes *string `json:"ingressBytes,omitempty"`

	IngressPackets *string `json:"ingressPackets,omitempty"`

	PostureComplianceStatuses []*string `json:"postureComplianceStatuses,omitempty"`

	Timestamp *string `json:"timestamp,omitempty"`

	Username *string `json:"username,omitempty"`
}

// +kubebuilder:skipversion
type ClientVPNConnectionStatus struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type ClientVPNEndpoint struct {
	ClientCIDRBlock *string `json:"clientCIDRBlock,omitempty"`

	ClientVPNEndpointID *string `json:"clientVPNEndpointID,omitempty"`

	CreationTime *string `json:"creationTime,omitempty"`

	DeletionTime *string `json:"deletionTime,omitempty"`

	Description *string `json:"description,omitempty"`

	DNSName *string `json:"dnsName,omitempty"`

	DNSServers []*string `json:"dnsServers,omitempty"`

	SelfServicePortalURL *string `json:"selfServicePortalURL,omitempty"`

	ServerCertificateARN *string `json:"serverCertificateARN,omitempty"`

	SplitTunnel *bool `json:"splitTunnel,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPNPort *int64 `json:"vpnPort,omitempty"`
}

// +kubebuilder:skipversion
type ClientVPNEndpointAttributeStatus struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type ClientVPNEndpointStatus struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type ClientVPNRoute struct {
	ClientVPNEndpointID *string `json:"clientVPNEndpointID,omitempty"`

	Description *string `json:"description,omitempty"`

	DestinationCIDR *string `json:"destinationCIDR,omitempty"`

	Origin *string `json:"origin,omitempty"`

	TargetSubnet *string `json:"targetSubnet,omitempty"`

	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type ClientVPNRouteStatus struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type CoipAddressUsage struct {
	AllocationID *string `json:"allocationID,omitempty"`

	AWSAccountID *string `json:"awsAccountID,omitempty"`

	AWSService *string `json:"awsService,omitempty"`

	CoIP *string `json:"coIP,omitempty"`
}

// +kubebuilder:skipversion
type CoipPool struct {
	PoolCIDRs []*string `json:"poolCIDRs,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ConnectionLogOptions struct {
	CloudwatchLogGroup *string `json:"cloudwatchLogGroup,omitempty"`

	CloudwatchLogStream *string `json:"cloudwatchLogStream,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type ConnectionLogResponseOptions struct {
	CloudwatchLogGroup *string `json:"cloudwatchLogGroup,omitempty"`

	CloudwatchLogStream *string `json:"cloudwatchLogStream,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type ConnectionNotification struct {
	ConnectionEvents []*string `json:"connectionEvents,omitempty"`

	ConnectionNotificationARN *string `json:"connectionNotificationARN,omitempty"`

	ConnectionNotificationID *string `json:"connectionNotificationID,omitempty"`

	ServiceID *string `json:"serviceID,omitempty"`

	VPCEndpointID *string `json:"vpcEndpointID,omitempty"`
}

// +kubebuilder:skipversion
type ConversionTask struct {
	ConversionTaskID *string `json:"conversionTaskID,omitempty"`

	ExpirationTime *string `json:"expirationTime,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type CreateFleetError struct {
	ErrorCode *string `json:"errorCode,omitempty"`

	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// +kubebuilder:skipversion
type CreateFleetInstance struct {
	InstanceType *string `json:"instanceType,omitempty"`
}

// +kubebuilder:skipversion
type CreateTransitGatewayVPCAttachmentRequestOptions struct {
	ApplianceModeSupport *string `json:"applianceModeSupport,omitempty"`

	DNSSupport *string `json:"dnsSupport,omitempty"`

	IPv6Support *string `json:"ipv6Support,omitempty"`
}

// +kubebuilder:skipversion
type CreateVolumePermission struct {
	UserID *string `json:"userID,omitempty"`
}

// +kubebuilder:skipversion
type CreditSpecification struct {
	CPUCredits *string `json:"cpuCredits,omitempty"`
}

// +kubebuilder:skipversion
type CreditSpecificationRequest struct {
	CPUCredits *string `json:"cpuCredits,omitempty"`
}

// +kubebuilder:skipversion
type CustomerGateway struct {
	BGPASN *string `json:"bgpASN,omitempty"`

	CertificateARN *string `json:"certificateARN,omitempty"`

	CustomerGatewayID *string `json:"customerGatewayID,omitempty"`

	DeviceName *string `json:"deviceName,omitempty"`

	IPAddress *string `json:"ipAddress,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type DHCPConfiguration struct {
	Key *string `json:"key,omitempty"`
}

// +kubebuilder:skipversion
type DHCPOptions struct {
	DHCPOptionsID *string `json:"dhcpOptionsID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type DNSEntry struct {
	DNSName *string `json:"dnsName,omitempty"`

	HostedZoneID *string `json:"hostedZoneID,omitempty"`
}

// +kubebuilder:skipversion
type DNSServersOptionsModifyStructure struct {
	CustomDNSServers []*string `json:"customDNSServers,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type DeleteFleetError struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type DeleteLaunchTemplateVersionsResponseErrorItem struct {
	LaunchTemplateID *string `json:"launchTemplateID,omitempty"`

	LaunchTemplateName *string `json:"launchTemplateName,omitempty"`

	VersionNumber *int64 `json:"versionNumber,omitempty"`
}

// +kubebuilder:skipversion
type DeleteLaunchTemplateVersionsResponseSuccessItem struct {
	LaunchTemplateID *string `json:"launchTemplateID,omitempty"`

	LaunchTemplateName *string `json:"launchTemplateName,omitempty"`

	VersionNumber *int64 `json:"versionNumber,omitempty"`
}

// +kubebuilder:skipversion
type DeleteQueuedReservedInstancesError struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type DeregisterInstanceTagAttributeRequest struct {
	IncludeAllTagsOfInstance *bool `json:"includeAllTagsOfInstance,omitempty"`
}

// +kubebuilder:skipversion
type DescribeFastSnapshotRestoreSuccessItem struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	DisabledTime *metav1.Time `json:"disabledTime,omitempty"`

	DisablingTime *metav1.Time `json:"disablingTime,omitempty"`

	EnabledTime *metav1.Time `json:"enabledTime,omitempty"`

	EnablingTime *metav1.Time `json:"enablingTime,omitempty"`

	OptimizingTime *metav1.Time `json:"optimizingTime,omitempty"`

	OwnerAlias *string `json:"ownerAlias,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	StateTransitionReason *string `json:"stateTransitionReason,omitempty"`
}

// +kubebuilder:skipversion
type DescribeFleetError struct {
	ErrorCode *string `json:"errorCode,omitempty"`

	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// +kubebuilder:skipversion
type DescribeFleetsInstances struct {
	InstanceType *string `json:"instanceType,omitempty"`
}

// +kubebuilder:skipversion
type DestinationOptionsRequest struct {
	HiveCompatiblePartitions *bool `json:"hiveCompatiblePartitions,omitempty"`

	PerHourPartition *bool `json:"perHourPartition,omitempty"`
}

// +kubebuilder:skipversion
type DestinationOptionsResponse struct {
	HiveCompatiblePartitions *bool `json:"hiveCompatiblePartitions,omitempty"`

	PerHourPartition *bool `json:"perHourPartition,omitempty"`
}

// +kubebuilder:skipversion
type DirectoryServiceAuthentication struct {
	DirectoryID *string `json:"directoryID,omitempty"`
}

// +kubebuilder:skipversion
type DirectoryServiceAuthenticationRequest struct {
	DirectoryID *string `json:"directoryID,omitempty"`
}

// +kubebuilder:skipversion
type DisableFastSnapshotRestoreErrorItem struct {
	SnapshotID *string `json:"snapshotID,omitempty"`
}

// +kubebuilder:skipversion
type DisableFastSnapshotRestoreStateError struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type DisableFastSnapshotRestoreStateErrorItem struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
}

// +kubebuilder:skipversion
type DisableFastSnapshotRestoreSuccessItem struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	DisabledTime *metav1.Time `json:"disabledTime,omitempty"`

	DisablingTime *metav1.Time `json:"disablingTime,omitempty"`

	EnabledTime *metav1.Time `json:"enabledTime,omitempty"`

	EnablingTime *metav1.Time `json:"enablingTime,omitempty"`

	OptimizingTime *metav1.Time `json:"optimizingTime,omitempty"`

	OwnerAlias *string `json:"ownerAlias,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	StateTransitionReason *string `json:"stateTransitionReason,omitempty"`
}

// +kubebuilder:skipversion
type DiskImage struct {
	Description *string `json:"description,omitempty"`
}

// +kubebuilder:skipversion
type DiskImageDescription struct {
	Checksum *string `json:"checksum,omitempty"`

	ImportManifestURL *string `json:"importManifestURL,omitempty"`

	Size *int64 `json:"size,omitempty"`
}

// +kubebuilder:skipversion
type DiskImageDetail struct {
	Bytes *int64 `json:"bytes,omitempty"`

	ImportManifestURL *string `json:"importManifestURL,omitempty"`
}

// +kubebuilder:skipversion
type DiskImageVolumeDescription struct {
	ID *string `json:"id,omitempty"`

	Size *int64 `json:"size,omitempty"`
}

// +kubebuilder:skipversion
type EBSBlockDevice struct {
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty"`

	IOPS *int64 `json:"iops,omitempty"`

	KMSKeyID *string `json:"kmsKeyID,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	Throughput *int64 `json:"throughput,omitempty"`

	VolumeSize *int64 `json:"volumeSize,omitempty"`

	VolumeType *string `json:"volumeType,omitempty"`
}

// +kubebuilder:skipversion
type EBSInstanceBlockDevice struct {
	AttachTime *metav1.Time `json:"attachTime,omitempty"`

	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	VolumeID *string `json:"volumeID,omitempty"`
}

// +kubebuilder:skipversion
type EBSInstanceBlockDeviceSpecification struct {
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	VolumeID *string `json:"volumeID,omitempty"`
}

// +kubebuilder:skipversion
type EgressOnlyInternetGateway struct {
	EgressOnlyInternetGatewayID *string `json:"egressOnlyInternetGatewayID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ElasticGPUAssociation struct {
	ElasticGPUAssociationID *string `json:"elasticGPUAssociationID,omitempty"`

	ElasticGPUAssociationState *string `json:"elasticGPUAssociationState,omitempty"`

	ElasticGPUAssociationTime *string `json:"elasticGPUAssociationTime,omitempty"`

	ElasticGPUID *string `json:"elasticGPUID,omitempty"`
}

// +kubebuilder:skipversion
type ElasticGPUSpecification struct {
	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type ElasticGPUSpecificationResponse struct {
	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type ElasticGPUs struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	ElasticGPUID *string `json:"elasticGPUID,omitempty"`

	ElasticGPUType *string `json:"elasticGPUType,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ElasticInferenceAccelerator struct {
	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type ElasticInferenceAcceleratorAssociation struct {
	ElasticInferenceAcceleratorARN *string `json:"elasticInferenceAcceleratorARN,omitempty"`

	ElasticInferenceAcceleratorAssociationID *string `json:"elasticInferenceAcceleratorAssociationID,omitempty"`

	ElasticInferenceAcceleratorAssociationState *string `json:"elasticInferenceAcceleratorAssociationState,omitempty"`

	ElasticInferenceAcceleratorAssociationTime *metav1.Time `json:"elasticInferenceAcceleratorAssociationTime,omitempty"`
}

// +kubebuilder:skipversion
type EnableFastSnapshotRestoreErrorItem struct {
	SnapshotID *string `json:"snapshotID,omitempty"`
}

// +kubebuilder:skipversion
type EnableFastSnapshotRestoreStateError struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type EnableFastSnapshotRestoreStateErrorItem struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
}

// +kubebuilder:skipversion
type EnableFastSnapshotRestoreSuccessItem struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	DisabledTime *metav1.Time `json:"disabledTime,omitempty"`

	DisablingTime *metav1.Time `json:"disablingTime,omitempty"`

	EnabledTime *metav1.Time `json:"enabledTime,omitempty"`

	EnablingTime *metav1.Time `json:"enablingTime,omitempty"`

	OptimizingTime *metav1.Time `json:"optimizingTime,omitempty"`

	OwnerAlias *string `json:"ownerAlias,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	StateTransitionReason *string `json:"stateTransitionReason,omitempty"`
}

// +kubebuilder:skipversion
type EnclaveOptions struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type EnclaveOptionsRequest struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type EventInformation struct {
	EventDescription *string `json:"eventDescription,omitempty"`

	EventSubType *string `json:"eventSubType,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`
}

// +kubebuilder:skipversion
type Explanation struct {
	AvailabilityZones []*string `json:"availabilityZones,omitempty"`

	CIDRs []*string `json:"cidrs,omitempty"`

	Direction *string `json:"direction,omitempty"`

	ExplanationCode *string `json:"explanationCode,omitempty"`

	MissingComponent *string `json:"missingComponent,omitempty"`

	PacketField *string `json:"packetField,omitempty"`

	State *string `json:"state,omitempty"`
}

// +kubebuilder:skipversion
type ExportImageTask struct {
	Description *string `json:"description,omitempty"`

	ExportImageTaskID *string `json:"exportImageTaskID,omitempty"`

	ImageID *string `json:"imageID,omitempty"`

	Progress *string `json:"progress,omitempty"`

	Status *string `json:"status,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ExportTask struct {
	Description *string `json:"description,omitempty"`

	ExportTaskID *string `json:"exportTaskID,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ExportTaskS3Location struct {
	S3Bucket *string `json:"s3Bucket,omitempty"`

	S3Prefix *string `json:"s3Prefix,omitempty"`
}

// +kubebuilder:skipversion
type ExportTaskS3LocationRequest struct {
	S3Bucket *string `json:"s3Bucket,omitempty"`

	S3Prefix *string `json:"s3Prefix,omitempty"`
}

// +kubebuilder:skipversion
type ExportToS3Task struct {
	S3Bucket *string `json:"s3Bucket,omitempty"`

	S3Key *string `json:"s3Key,omitempty"`
}

// +kubebuilder:skipversion
type ExportToS3TaskSpecification struct {
	S3Bucket *string `json:"s3Bucket,omitempty"`

	S3Prefix *string `json:"s3Prefix,omitempty"`
}

// +kubebuilder:skipversion
type FPGAImage struct {
	CreateTime *metav1.Time `json:"createTime,omitempty"`

	DataRetentionSupport *bool `json:"dataRetentionSupport,omitempty"`

	Description *string `json:"description,omitempty"`

	FPGAImageGlobalID *string `json:"fpgaImageGlobalID,omitempty"`

	FPGAImageID *string `json:"fpgaImageID,omitempty"`

	Name *string `json:"name,omitempty"`

	OwnerAlias *string `json:"ownerAlias,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Public *bool `json:"public,omitempty"`

	ShellVersion *string `json:"shellVersion,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	UpdateTime *metav1.Time `json:"updateTime,omitempty"`
}

// +kubebuilder:skipversion
type FPGAImageAttribute struct {
	Description *string `json:"description,omitempty"`

	FPGAImageID *string `json:"fpgaImageID,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type FPGAImageState struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type FailedQueuedPurchaseDeletion struct {
	ReservedInstancesID *string `json:"reservedInstancesID,omitempty"`
}

// +kubebuilder:skipversion
type FederatedAuthentication struct {
	SamlProviderARN *string `json:"samlProviderARN,omitempty"`

	SelfServiceSamlProviderARN *string `json:"selfServiceSamlProviderARN,omitempty"`
}

// +kubebuilder:skipversion
type FederatedAuthenticationRequest struct {
	SAMLProviderARN *string `json:"sAMLProviderARN,omitempty"`

	SelfServiceSAMLProviderARN *string `json:"selfServiceSAMLProviderARN,omitempty"`
}

// +kubebuilder:skipversion
type Filter struct {
	Name *string `json:"name,omitempty"`

	Values []*string `json:"values,omitempty"`
}

// +kubebuilder:skipversion
type FleetCapacityReservation struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	AvailabilityZoneID *string `json:"availabilityZoneID,omitempty"`

	CapacityReservationID *string `json:"capacityReservationID,omitempty"`

	CreateDate *metav1.Time `json:"createDate,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	FulfilledCapacity *float64 `json:"fulfilledCapacity,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	TotalInstanceCount *int64 `json:"totalInstanceCount,omitempty"`
}

// +kubebuilder:skipversion
type FleetData struct {
	ClientToken *string `json:"clientToken,omitempty"`

	Context *string `json:"context,omitempty"`

	CreateTime *metav1.Time `json:"createTime,omitempty"`

	FulfilledCapacity *float64 `json:"fulfilledCapacity,omitempty"`

	FulfilledOnDemandCapacity *float64 `json:"fulfilledOnDemandCapacity,omitempty"`

	ReplaceUnhealthyInstances *bool `json:"replaceUnhealthyInstances,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TerminateInstancesWithExpiration *bool `json:"terminateInstancesWithExpiration,omitempty"`

	ValidFrom *metav1.Time `json:"validFrom,omitempty"`

	ValidUntil *metav1.Time `json:"validUntil,omitempty"`
}

// +kubebuilder:skipversion
type FleetLaunchTemplateOverrides struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple parameters, you get instance types that satisfy
	// all of the specified parameters. If you specify multiple values for a parameter,
	// you get instance types that satisfy any of the specified values.
	//
	// You must specify VCpuCount and MemoryMiB. All other parameters are optional.
	// Any unspecified optional parameter is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	InstanceRequirements *InstanceRequirements `json:"instanceRequirements,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	MaxPrice *string `json:"maxPrice,omitempty"`

	Priority *float64 `json:"priority,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	WeightedCapacity *float64 `json:"weightedCapacity,omitempty"`
}

// +kubebuilder:skipversion
type FleetLaunchTemplateOverridesRequest struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple parameters, you get instance types that satisfy
	// all of the specified parameters. If you specify multiple values for a parameter,
	// you get instance types that satisfy any of the specified values.
	//
	// You must specify VCpuCount and MemoryMiB. All other parameters are optional.
	// Any unspecified optional parameter is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	InstanceRequirements *InstanceRequirementsRequest `json:"instanceRequirements,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	MaxPrice *string `json:"maxPrice,omitempty"`

	Priority *float64 `json:"priority,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	WeightedCapacity *float64 `json:"weightedCapacity,omitempty"`
}

// +kubebuilder:skipversion
type FleetLaunchTemplateSpecification struct {
	LaunchTemplateID *string `json:"launchTemplateID,omitempty"`

	LaunchTemplateName *string `json:"launchTemplateName,omitempty"`

	Version *string `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type FleetLaunchTemplateSpecificationRequest struct {
	LaunchTemplateID *string `json:"launchTemplateID,omitempty"`

	LaunchTemplateName *string `json:"launchTemplateName,omitempty"`

	Version *string `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type FleetSpotCapacityRebalance struct {
	TerminationDelay *int64 `json:"terminationDelay,omitempty"`
}

// +kubebuilder:skipversion
type FleetSpotCapacityRebalanceRequest struct {
	TerminationDelay *int64 `json:"terminationDelay,omitempty"`
}

// +kubebuilder:skipversion
type FlowLog struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	DeliverLogsErrorMessage *string `json:"deliverLogsErrorMessage,omitempty"`

	DeliverLogsPermissionARN *string `json:"deliverLogsPermissionARN,omitempty"`

	DeliverLogsStatus *string `json:"deliverLogsStatus,omitempty"`

	FlowLogID *string `json:"flowLogID,omitempty"`

	FlowLogStatus *string `json:"flowLogStatus,omitempty"`

	LogDestination *string `json:"logDestination,omitempty"`

	LogFormat *string `json:"logFormat,omitempty"`

	LogGroupName *string `json:"logGroupName,omitempty"`

	MaxAggregationInterval *int64 `json:"maxAggregationInterval,omitempty"`

	ResourceID *string `json:"resourceID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type GroupIdentifier struct {
	GroupID *string `json:"groupID,omitempty"`

	GroupName *string `json:"groupName,omitempty"`
}

// +kubebuilder:skipversion
type HibernationOptions struct {
	Configured *bool `json:"configured,omitempty"`
}

// +kubebuilder:skipversion
type HibernationOptionsRequest struct {
	Configured *bool `json:"configured,omitempty"`
}

// +kubebuilder:skipversion
type HistoryRecord struct {
	Timestamp *metav1.Time `json:"timestamp,omitempty"`
}

// +kubebuilder:skipversion
type HistoryRecordEntry struct {
	Timestamp *metav1.Time `json:"timestamp,omitempty"`
}

// +kubebuilder:skipversion
type Host struct {
	AllocationTime *metav1.Time `json:"allocationTime,omitempty"`

	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	AvailabilityZoneID *string `json:"availabilityZoneID,omitempty"`

	ClientToken *string `json:"clientToken,omitempty"`

	HostID *string `json:"hostID,omitempty"`

	HostReservationID *string `json:"hostReservationID,omitempty"`

	MemberOfServiceLinkedResourceGroup *bool `json:"memberOfServiceLinkedResourceGroup,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	ReleaseTime *metav1.Time `json:"releaseTime,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type HostInstance struct {
	InstanceID *string `json:"instanceID,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`
}

// +kubebuilder:skipversion
type HostOffering struct {
	Duration *int64 `json:"duration,omitempty"`

	HourlyPrice *string `json:"hourlyPrice,omitempty"`

	InstanceFamily *string `json:"instanceFamily,omitempty"`

	OfferingID *string `json:"offeringID,omitempty"`

	UpfrontPrice *string `json:"upfrontPrice,omitempty"`
}

// +kubebuilder:skipversion
type HostProperties struct {
	Cores *int64 `json:"cores,omitempty"`

	InstanceFamily *string `json:"instanceFamily,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	Sockets *int64 `json:"sockets,omitempty"`

	TotalVCPUs *int64 `json:"totalVCPUs,omitempty"`
}

// +kubebuilder:skipversion
type HostReservation struct {
	Count *int64 `json:"count,omitempty"`

	Duration *int64 `json:"duration,omitempty"`

	End *metav1.Time `json:"end,omitempty"`

	HostReservationID *string `json:"hostReservationID,omitempty"`

	HourlyPrice *string `json:"hourlyPrice,omitempty"`

	InstanceFamily *string `json:"instanceFamily,omitempty"`

	OfferingID *string `json:"offeringID,omitempty"`

	Start *metav1.Time `json:"start,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	UpfrontPrice *string `json:"upfrontPrice,omitempty"`
}

// +kubebuilder:skipversion
type IAMInstanceProfile struct {
	ARN *string `json:"arn,omitempty"`

	ID *string `json:"id,omitempty"`
}

// +kubebuilder:skipversion
type IAMInstanceProfileAssociation struct {
	AssociationID *string `json:"associationID,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	Timestamp *metav1.Time `json:"timestamp,omitempty"`
}

// +kubebuilder:skipversion
type IAMInstanceProfileSpecification struct {
	ARN *string `json:"arn,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type ICMPTypeCode struct {
	Code *int64 `json:"code,omitempty"`

	Type *int64 `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type IDFormat struct {
	Deadline *metav1.Time `json:"deadline,omitempty"`

	Resource *string `json:"resource,omitempty"`

	UseLongIDs *bool `json:"useLongIDs,omitempty"`
}

// +kubebuilder:skipversion
type IKEVersionsListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type IKEVersionsRequestListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type IPPermission struct {
	FromPort *int64 `json:"fromPort,omitempty"`

	IPProtocol *string `json:"ipProtocol,omitempty"`

	ToPort *int64 `json:"toPort,omitempty"`
}

// +kubebuilder:skipversion
type IPRange struct {
	CIDRIP *string `json:"cidrIP,omitempty"`

	Description *string `json:"description,omitempty"`
}

// +kubebuilder:skipversion
type IPv4PrefixSpecification struct {
	IPv4Prefix *string `json:"ipv4Prefix,omitempty"`
}

// +kubebuilder:skipversion
type IPv4PrefixSpecificationRequest struct {
	IPv4Prefix *string `json:"ipv4Prefix,omitempty"`
}

// +kubebuilder:skipversion
type IPv4PrefixSpecificationResponse struct {
	IPv4Prefix *string `json:"ipv4Prefix,omitempty"`
}

// +kubebuilder:skipversion
type IPv6CIDRAssociation struct {
	AssociatedResource *string `json:"associatedResource,omitempty"`

	IPv6CIDR *string `json:"ipv6CIDR,omitempty"`
}

// +kubebuilder:skipversion
type IPv6CIDRBlock struct {
	IPv6CIDRBlock *string `json:"ipv6CIDRBlock,omitempty"`
}

// +kubebuilder:skipversion
type IPv6Pool struct {
	Description *string `json:"description,omitempty"`

	PoolID *string `json:"poolID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type IPv6PrefixSpecification struct {
	IPv6Prefix *string `json:"ipv6Prefix,omitempty"`
}

// +kubebuilder:skipversion
type IPv6PrefixSpecificationRequest struct {
	IPv6Prefix *string `json:"ipv6Prefix,omitempty"`
}

// +kubebuilder:skipversion
type IPv6PrefixSpecificationResponse struct {
	IPv6Prefix *string `json:"ipv6Prefix,omitempty"`
}

// +kubebuilder:skipversion
type IPv6Range struct {
	CIDRIPv6 *string `json:"cidrIPv6,omitempty"`

	Description *string `json:"description,omitempty"`
}

// +kubebuilder:skipversion
type Image struct {
	CreationDate *string `json:"creationDate,omitempty"`

	DeprecationTime *string `json:"deprecationTime,omitempty"`

	Description *string `json:"description,omitempty"`

	ENASupport *bool `json:"enaSupport,omitempty"`

	ImageID *string `json:"imageID,omitempty"`

	ImageLocation *string `json:"imageLocation,omitempty"`

	ImageOwnerAlias *string `json:"imageOwnerAlias,omitempty"`

	KernelID *string `json:"kernelID,omitempty"`

	Name *string `json:"name,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	PlatformDetails *string `json:"platformDetails,omitempty"`

	Public *bool `json:"public,omitempty"`

	RamdiskID *string `json:"ramdiskID,omitempty"`

	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	SriovNetSupport *string `json:"sriovNetSupport,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	UsageOperation *string `json:"usageOperation,omitempty"`
}

// +kubebuilder:skipversion
type ImageDiskContainer struct {
	Description *string `json:"description,omitempty"`

	DeviceName *string `json:"deviceName,omitempty"`

	Format *string `json:"format,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	URL *string `json:"url,omitempty"`
}

// +kubebuilder:skipversion
type ImportImageLicenseConfigurationRequest struct {
	LicenseConfigurationARN *string `json:"licenseConfigurationARN,omitempty"`
}

// +kubebuilder:skipversion
type ImportImageLicenseConfigurationResponse struct {
	LicenseConfigurationARN *string `json:"licenseConfigurationARN,omitempty"`
}

// +kubebuilder:skipversion
type ImportImageTask struct {
	Architecture *string `json:"architecture,omitempty"`

	Description *string `json:"description,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty"`

	Hypervisor *string `json:"hypervisor,omitempty"`

	ImageID *string `json:"imageID,omitempty"`

	ImportTaskID *string `json:"importTaskID,omitempty"`

	KMSKeyID *string `json:"kmsKeyID,omitempty"`

	LicenseType *string `json:"licenseType,omitempty"`

	Platform *string `json:"platform,omitempty"`

	Progress *string `json:"progress,omitempty"`

	Status *string `json:"status,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	UsageOperation *string `json:"usageOperation,omitempty"`
}

// +kubebuilder:skipversion
type ImportInstanceLaunchSpecification struct {
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	GroupIDs []*string `json:"groupIDs,omitempty"`

	GroupNames []*string `json:"groupNames,omitempty"`

	InstanceInitiatedShutdownBehavior *string `json:"instanceInitiatedShutdownBehavior,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	Monitoring *bool `json:"monitoring,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type ImportInstanceTaskDetails struct {
	Description *string `json:"description,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`
}

// +kubebuilder:skipversion
type ImportInstanceVolumeDetailItem struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	BytesConverted *int64 `json:"bytesConverted,omitempty"`

	Description *string `json:"description,omitempty"`

	Status *string `json:"status,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`
}

// +kubebuilder:skipversion
type ImportSnapshotTask struct {
	Description *string `json:"description,omitempty"`

	ImportTaskID *string `json:"importTaskID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ImportVolumeTaskDetails struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	BytesConverted *int64 `json:"bytesConverted,omitempty"`

	Description *string `json:"description,omitempty"`
}

// +kubebuilder:skipversion
type InstanceBlockDeviceMapping struct {
	DeviceName *string `json:"deviceName,omitempty"`
}

// +kubebuilder:skipversion
type InstanceBlockDeviceMappingSpecification struct {
	DeviceName *string `json:"deviceName,omitempty"`

	NoDevice *string `json:"noDevice,omitempty"`

	VirtualName *string `json:"virtualName,omitempty"`
}

// +kubebuilder:skipversion
type InstanceCapacity struct {
	AvailableCapacity *int64 `json:"availableCapacity,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	TotalCapacity *int64 `json:"totalCapacity,omitempty"`
}

// +kubebuilder:skipversion
type InstanceCount struct {
	InstanceCount *int64 `json:"instanceCount,omitempty"`
}

// +kubebuilder:skipversion
type InstanceCreditSpecification struct {
	CPUCredits *string `json:"cpuCredits,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`
}

// +kubebuilder:skipversion
type InstanceCreditSpecificationRequest struct {
	CPUCredits *string `json:"cpuCredits,omitempty"`
}

// +kubebuilder:skipversion
type InstanceEventWindow struct {
	Name *string `json:"name,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type InstanceEventWindowAssociationRequest struct {
	InstanceTags []*Tag `json:"instanceTags,omitempty"`
}

// +kubebuilder:skipversion
type InstanceEventWindowAssociationTarget struct {
	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type InstanceEventWindowDisassociationRequest struct {
	InstanceTags []*Tag `json:"instanceTags,omitempty"`
}

// +kubebuilder:skipversion
type InstanceExportDetails struct {
	InstanceID *string `json:"instanceID,omitempty"`
}

// +kubebuilder:skipversion
type InstanceFamilyCreditSpecification struct {
	CPUCredits *string `json:"cpuCredits,omitempty"`
}

// +kubebuilder:skipversion
type InstanceIPv4Prefix struct {
	IPv4Prefix *string `json:"ipv4Prefix,omitempty"`
}

// +kubebuilder:skipversion
type InstanceIPv6Address struct {
	IPv6Address *string `json:"ipv6Address,omitempty"`
}

// +kubebuilder:skipversion
type InstanceIPv6AddressRequest struct {
	IPv6Address *string `json:"ipv6Address,omitempty"`
}

// +kubebuilder:skipversion
type InstanceIPv6Prefix struct {
	IPv6Prefix *string `json:"ipv6Prefix,omitempty"`
}

// +kubebuilder:skipversion
type InstanceMarketOptionsRequest struct {
	MarketType *string `json:"marketType,omitempty"`
}

// +kubebuilder:skipversion
type InstanceMetadataOptionsRequest struct {
	HTTPPutResponseHopLimit *int64 `json:"httpPutResponseHopLimit,omitempty"`
}

// +kubebuilder:skipversion
type InstanceMetadataOptionsResponse struct {
	HTTPPutResponseHopLimit *int64 `json:"httpPutResponseHopLimit,omitempty"`
}

// +kubebuilder:skipversion
type InstanceMonitoring struct {
	InstanceID *string `json:"instanceID,omitempty"`
}

// +kubebuilder:skipversion
type InstanceNetworkInterface struct {
	Description *string `json:"description,omitempty"`

	InterfaceType *string `json:"interfaceType,omitempty"`

	IPv6Addresses []*InstanceIPv6Address `json:"ipv6Addresses,omitempty"`

	MacAddress *string `json:"macAddress,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	PrivateDNSName *string `json:"privateDNSName,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	SourceDestCheck *bool `json:"sourceDestCheck,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type InstanceNetworkInterfaceAssociation struct {
	CarrierIP *string `json:"carrierIP,omitempty"`

	CustomerOwnedIP *string `json:"customerOwnedIP,omitempty"`

	IPOwnerID *string `json:"ipOwnerID,omitempty"`

	PublicDNSName *string `json:"publicDNSName,omitempty"`

	PublicIP *string `json:"publicIP,omitempty"`
}

// +kubebuilder:skipversion
type InstanceNetworkInterfaceAttachment struct {
	AttachTime *metav1.Time `json:"attachTime,omitempty"`

	AttachmentID *string `json:"attachmentID,omitempty"`

	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	DeviceIndex *int64 `json:"deviceIndex,omitempty"`

	NetworkCardIndex *int64 `json:"networkCardIndex,omitempty"`
}

// +kubebuilder:skipversion
type InstanceNetworkInterfaceSpecification struct {
	AssociateCarrierIPAddress *bool `json:"associateCarrierIPAddress,omitempty"`

	AssociatePublicIPAddress *bool `json:"associatePublicIPAddress,omitempty"`

	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Description *string `json:"description,omitempty"`

	DeviceIndex *int64 `json:"deviceIndex,omitempty"`

	Groups []*string `json:"groups,omitempty"`

	InterfaceType *string `json:"interfaceType,omitempty"`

	IPv4PrefixCount *int64 `json:"ipv4PrefixCount,omitempty"`

	IPv4Prefixes []*IPv4PrefixSpecificationRequest `json:"ipv4Prefixes,omitempty"`

	IPv6AddressCount *int64 `json:"ipv6AddressCount,omitempty"`

	IPv6Addresses []*InstanceIPv6Address `json:"ipv6Addresses,omitempty"`

	IPv6PrefixCount *int64 `json:"ipv6PrefixCount,omitempty"`

	IPv6Prefixes []*IPv6PrefixSpecificationRequest `json:"ipv6Prefixes,omitempty"`

	NetworkCardIndex *int64 `json:"networkCardIndex,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	PrivateIPAddresses []*PrivateIPAddressSpecification `json:"privateIPAddresses,omitempty"`

	SecondaryPrivateIPAddressCount *int64 `json:"secondaryPrivateIPAddressCount,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type InstancePrivateIPAddress struct {
	Primary *bool `json:"primary,omitempty"`

	PrivateDNSName *string `json:"privateDNSName,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
}

// +kubebuilder:skipversion
type InstanceRequirements struct {
	// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web
	// Services Inferentia chips) on an instance.
	AcceleratorCount *AcceleratorCount `json:"acceleratorCount,omitempty"`

	AcceleratorManufacturers []*string `json:"acceleratorManufacturers,omitempty"`

	AcceleratorNames []*string `json:"acceleratorNames,omitempty"`
	// The minimum and maximum amount of total accelerator memory, in MiB.
	AcceleratorTotalMemoryMiB *AcceleratorTotalMemoryMiB `json:"acceleratorTotalMemoryMiB,omitempty"`

	AcceleratorTypes []*string `json:"acceleratorTypes,omitempty"`

	BareMetal *string `json:"bareMetal,omitempty"`
	// The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more
	// information, see Amazon EBSoptimized instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html)
	// in the Amazon EC2 User Guide.
	BaselineEBSBandwidthMbps *BaselineEBSBandwidthMbps `json:"baselineEBSBandwidthMbps,omitempty"`

	BurstablePerformance *string `json:"burstablePerformance,omitempty"`

	CPUManufacturers []*string `json:"cpuManufacturers,omitempty"`

	ExcludedInstanceTypes []*string `json:"excludedInstanceTypes,omitempty"`

	InstanceGenerations []*string `json:"instanceGenerations,omitempty"`

	LocalStorage *string `json:"localStorage,omitempty"`

	LocalStorageTypes []*string `json:"localStorageTypes,omitempty"`
	// The minimum and maximum amount of memory per vCPU, in GiB.
	MemoryGiBPerVCPU *MemoryGiBPerVCPU `json:"memoryGiBPerVCPU,omitempty"`
	// The minimum and maximum amount of memory, in MiB.
	MemoryMiB *MemoryMiB `json:"memoryMiB,omitempty"`
	// The minimum and maximum number of network interfaces.
	NetworkInterfaceCount *NetworkInterfaceCount `json:"networkInterfaceCount,omitempty"`

	OnDemandMaxPricePercentageOverLowestPrice *int64 `json:"onDemandMaxPricePercentageOverLowestPrice,omitempty"`

	RequireHibernateSupport *bool `json:"requireHibernateSupport,omitempty"`

	SpotMaxPricePercentageOverLowestPrice *int64 `json:"spotMaxPricePercentageOverLowestPrice,omitempty"`
	// The minimum and maximum amount of total local storage, in GB.
	TotalLocalStorageGB *TotalLocalStorageGB `json:"totalLocalStorageGB,omitempty"`
	// The minimum and maximum number of vCPUs.
	VCPUCount *VCPUCountRange `json:"vCPUCount,omitempty"`
}

// +kubebuilder:skipversion
type InstanceRequirementsRequest struct {
	// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web
	// Services Inferentia chips) on an instance. To exclude accelerator-enabled
	// instance types, set Max to 0.
	AcceleratorCount *AcceleratorCountRequest `json:"acceleratorCount,omitempty"`

	AcceleratorManufacturers []*string `json:"acceleratorManufacturers,omitempty"`

	AcceleratorNames []*string `json:"acceleratorNames,omitempty"`
	// The minimum and maximum amount of total accelerator memory, in MiB.
	AcceleratorTotalMemoryMiB *AcceleratorTotalMemoryMiBRequest `json:"acceleratorTotalMemoryMiB,omitempty"`

	AcceleratorTypes []*string `json:"acceleratorTypes,omitempty"`

	BareMetal *string `json:"bareMetal,omitempty"`
	// The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more
	// information, see Amazon EBSoptimized instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html)
	// in the Amazon EC2 User Guide.
	BaselineEBSBandwidthMbps *BaselineEBSBandwidthMbpsRequest `json:"baselineEBSBandwidthMbps,omitempty"`

	BurstablePerformance *string `json:"burstablePerformance,omitempty"`

	CPUManufacturers []*string `json:"cpuManufacturers,omitempty"`

	ExcludedInstanceTypes []*string `json:"excludedInstanceTypes,omitempty"`

	InstanceGenerations []*string `json:"instanceGenerations,omitempty"`

	LocalStorage *string `json:"localStorage,omitempty"`

	LocalStorageTypes []*string `json:"localStorageTypes,omitempty"`
	// The minimum and maximum amount of memory per vCPU, in GiB.
	MemoryGiBPerVCPU *MemoryGiBPerVCPURequest `json:"memoryGiBPerVCPU,omitempty"`
	// The minimum and maximum amount of memory, in MiB.
	MemoryMiB *MemoryMiBRequest `json:"memoryMiB,omitempty"`
	// The minimum and maximum number of network interfaces.
	NetworkInterfaceCount *NetworkInterfaceCountRequest `json:"networkInterfaceCount,omitempty"`

	OnDemandMaxPricePercentageOverLowestPrice *int64 `json:"onDemandMaxPricePercentageOverLowestPrice,omitempty"`

	RequireHibernateSupport *bool `json:"requireHibernateSupport,omitempty"`

	SpotMaxPricePercentageOverLowestPrice *int64 `json:"spotMaxPricePercentageOverLowestPrice,omitempty"`
	// The minimum and maximum amount of total local storage, in GB.
	TotalLocalStorageGB *TotalLocalStorageGBRequest `json:"totalLocalStorageGB,omitempty"`
	// The minimum and maximum number of vCPUs.
	VCPUCount *VCPUCountRangeRequest `json:"vCPUCount,omitempty"`
}

// +kubebuilder:skipversion
type InstanceRequirementsWithMetadataRequest struct {
	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple parameters, you get instance types that satisfy
	// all of the specified parameters. If you specify multiple values for a parameter,
	// you get instance types that satisfy any of the specified values.
	//
	// You must specify VCpuCount and MemoryMiB. All other parameters are optional.
	// Any unspecified optional parameter is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	InstanceRequirements *InstanceRequirementsRequest `json:"instanceRequirements,omitempty"`
}

// +kubebuilder:skipversion
type InstanceSpecification struct {
	ExcludeBootVolume *bool `json:"excludeBootVolume,omitempty"`
}

// +kubebuilder:skipversion
type InstanceState struct {
	Code *int64 `json:"code,omitempty"`
}

// +kubebuilder:skipversion
type InstanceStateChange struct {
	InstanceID *string `json:"instanceID,omitempty"`
}

// +kubebuilder:skipversion
type InstanceStatus struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`
}

// +kubebuilder:skipversion
type InstanceStatusDetails struct {
	ImpairedSince *metav1.Time `json:"impairedSince,omitempty"`
}

// +kubebuilder:skipversion
type InstanceStatusEvent struct {
	Description *string `json:"description,omitempty"`

	NotAfter *metav1.Time `json:"notAfter,omitempty"`

	NotBefore *metav1.Time `json:"notBefore,omitempty"`

	NotBeforeDeadline *metav1.Time `json:"notBeforeDeadline,omitempty"`
}

// +kubebuilder:skipversion
type InstanceTagNotificationAttribute struct {
	IncludeAllTagsOfInstance *bool `json:"includeAllTagsOfInstance,omitempty"`
}

// +kubebuilder:skipversion
type InstanceTypeInfo struct {
	InstanceType *string `json:"instanceType,omitempty"`
}

// +kubebuilder:skipversion
type InstanceTypeInfoFromInstanceRequirements struct {
	InstanceType *string `json:"instanceType,omitempty"`
}

// +kubebuilder:skipversion
type InstanceTypeOffering struct {
	InstanceType *string `json:"instanceType,omitempty"`
}

// +kubebuilder:skipversion
type InstanceUsage struct {
	AccountID *string `json:"accountID,omitempty"`

	UsedInstanceCount *int64 `json:"usedInstanceCount,omitempty"`
}

// +kubebuilder:skipversion
type InternetGateway struct {
	InternetGatewayID *string `json:"internetGatewayID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type InternetGatewayAttachment struct {
	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type KeyPairInfo struct {
	KeyFingerprint *string `json:"keyFingerprint,omitempty"`

	KeyName *string `json:"keyName,omitempty"`

	KeyPairID *string `json:"keyPairID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type LastError struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type LaunchPermission struct {
	OrganizationARN *string `json:"organizationARN,omitempty"`

	OrganizationalUnitARN *string `json:"organizationalUnitARN,omitempty"`

	UserID *string `json:"userID,omitempty"`
}

// +kubebuilder:skipversion
type LaunchSpecification struct {
	AddressingType *string `json:"addressingType,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	ImageID *string `json:"imageID,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	KernelID *string `json:"kernelID,omitempty"`

	KeyName *string `json:"keyName,omitempty"`

	RamdiskID *string `json:"ramdiskID,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	UserData *string `json:"userData,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateBlockDeviceMapping struct {
	DeviceName *string `json:"deviceName,omitempty"`
	// Describes a block device for an EBS volume.
	EBS *LaunchTemplateEBSBlockDevice `json:"ebs,omitempty"`

	NoDevice *string `json:"noDevice,omitempty"`

	VirtualName *string `json:"virtualName,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateBlockDeviceMappingRequest struct {
	DeviceName *string `json:"deviceName,omitempty"`
	// The parameters for a block device for an EBS volume.
	EBS *LaunchTemplateEBSBlockDeviceRequest `json:"ebs,omitempty"`

	NoDevice *string `json:"noDevice,omitempty"`

	VirtualName *string `json:"virtualName,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateCPUOptions struct {
	CoreCount *int64 `json:"coreCount,omitempty"`

	ThreadsPerCore *int64 `json:"threadsPerCore,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateCPUOptionsRequest struct {
	CoreCount *int64 `json:"coreCount,omitempty"`

	ThreadsPerCore *int64 `json:"threadsPerCore,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateCapacityReservationSpecificationRequest struct {
	CapacityReservationPreference *string `json:"capacityReservationPreference,omitempty"`
	// Describes a target Capacity Reservation or Capacity Reservation group.
	CapacityReservationTarget *CapacityReservationTarget `json:"capacityReservationTarget,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateCapacityReservationSpecificationResponse struct {
	CapacityReservationPreference *string `json:"capacityReservationPreference,omitempty"`
	// Describes a target Capacity Reservation or Capacity Reservation group.
	CapacityReservationTarget *CapacityReservationTargetResponse `json:"capacityReservationTarget,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateEBSBlockDevice struct {
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty"`

	IOPS *int64 `json:"iops,omitempty"`

	KMSKeyID *string `json:"kmsKeyID,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	Throughput *int64 `json:"throughput,omitempty"`

	VolumeSize *int64 `json:"volumeSize,omitempty"`

	VolumeType *string `json:"volumeType,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateEBSBlockDeviceRequest struct {
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty"`

	IOPS *int64 `json:"iops,omitempty"`

	KMSKeyID *string `json:"kmsKeyID,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	Throughput *int64 `json:"throughput,omitempty"`

	VolumeSize *int64 `json:"volumeSize,omitempty"`

	VolumeType *string `json:"volumeType,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateElasticInferenceAccelerator struct {
	Count *int64 `json:"count,omitempty"`

	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateElasticInferenceAcceleratorResponse struct {
	Count *int64 `json:"count,omitempty"`

	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateEnclaveOptions struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateEnclaveOptionsRequest struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateHibernationOptions struct {
	Configured *bool `json:"configured,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateHibernationOptionsRequest struct {
	Configured *bool `json:"configured,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateIAMInstanceProfileSpecification struct {
	ARN *string `json:"arn,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateIAMInstanceProfileSpecificationRequest struct {
	ARN *string `json:"arn,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateInstanceMarketOptions struct {
	MarketType *string `json:"marketType,omitempty"`
	// The options for Spot Instances.
	SpotOptions *LaunchTemplateSpotMarketOptions `json:"spotOptions,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateInstanceMarketOptionsRequest struct {
	MarketType *string `json:"marketType,omitempty"`
	// The options for Spot Instances.
	SpotOptions *LaunchTemplateSpotMarketOptionsRequest `json:"spotOptions,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateInstanceMetadataOptions struct {
	HTTPEndpoint *string `json:"httpEndpoint,omitempty"`

	HTTPProtocolIPv6 *string `json:"httpProtocolIPv6,omitempty"`

	HTTPPutResponseHopLimit *int64 `json:"httpPutResponseHopLimit,omitempty"`

	HTTPTokens *string `json:"httpTokens,omitempty"`

	State *string `json:"state,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateInstanceMetadataOptionsRequest struct {
	HTTPEndpoint *string `json:"httpEndpoint,omitempty"`

	HTTPProtocolIPv6 *string `json:"httpProtocolIPv6,omitempty"`

	HTTPPutResponseHopLimit *int64 `json:"httpPutResponseHopLimit,omitempty"`

	HTTPTokens *string `json:"httpTokens,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateInstanceNetworkInterfaceSpecification struct {
	AssociateCarrierIPAddress *bool `json:"associateCarrierIPAddress,omitempty"`

	AssociatePublicIPAddress *bool `json:"associatePublicIPAddress,omitempty"`

	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Description *string `json:"description,omitempty"`

	DeviceIndex *int64 `json:"deviceIndex,omitempty"`

	Groups []*string `json:"groups,omitempty"`

	InterfaceType *string `json:"interfaceType,omitempty"`

	IPv4PrefixCount *int64 `json:"ipv4PrefixCount,omitempty"`

	IPv4Prefixes []*IPv4PrefixSpecificationResponse `json:"ipv4Prefixes,omitempty"`

	IPv6AddressCount *int64 `json:"ipv6AddressCount,omitempty"`

	IPv6Addresses []*InstanceIPv6Address `json:"ipv6Addresses,omitempty"`

	IPv6PrefixCount *int64 `json:"ipv6PrefixCount,omitempty"`

	IPv6Prefixes []*IPv6PrefixSpecificationResponse `json:"ipv6Prefixes,omitempty"`

	NetworkCardIndex *int64 `json:"networkCardIndex,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	PrivateIPAddresses []*PrivateIPAddressSpecification `json:"privateIPAddresses,omitempty"`

	SecondaryPrivateIPAddressCount *int64 `json:"secondaryPrivateIPAddressCount,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateInstanceNetworkInterfaceSpecificationRequest struct {
	AssociateCarrierIPAddress *bool `json:"associateCarrierIPAddress,omitempty"`

	AssociatePublicIPAddress *bool `json:"associatePublicIPAddress,omitempty"`

	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Description *string `json:"description,omitempty"`

	DeviceIndex *int64 `json:"deviceIndex,omitempty"`

	Groups []*string `json:"groups,omitempty"`

	InterfaceType *string `json:"interfaceType,omitempty"`

	IPv4PrefixCount *int64 `json:"ipv4PrefixCount,omitempty"`

	IPv4Prefixes []*IPv4PrefixSpecificationRequest `json:"ipv4Prefixes,omitempty"`

	IPv6AddressCount *int64 `json:"ipv6AddressCount,omitempty"`

	IPv6Addresses []*InstanceIPv6AddressRequest `json:"ipv6Addresses,omitempty"`

	IPv6PrefixCount *int64 `json:"ipv6PrefixCount,omitempty"`

	IPv6Prefixes []*IPv6PrefixSpecificationRequest `json:"ipv6Prefixes,omitempty"`

	NetworkCardIndex *int64 `json:"networkCardIndex,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	PrivateIPAddresses []*PrivateIPAddressSpecification `json:"privateIPAddresses,omitempty"`

	SecondaryPrivateIPAddressCount *int64 `json:"secondaryPrivateIPAddressCount,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateLicenseConfiguration struct {
	LicenseConfigurationARN *string `json:"licenseConfigurationARN,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateLicenseConfigurationRequest struct {
	LicenseConfigurationARN *string `json:"licenseConfigurationARN,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateOverrides struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple parameters, you get instance types that satisfy
	// all of the specified parameters. If you specify multiple values for a parameter,
	// you get instance types that satisfy any of the specified values.
	//
	// You must specify VCpuCount and MemoryMiB. All other parameters are optional.
	// Any unspecified optional parameter is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	InstanceRequirements *InstanceRequirements `json:"instanceRequirements,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	Priority *float64 `json:"priority,omitempty"`

	SpotPrice *string `json:"spotPrice,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	WeightedCapacity *float64 `json:"weightedCapacity,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplatePlacement struct {
	Affinity *string `json:"affinity,omitempty"`

	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	GroupName *string `json:"groupName,omitempty"`

	HostID *string `json:"hostID,omitempty"`

	HostResourceGroupARN *string `json:"hostResourceGroupARN,omitempty"`

	PartitionNumber *int64 `json:"partitionNumber,omitempty"`

	SpreadDomain *string `json:"spreadDomain,omitempty"`

	Tenancy *string `json:"tenancy,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplatePlacementRequest struct {
	Affinity *string `json:"affinity,omitempty"`

	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	GroupName *string `json:"groupName,omitempty"`

	HostID *string `json:"hostID,omitempty"`

	HostResourceGroupARN *string `json:"hostResourceGroupARN,omitempty"`

	PartitionNumber *int64 `json:"partitionNumber,omitempty"`

	SpreadDomain *string `json:"spreadDomain,omitempty"`

	Tenancy *string `json:"tenancy,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateSpecification struct {
	LaunchTemplateID *string `json:"launchTemplateID,omitempty"`

	LaunchTemplateName *string `json:"launchTemplateName,omitempty"`

	Version *string `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateSpotMarketOptions struct {
	BlockDurationMinutes *int64 `json:"blockDurationMinutes,omitempty"`

	InstanceInterruptionBehavior *string `json:"instanceInterruptionBehavior,omitempty"`

	MaxPrice *string `json:"maxPrice,omitempty"`

	SpotInstanceType *string `json:"spotInstanceType,omitempty"`

	ValidUntil *metav1.Time `json:"validUntil,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateSpotMarketOptionsRequest struct {
	BlockDurationMinutes *int64 `json:"blockDurationMinutes,omitempty"`

	InstanceInterruptionBehavior *string `json:"instanceInterruptionBehavior,omitempty"`

	MaxPrice *string `json:"maxPrice,omitempty"`

	SpotInstanceType *string `json:"spotInstanceType,omitempty"`

	ValidUntil *metav1.Time `json:"validUntil,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateTagSpecification struct {
	ResourceType *string `json:"resourceType,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateTagSpecificationRequest struct {
	ResourceType *string `json:"resourceType,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplateVersion_SDK struct {
	CreateTime *metav1.Time `json:"createTime,omitempty"`

	CreatedBy *string `json:"createdBy,omitempty"`

	DefaultVersion *bool `json:"defaultVersion,omitempty"`
	// The information for a launch template.
	LaunchTemplateData *ResponseLaunchTemplateData `json:"launchTemplateData,omitempty"`

	LaunchTemplateID *string `json:"launchTemplateID,omitempty"`

	LaunchTemplateName *string `json:"launchTemplateName,omitempty"`

	VersionDescription *string `json:"versionDescription,omitempty"`

	VersionNumber *int64 `json:"versionNumber,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplate_SDK struct {
	CreateTime *metav1.Time `json:"createTime,omitempty"`

	CreatedBy *string `json:"createdBy,omitempty"`

	DefaultVersionNumber *int64 `json:"defaultVersionNumber,omitempty"`

	LatestVersionNumber *int64 `json:"latestVersionNumber,omitempty"`

	LaunchTemplateID *string `json:"launchTemplateID,omitempty"`

	LaunchTemplateName *string `json:"launchTemplateName,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplatesMonitoring struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type LaunchTemplatesMonitoringRequest struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type LicenseConfiguration struct {
	LicenseConfigurationARN *string `json:"licenseConfigurationARN,omitempty"`
}

// +kubebuilder:skipversion
type LicenseConfigurationRequest struct {
	LicenseConfigurationARN *string `json:"licenseConfigurationARN,omitempty"`
}

// +kubebuilder:skipversion
type LoadPermission struct {
	UserID *string `json:"userID,omitempty"`
}

// +kubebuilder:skipversion
type LoadPermissionRequest struct {
	UserID *string `json:"userID,omitempty"`
}

// +kubebuilder:skipversion
type LocalGateway struct {
	LocalGatewayID *string `json:"localGatewayID,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type LocalGatewayRoute struct {
	DestinationCIDRBlock *string `json:"destinationCIDRBlock,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`
}

// +kubebuilder:skipversion
type LocalGatewayRouteTable struct {
	LocalGatewayID *string `json:"localGatewayID,omitempty"`

	LocalGatewayRouteTableID *string `json:"localGatewayRouteTableID,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type LocalGatewayRouteTableVPCAssociation struct {
	LocalGatewayID *string `json:"localGatewayID,omitempty"`

	LocalGatewayRouteTableID *string `json:"localGatewayRouteTableID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type LocalGatewayRouteTableVirtualInterfaceGroupAssociation struct {
	LocalGatewayID *string `json:"localGatewayID,omitempty"`

	LocalGatewayRouteTableID *string `json:"localGatewayRouteTableID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type LocalGatewayVirtualInterface struct {
	LocalAddress *string `json:"localAddress,omitempty"`

	LocalBGPASN *int64 `json:"localBGPASN,omitempty"`

	LocalGatewayID *string `json:"localGatewayID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	PeerAddress *string `json:"peerAddress,omitempty"`

	PeerBGPASN *int64 `json:"peerBGPASN,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VLAN *int64 `json:"vlan,omitempty"`
}

// +kubebuilder:skipversion
type LocalGatewayVirtualInterfaceGroup struct {
	LocalGatewayID *string `json:"localGatewayID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ManagedPrefixList struct {
	AddressFamily *string `json:"addressFamily,omitempty"`

	MaxEntries *int64 `json:"maxEntries,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	PrefixListID *string `json:"prefixListID,omitempty"`

	PrefixListName *string `json:"prefixListName,omitempty"`

	StateMessage *string `json:"stateMessage,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	Version *int64 `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type MemoryGiBPerVCPU struct {
	Max *float64 `json:"max,omitempty"`

	Min *float64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type MemoryGiBPerVCPURequest struct {
	Max *float64 `json:"max,omitempty"`

	Min *float64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type MemoryMiB struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type MemoryMiBRequest struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type ModifyTransitGatewayOptions struct {
	AutoAcceptSharedAttachments *string `json:"autoAcceptSharedAttachments,omitempty"`

	DefaultRouteTableAssociation *string `json:"defaultRouteTableAssociation,omitempty"`

	DefaultRouteTablePropagation *string `json:"defaultRouteTablePropagation,omitempty"`

	DNSSupport *string `json:"dnsSupport,omitempty"`

	VPNECMPSupport *string `json:"vpnECMPSupport,omitempty"`
}

// +kubebuilder:skipversion
type ModifyTransitGatewayVPCAttachmentRequestOptions struct {
	ApplianceModeSupport *string `json:"applianceModeSupport,omitempty"`

	DNSSupport *string `json:"dnsSupport,omitempty"`

	IPv6Support *string `json:"ipv6Support,omitempty"`
}

// +kubebuilder:skipversion
type ModifyVPNTunnelOptionsSpecification struct {
	DPDTimeoutAction *string `json:"dpdTimeoutAction,omitempty"`

	DPDTimeoutSeconds *int64 `json:"dpdTimeoutSeconds,omitempty"`

	Phase1LifetimeSeconds *int64 `json:"phase1LifetimeSeconds,omitempty"`

	Phase2LifetimeSeconds *int64 `json:"phase2LifetimeSeconds,omitempty"`

	PreSharedKey *string `json:"preSharedKey,omitempty"`

	RekeyFuzzPercentage *int64 `json:"rekeyFuzzPercentage,omitempty"`

	RekeyMarginTimeSeconds *int64 `json:"rekeyMarginTimeSeconds,omitempty"`

	ReplayWindowSize *int64 `json:"replayWindowSize,omitempty"`

	StartupAction *string `json:"startupAction,omitempty"`

	TunnelInsideCIDR *string `json:"tunnelInsideCIDR,omitempty"`

	TunnelInsideIPv6CIDR *string `json:"tunnelInsideIPv6CIDR,omitempty"`
}

// +kubebuilder:skipversion
type MovingAddressStatus struct {
	PublicIP *string `json:"publicIP,omitempty"`
}

// +kubebuilder:skipversion
type NATGateway struct {
	CreateTime *metav1.Time `json:"createTime,omitempty"`

	DeleteTime *metav1.Time `json:"deleteTime,omitempty"`

	FailureCode *string `json:"failureCode,omitempty"`

	FailureMessage *string `json:"failureMessage,omitempty"`

	NATGatewayID *string `json:"natGatewayID,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type NATGatewayAddress struct {
	AllocationID *string `json:"allocationID,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	PrivateIP *string `json:"privateIP,omitempty"`

	PublicIP *string `json:"publicIP,omitempty"`
}

// +kubebuilder:skipversion
type NetworkACL struct {
	IsDefault *bool `json:"isDefault,omitempty"`

	NetworkACLID *string `json:"networkACLID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type NetworkACLAssociation struct {
	NetworkACLAssociationID *string `json:"networkACLAssociationID,omitempty"`

	NetworkACLID *string `json:"networkACLID,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type NetworkACLEntry struct {
	CIDRBlock *string `json:"cidrBlock,omitempty"`

	Egress *bool `json:"egress,omitempty"`

	IPv6CIDRBlock *string `json:"ipv6CIDRBlock,omitempty"`

	Protocol *string `json:"protocol,omitempty"`

	RuleNumber *int64 `json:"ruleNumber,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInsightsAnalysis struct {
	NetworkPathFound *bool `json:"networkPathFound,omitempty"`

	StartDate *metav1.Time `json:"startDate,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInsightsPath struct {
	CreatedDate *metav1.Time `json:"createdDate,omitempty"`

	Destination *string `json:"destination,omitempty"`

	DestinationPort *int64 `json:"destinationPort,omitempty"`

	Source *string `json:"source,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterface struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	DenyAllIgwTraffic *bool `json:"denyAllIgwTraffic,omitempty"`

	Description *string `json:"description,omitempty"`

	MacAddress *string `json:"macAddress,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	PrivateDNSName *string `json:"privateDNSName,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	RequesterID *string `json:"requesterID,omitempty"`

	RequesterManaged *bool `json:"requesterManaged,omitempty"`

	SourceDestCheck *bool `json:"sourceDestCheck,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	TagSet []*Tag `json:"tagSet,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfaceAssociation struct {
	AllocationID *string `json:"allocationID,omitempty"`

	AssociationID *string `json:"associationID,omitempty"`

	CarrierIP *string `json:"carrierIP,omitempty"`

	CustomerOwnedIP *string `json:"customerOwnedIP,omitempty"`

	IPOwnerID *string `json:"ipOwnerID,omitempty"`

	PublicDNSName *string `json:"publicDNSName,omitempty"`

	PublicIP *string `json:"publicIP,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfaceAttachment struct {
	AttachTime *metav1.Time `json:"attachTime,omitempty"`

	AttachmentID *string `json:"attachmentID,omitempty"`

	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	DeviceIndex *int64 `json:"deviceIndex,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	InstanceOwnerID *string `json:"instanceOwnerID,omitempty"`

	NetworkCardIndex *int64 `json:"networkCardIndex,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfaceAttachmentChanges struct {
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfaceCount struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfaceCountRequest struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfaceIPv6Address struct {
	IPv6Address *string `json:"ipv6Address,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfacePermission struct {
	AWSAccountID *string `json:"awsAccountID,omitempty"`

	AWSService *string `json:"awsService,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	NetworkInterfacePermissionID *string `json:"networkInterfacePermissionID,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfacePermissionState struct {
	StatusMessage *string `json:"statusMessage,omitempty"`
}

// +kubebuilder:skipversion
type NetworkInterfacePrivateIPAddress struct {
	Primary *bool `json:"primary,omitempty"`

	PrivateDNSName *string `json:"privateDNSName,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
}

// +kubebuilder:skipversion
type NewDHCPConfiguration struct {
	Key *string `json:"key,omitempty"`

	Values []*string `json:"values,omitempty"`
}

// +kubebuilder:skipversion
type OnDemandOptions struct {
	MaxTotalPrice *string `json:"maxTotalPrice,omitempty"`

	MinTargetCapacity *int64 `json:"minTargetCapacity,omitempty"`

	SingleAvailabilityZone *bool `json:"singleAvailabilityZone,omitempty"`

	SingleInstanceType *bool `json:"singleInstanceType,omitempty"`
}

// +kubebuilder:skipversion
type OnDemandOptionsRequest struct {
	MaxTotalPrice *string `json:"maxTotalPrice,omitempty"`

	MinTargetCapacity *int64 `json:"minTargetCapacity,omitempty"`

	SingleAvailabilityZone *bool `json:"singleAvailabilityZone,omitempty"`

	SingleInstanceType *bool `json:"singleInstanceType,omitempty"`
}

// +kubebuilder:skipversion
type PathComponent struct {
	SequenceNumber *int64 `json:"sequenceNumber,omitempty"`
}

// +kubebuilder:skipversion
type PciID struct {
	DeviceID *string `json:"deviceID,omitempty"`

	SubsystemID *string `json:"subsystemID,omitempty"`

	SubsystemVendorID *string `json:"subsystemVendorID,omitempty"`

	VendorID *string `json:"vendorID,omitempty"`
}

// +kubebuilder:skipversion
type PeeringAttachmentStatus struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type PeeringConnectionOptions struct {
	AllowDNSResolutionFromRemoteVPC *bool `json:"allowDNSResolutionFromRemoteVPC,omitempty"`

	AllowEgressFromLocalClassicLinkToRemoteVPC *bool `json:"allowEgressFromLocalClassicLinkToRemoteVPC,omitempty"`

	AllowEgressFromLocalVPCToRemoteClassicLink *bool `json:"allowEgressFromLocalVPCToRemoteClassicLink,omitempty"`
}

// +kubebuilder:skipversion
type PeeringConnectionOptionsRequest struct {
	AllowDNSResolutionFromRemoteVPC *bool `json:"allowDNSResolutionFromRemoteVPC,omitempty"`

	AllowEgressFromLocalClassicLinkToRemoteVPC *bool `json:"allowEgressFromLocalClassicLinkToRemoteVPC,omitempty"`

	AllowEgressFromLocalVPCToRemoteClassicLink *bool `json:"allowEgressFromLocalVPCToRemoteClassicLink,omitempty"`
}

// +kubebuilder:skipversion
type PeeringTgwInfo struct {
	OwnerID *string `json:"ownerID,omitempty"`

	Region *string `json:"region,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`
}

// +kubebuilder:skipversion
type Phase1DHGroupNumbersListValue struct {
	Value *int64 `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase1DHGroupNumbersRequestListValue struct {
	Value *int64 `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase1EncryptionAlgorithmsListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase1EncryptionAlgorithmsRequestListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase1IntegrityAlgorithmsListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase1IntegrityAlgorithmsRequestListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase2DHGroupNumbersListValue struct {
	Value *int64 `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase2DHGroupNumbersRequestListValue struct {
	Value *int64 `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase2EncryptionAlgorithmsListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase2EncryptionAlgorithmsRequestListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase2IntegrityAlgorithmsListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Phase2IntegrityAlgorithmsRequestListValue struct {
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Placement struct {
	Affinity *string `json:"affinity,omitempty"`

	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	GroupName *string `json:"groupName,omitempty"`

	HostID *string `json:"hostID,omitempty"`

	HostResourceGroupARN *string `json:"hostResourceGroupARN,omitempty"`

	PartitionNumber *int64 `json:"partitionNumber,omitempty"`

	SpreadDomain *string `json:"spreadDomain,omitempty"`

	Tenancy *string `json:"tenancy,omitempty"`
}

// +kubebuilder:skipversion
type PlacementGroup struct {
	GroupID *string `json:"groupID,omitempty"`

	GroupName *string `json:"groupName,omitempty"`

	PartitionCount *int64 `json:"partitionCount,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type PlacementResponse struct {
	GroupName *string `json:"groupName,omitempty"`
}

// +kubebuilder:skipversion
type PoolCIDRBlock struct {
	CIDR *string `json:"cidr,omitempty"`
}

// +kubebuilder:skipversion
type PortRange struct {
	From *int64 `json:"from,omitempty"`

	To *int64 `json:"to,omitempty"`
}

// +kubebuilder:skipversion
type PrefixList struct {
	CIDRs []*string `json:"cidrs,omitempty"`

	PrefixListID *string `json:"prefixListID,omitempty"`

	PrefixListName *string `json:"prefixListName,omitempty"`
}

// +kubebuilder:skipversion
type PrefixListAssociation struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceOwner *string `json:"resourceOwner,omitempty"`
}

// +kubebuilder:skipversion
type PrefixListEntry struct {
	CIDR *string `json:"cidr,omitempty"`

	Description *string `json:"description,omitempty"`
}

// +kubebuilder:skipversion
type PrefixListID struct {
	Description *string `json:"description,omitempty"`

	PrefixListID *string `json:"prefixListID,omitempty"`
}

// +kubebuilder:skipversion
type PriceSchedule struct {
	Active *bool `json:"active,omitempty"`

	Price *float64 `json:"price,omitempty"`

	Term *int64 `json:"term,omitempty"`
}

// +kubebuilder:skipversion
type PriceScheduleSpecification struct {
	Price *float64 `json:"price,omitempty"`

	Term *int64 `json:"term,omitempty"`
}

// +kubebuilder:skipversion
type PricingDetail struct {
	Count *int64 `json:"count,omitempty"`

	Price *float64 `json:"price,omitempty"`
}

// +kubebuilder:skipversion
type PrincipalIDFormat struct {
	ARN *string `json:"arn,omitempty"`
}

// +kubebuilder:skipversion
type PrivateDNSDetails struct {
	PrivateDNSName *string `json:"privateDNSName,omitempty"`
}

// +kubebuilder:skipversion
type PrivateDNSNameConfiguration struct {
	Name *string `json:"name,omitempty"`

	State *string `json:"state,omitempty"`

	Type *string `json:"type_,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type PrivateIPAddressSpecification struct {
	Primary *bool `json:"primary,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
}

// +kubebuilder:skipversion
type ProductCode struct {
	ProductCodeID *string `json:"productCodeID,omitempty"`
}

// +kubebuilder:skipversion
type PropagatingVGW struct {
	GatewayID *string `json:"gatewayID,omitempty"`
}

// +kubebuilder:skipversion
type ProvisionedBandwidth struct {
	ProvisionTime *metav1.Time `json:"provisionTime,omitempty"`

	Provisioned *string `json:"provisioned,omitempty"`

	RequestTime *metav1.Time `json:"requestTime,omitempty"`

	Requested *string `json:"requested,omitempty"`

	Status *string `json:"status,omitempty"`
}

// +kubebuilder:skipversion
type PtrUpdateStatus struct {
	Reason *string `json:"reason,omitempty"`

	Status *string `json:"status,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type PublicIPv4Pool struct {
	Description *string `json:"description,omitempty"`

	NetworkBorderGroup *string `json:"networkBorderGroup,omitempty"`

	PoolID *string `json:"poolID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TotalAddressCount *int64 `json:"totalAddressCount,omitempty"`

	TotalAvailableAddressCount *int64 `json:"totalAvailableAddressCount,omitempty"`
}

// +kubebuilder:skipversion
type PublicIPv4PoolRange struct {
	AddressCount *int64 `json:"addressCount,omitempty"`

	AvailableAddressCount *int64 `json:"availableAddressCount,omitempty"`

	FirstAddress *string `json:"firstAddress,omitempty"`

	LastAddress *string `json:"lastAddress,omitempty"`
}

// +kubebuilder:skipversion
type Purchase struct {
	Duration *int64 `json:"duration,omitempty"`

	HostReservationID *string `json:"hostReservationID,omitempty"`

	HourlyPrice *string `json:"hourlyPrice,omitempty"`

	InstanceFamily *string `json:"instanceFamily,omitempty"`

	UpfrontPrice *string `json:"upfrontPrice,omitempty"`
}

// +kubebuilder:skipversion
type PurchaseRequest struct {
	InstanceCount *int64 `json:"instanceCount,omitempty"`

	PurchaseToken *string `json:"purchaseToken,omitempty"`
}

// +kubebuilder:skipversion
type RecurringCharge struct {
	Amount *float64 `json:"amount,omitempty"`
}

// +kubebuilder:skipversion
type ReferencedSecurityGroup struct {
	GroupID *string `json:"groupID,omitempty"`

	PeeringStatus *string `json:"peeringStatus,omitempty"`

	UserID *string `json:"userID,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`

	VPCPeeringConnectionID *string `json:"vpcPeeringConnectionID,omitempty"`
}

// +kubebuilder:skipversion
type Region struct {
	Endpoint *string `json:"endpoint,omitempty"`

	OptInStatus *string `json:"optInStatus,omitempty"`

	RegionName *string `json:"regionName,omitempty"`
}

// +kubebuilder:skipversion
type RegisterInstanceTagAttributeRequest struct {
	IncludeAllTagsOfInstance *bool `json:"includeAllTagsOfInstance,omitempty"`
}

// +kubebuilder:skipversion
type RemovePrefixListEntry struct {
	CIDR *string `json:"cidr,omitempty"`
}

// +kubebuilder:skipversion
type ReplaceRootVolumeTask struct {
	CompleteTime *string `json:"completeTime,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	StartTime *string `json:"startTime,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type RequestLaunchTemplateData struct {
	BlockDeviceMappings []*LaunchTemplateBlockDeviceMappingRequest `json:"blockDeviceMappings,omitempty"`
	// Describes an instance's Capacity Reservation targeting option. You can specify
	// only one option at a time. Use the CapacityReservationPreference parameter
	// to configure the instance to run in On-Demand capacity or to run in any open
	// Capacity Reservation that has matching attributes (instance type, platform,
	// Availability Zone). Use the CapacityReservationTarget parameter to explicitly
	// target a specific Capacity Reservation or a Capacity Reservation group.
	CapacityReservationSpecification *LaunchTemplateCapacityReservationSpecificationRequest `json:"capacityReservationSpecification,omitempty"`
	// The CPU options for the instance. Both the core count and threads per core
	// must be specified in the request.
	CPUOptions *LaunchTemplateCPUOptionsRequest `json:"cpuOptions,omitempty"`
	// The credit option for CPU usage of a T2, T3, or T3a instance.
	CreditSpecification *CreditSpecificationRequest `json:"creditSpecification,omitempty"`

	DisableAPITermination *bool `json:"disableAPITermination,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	ElasticGPUSpecifications []*ElasticGPUSpecification `json:"elasticGPUSpecifications,omitempty"`

	ElasticInferenceAccelerators []*LaunchTemplateElasticInferenceAccelerator `json:"elasticInferenceAccelerators,omitempty"`
	// Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.
	// For more information, see What is Amazon Web Services Nitro Enclaves? (https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html)
	// in the Amazon Web Services Nitro Enclaves User Guide.
	EnclaveOptions *LaunchTemplateEnclaveOptionsRequest `json:"enclaveOptions,omitempty"`
	// Indicates whether the instance is configured for hibernation. This parameter
	// is valid only if the instance meets the hibernation prerequisites (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites).
	HibernationOptions *LaunchTemplateHibernationOptionsRequest `json:"hibernationOptions,omitempty"`
	// An IAM instance profile.
	IAMInstanceProfile *LaunchTemplateIAMInstanceProfileSpecificationRequest `json:"iamInstanceProfile,omitempty"`

	ImageID *string `json:"imageID,omitempty"`

	InstanceInitiatedShutdownBehavior *string `json:"instanceInitiatedShutdownBehavior,omitempty"`
	// The market (purchasing) option for the instances.
	InstanceMarketOptions *LaunchTemplateInstanceMarketOptionsRequest `json:"instanceMarketOptions,omitempty"`
	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple parameters, you get instance types that satisfy
	// all of the specified parameters. If you specify multiple values for a parameter,
	// you get instance types that satisfy any of the specified values.
	//
	// You must specify VCpuCount and MemoryMiB. All other parameters are optional.
	// Any unspecified optional parameter is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	InstanceRequirements *InstanceRequirementsRequest `json:"instanceRequirements,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	KernelID *string `json:"kernelID,omitempty"`

	KeyName *string `json:"keyName,omitempty"`

	LicenseSpecifications []*LaunchTemplateLicenseConfigurationRequest `json:"licenseSpecifications,omitempty"`
	// The metadata options for the instance. For more information, see Instance
	// Metadata and User Data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)
	// in the Amazon Elastic Compute Cloud User Guide.
	MetadataOptions *LaunchTemplateInstanceMetadataOptionsRequest `json:"metadataOptions,omitempty"`
	// Describes the monitoring for the instance.
	Monitoring *LaunchTemplatesMonitoringRequest `json:"monitoring,omitempty"`

	NetworkInterfaces []*LaunchTemplateInstanceNetworkInterfaceSpecificationRequest `json:"networkInterfaces,omitempty"`
	// Describes the placement of an instance.
	Placement *LaunchTemplatePlacementRequest `json:"placement,omitempty"`

	RamDiskID *string `json:"ramDiskID,omitempty"`

	SecurityGroupIDs []*string `json:"securityGroupIDs,omitempty"`

	SecurityGroups []*string `json:"securityGroups,omitempty"`

	TagSpecifications []*LaunchTemplateTagSpecificationRequest `json:"tagSpecifications,omitempty"`

	UserData *string `json:"userData,omitempty"`
}

// +kubebuilder:skipversion
type RequestSpotLaunchSpecification struct {
	AddressingType *string `json:"addressingType,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	ImageID *string `json:"imageID,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	KernelID *string `json:"kernelID,omitempty"`

	KeyName *string `json:"keyName,omitempty"`

	RamdiskID *string `json:"ramdiskID,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	UserData *string `json:"userData,omitempty"`
}

// +kubebuilder:skipversion
type ReservationFleetInstanceSpecification struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	AvailabilityZoneID *string `json:"availabilityZoneID,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`
}

// +kubebuilder:skipversion
type ReservationValue struct {
	HourlyPrice *string `json:"hourlyPrice,omitempty"`

	RemainingTotalValue *string `json:"remainingTotalValue,omitempty"`

	RemainingUpfrontValue *string `json:"remainingUpfrontValue,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstanceLimitPrice struct {
	Amount *float64 `json:"amount,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstanceReservationValue struct {
	ReservedInstanceID *string `json:"reservedInstanceID,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstances struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	Duration *int64 `json:"duration,omitempty"`

	End *metav1.Time `json:"end,omitempty"`

	InstanceCount *int64 `json:"instanceCount,omitempty"`

	InstanceTenancy *string `json:"instanceTenancy,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	ReservedInstancesID *string `json:"reservedInstancesID,omitempty"`

	Start *metav1.Time `json:"start,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstancesConfiguration struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	InstanceCount *int64 `json:"instanceCount,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	Platform *string `json:"platform,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstancesID struct {
	ReservedInstancesID *string `json:"reservedInstancesID,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstancesListing struct {
	ClientToken *string `json:"clientToken,omitempty"`

	CreateDate *metav1.Time `json:"createDate,omitempty"`

	ReservedInstancesID *string `json:"reservedInstancesID,omitempty"`

	ReservedInstancesListingID *string `json:"reservedInstancesListingID,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	UpdateDate *metav1.Time `json:"updateDate,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstancesModification struct {
	ClientToken *string `json:"clientToken,omitempty"`

	CreateDate *metav1.Time `json:"createDate,omitempty"`

	EffectiveDate *metav1.Time `json:"effectiveDate,omitempty"`

	ReservedInstancesModificationID *string `json:"reservedInstancesModificationID,omitempty"`

	Status *string `json:"status,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	UpdateDate *metav1.Time `json:"updateDate,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstancesModificationResult struct {
	ReservedInstancesID *string `json:"reservedInstancesID,omitempty"`
}

// +kubebuilder:skipversion
type ReservedInstancesOffering struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	Duration *int64 `json:"duration,omitempty"`

	InstanceTenancy *string `json:"instanceTenancy,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	Marketplace *bool `json:"marketplace,omitempty"`

	ReservedInstancesOfferingID *string `json:"reservedInstancesOfferingID,omitempty"`
}

// +kubebuilder:skipversion
type ResponseError struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type ResponseLaunchTemplateData struct {
	BlockDeviceMappings []*LaunchTemplateBlockDeviceMapping `json:"blockDeviceMappings,omitempty"`
	// Information about the Capacity Reservation targeting option.
	CapacityReservationSpecification *LaunchTemplateCapacityReservationSpecificationResponse `json:"capacityReservationSpecification,omitempty"`
	// The CPU options for the instance.
	CPUOptions *LaunchTemplateCPUOptions `json:"cpuOptions,omitempty"`
	// Describes the credit option for CPU usage of a T2, T3, or T3a instance.
	CreditSpecification *CreditSpecification `json:"creditSpecification,omitempty"`

	DisableAPITermination *bool `json:"disableAPITermination,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	ElasticGPUSpecifications []*ElasticGPUSpecificationResponse `json:"elasticGPUSpecifications,omitempty"`

	ElasticInferenceAccelerators []*LaunchTemplateElasticInferenceAcceleratorResponse `json:"elasticInferenceAccelerators,omitempty"`
	// Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.
	EnclaveOptions *LaunchTemplateEnclaveOptions `json:"enclaveOptions,omitempty"`
	// Indicates whether an instance is configured for hibernation.
	HibernationOptions *LaunchTemplateHibernationOptions `json:"hibernationOptions,omitempty"`
	// Describes an IAM instance profile.
	IAMInstanceProfile *LaunchTemplateIAMInstanceProfileSpecification `json:"iamInstanceProfile,omitempty"`

	ImageID *string `json:"imageID,omitempty"`

	InstanceInitiatedShutdownBehavior *string `json:"instanceInitiatedShutdownBehavior,omitempty"`
	// The market (purchasing) option for the instances.
	InstanceMarketOptions *LaunchTemplateInstanceMarketOptions `json:"instanceMarketOptions,omitempty"`
	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple parameters, you get instance types that satisfy
	// all of the specified parameters. If you specify multiple values for a parameter,
	// you get instance types that satisfy any of the specified values.
	//
	// You must specify VCpuCount and MemoryMiB. All other parameters are optional.
	// Any unspecified optional parameter is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	InstanceRequirements *InstanceRequirements `json:"instanceRequirements,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	KernelID *string `json:"kernelID,omitempty"`

	KeyName *string `json:"keyName,omitempty"`

	LicenseSpecifications []*LaunchTemplateLicenseConfiguration `json:"licenseSpecifications,omitempty"`
	// The metadata options for the instance. For more information, see Instance
	// Metadata and User Data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)
	// in the Amazon Elastic Compute Cloud User Guide.
	MetadataOptions *LaunchTemplateInstanceMetadataOptions `json:"metadataOptions,omitempty"`
	// Describes the monitoring for the instance.
	Monitoring *LaunchTemplatesMonitoring `json:"monitoring,omitempty"`

	NetworkInterfaces []*LaunchTemplateInstanceNetworkInterfaceSpecification `json:"networkInterfaces,omitempty"`
	// Describes the placement of an instance.
	Placement *LaunchTemplatePlacement `json:"placement,omitempty"`

	RamDiskID *string `json:"ramDiskID,omitempty"`

	SecurityGroupIDs []*string `json:"securityGroupIDs,omitempty"`

	SecurityGroups []*string `json:"securityGroups,omitempty"`

	TagSpecifications []*LaunchTemplateTagSpecification `json:"tagSpecifications,omitempty"`

	UserData *string `json:"userData,omitempty"`
}

// +kubebuilder:skipversion
type RouteTable struct {
	OwnerID *string `json:"ownerID,omitempty"`

	RouteTableID *string `json:"routeTableID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type RouteTableAssociation struct {
	GatewayID *string `json:"gatewayID,omitempty"`

	Main *bool `json:"main,omitempty"`

	RouteTableAssociationID *string `json:"routeTableAssociationID,omitempty"`

	RouteTableID *string `json:"routeTableID,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type RouteTableAssociationState struct {
	StatusMessage *string `json:"statusMessage,omitempty"`
}

// +kubebuilder:skipversion
type Route_SDK struct {
	CarrierGatewayID *string `json:"carrierGatewayID,omitempty"`

	DestinationCIDRBlock *string `json:"destinationCIDRBlock,omitempty"`

	DestinationIPv6CIDRBlock *string `json:"destinationIPv6CIDRBlock,omitempty"`

	DestinationPrefixListID *string `json:"destinationPrefixListID,omitempty"`

	EgressOnlyInternetGatewayID *string `json:"egressOnlyInternetGatewayID,omitempty"`

	GatewayID *string `json:"gatewayID,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	InstanceOwnerID *string `json:"instanceOwnerID,omitempty"`

	LocalGatewayID *string `json:"localGatewayID,omitempty"`

	NATGatewayID *string `json:"natGatewayID,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`

	VPCPeeringConnectionID *string `json:"vpcPeeringConnectionID,omitempty"`
}

// +kubebuilder:skipversion
type RunInstancesMonitoringEnabled struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type S3ObjectTag struct {
	Key *string `json:"key,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type S3Storage struct {
	AWSAccessKeyID *string `json:"awsAccessKeyID,omitempty"`

	Bucket *string `json:"bucket,omitempty"`

	Prefix *string `json:"prefix,omitempty"`

	UploadPolicySignature *string `json:"uploadPolicySignature,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstance struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	CreateDate *metav1.Time `json:"createDate,omitempty"`

	HourlyPrice *string `json:"hourlyPrice,omitempty"`

	InstanceCount *int64 `json:"instanceCount,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	NetworkPlatform *string `json:"networkPlatform,omitempty"`

	NextSlotStartTime *metav1.Time `json:"nextSlotStartTime,omitempty"`

	Platform *string `json:"platform,omitempty"`

	PreviousSlotEndTime *metav1.Time `json:"previousSlotEndTime,omitempty"`

	ScheduledInstanceID *string `json:"scheduledInstanceID,omitempty"`

	SlotDurationInHours *int64 `json:"slotDurationInHours,omitempty"`

	TermEndDate *metav1.Time `json:"termEndDate,omitempty"`

	TermStartDate *metav1.Time `json:"termStartDate,omitempty"`

	TotalScheduledInstanceHours *int64 `json:"totalScheduledInstanceHours,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstanceAvailability struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	AvailableInstanceCount *int64 `json:"availableInstanceCount,omitempty"`

	FirstSlotStartTime *metav1.Time `json:"firstSlotStartTime,omitempty"`

	HourlyPrice *string `json:"hourlyPrice,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	MaxTermDurationInDays *int64 `json:"maxTermDurationInDays,omitempty"`

	MinTermDurationInDays *int64 `json:"minTermDurationInDays,omitempty"`

	NetworkPlatform *string `json:"networkPlatform,omitempty"`

	Platform *string `json:"platform,omitempty"`

	PurchaseToken *string `json:"purchaseToken,omitempty"`

	SlotDurationInHours *int64 `json:"slotDurationInHours,omitempty"`

	TotalScheduledInstanceHours *int64 `json:"totalScheduledInstanceHours,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstanceRecurrence struct {
	Frequency *string `json:"frequency,omitempty"`

	Interval *int64 `json:"interval,omitempty"`

	OccurrenceRelativeToEnd *bool `json:"occurrenceRelativeToEnd,omitempty"`

	OccurrenceUnit *string `json:"occurrenceUnit,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstanceRecurrenceRequest struct {
	Frequency *string `json:"frequency,omitempty"`

	Interval *int64 `json:"interval,omitempty"`

	OccurrenceRelativeToEnd *bool `json:"occurrenceRelativeToEnd,omitempty"`

	OccurrenceUnit *string `json:"occurrenceUnit,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstancesBlockDeviceMapping struct {
	DeviceName *string `json:"deviceName,omitempty"`

	NoDevice *string `json:"noDevice,omitempty"`

	VirtualName *string `json:"virtualName,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstancesEBS struct {
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty"`

	IOPS *int64 `json:"iops,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	VolumeSize *int64 `json:"volumeSize,omitempty"`

	VolumeType *string `json:"volumeType,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstancesIAMInstanceProfile struct {
	ARN *string `json:"arn,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstancesLaunchSpecification struct {
	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	ImageID *string `json:"imageID,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	KernelID *string `json:"kernelID,omitempty"`

	KeyName *string `json:"keyName,omitempty"`

	RamdiskID *string `json:"ramdiskID,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	UserData *string `json:"userData,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstancesMonitoring struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstancesNetworkInterface struct {
	AssociatePublicIPAddress *bool `json:"associatePublicIPAddress,omitempty"`

	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Description *string `json:"description,omitempty"`

	DeviceIndex *int64 `json:"deviceIndex,omitempty"`

	IPv6AddressCount *int64 `json:"ipv6AddressCount,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	SecondaryPrivateIPAddressCount *int64 `json:"secondaryPrivateIPAddressCount,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstancesPlacement struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	GroupName *string `json:"groupName,omitempty"`
}

// +kubebuilder:skipversion
type ScheduledInstancesPrivateIPAddressConfig struct {
	Primary *bool `json:"primary,omitempty"`

	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
}

// +kubebuilder:skipversion
type SecurityGroup struct {
	Description *string `json:"description,omitempty"`

	GroupID *string `json:"groupID,omitempty"`

	GroupName *string `json:"groupName,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type SecurityGroupIdentifier struct {
	GroupID *string `json:"groupID,omitempty"`

	GroupName *string `json:"groupName,omitempty"`
}

// +kubebuilder:skipversion
type SecurityGroupReference struct {
	GroupID *string `json:"groupID,omitempty"`

	ReferencingVPCID *string `json:"referencingVPCID,omitempty"`

	VPCPeeringConnectionID *string `json:"vpcPeeringConnectionID,omitempty"`
}

// +kubebuilder:skipversion
type SecurityGroupRule struct {
	CIDRIPv4 *string `json:"cidrIPv4,omitempty"`

	CIDRIPv6 *string `json:"cidrIPv6,omitempty"`

	Description *string `json:"description,omitempty"`

	FromPort *int64 `json:"fromPort,omitempty"`

	GroupID *string `json:"groupID,omitempty"`

	GroupOwnerID *string `json:"groupOwnerID,omitempty"`

	IPProtocol *string `json:"ipProtocol,omitempty"`

	IsEgress *bool `json:"isEgress,omitempty"`

	PrefixListID *string `json:"prefixListID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	ToPort *int64 `json:"toPort,omitempty"`
}

// +kubebuilder:skipversion
type SecurityGroupRuleDescription struct {
	Description *string `json:"description,omitempty"`

	SecurityGroupRuleID *string `json:"securityGroupRuleID,omitempty"`
}

// +kubebuilder:skipversion
type SecurityGroupRuleRequest struct {
	CIDRIPv4 *string `json:"cidrIPv4,omitempty"`

	CIDRIPv6 *string `json:"cidrIPv6,omitempty"`

	Description *string `json:"description,omitempty"`

	FromPort *int64 `json:"fromPort,omitempty"`

	IPProtocol *string `json:"ipProtocol,omitempty"`

	PrefixListID *string `json:"prefixListID,omitempty"`

	ReferencedGroupID *string `json:"referencedGroupID,omitempty"`

	ToPort *int64 `json:"toPort,omitempty"`
}

// +kubebuilder:skipversion
type ServiceConfiguration struct {
	AcceptanceRequired *bool `json:"acceptanceRequired,omitempty"`

	AvailabilityZones []*string `json:"availabilityZones,omitempty"`

	BaseEndpointDNSNames []*string `json:"baseEndpointDNSNames,omitempty"`

	GatewayLoadBalancerARNs []*string `json:"gatewayLoadBalancerARNs,omitempty"`

	ManagesVPCEndpoints *bool `json:"managesVPCEndpoints,omitempty"`

	NetworkLoadBalancerARNs []*string `json:"networkLoadBalancerARNs,omitempty"`

	PrivateDNSName *string `json:"privateDNSName,omitempty"`
	// Information about the private DNS name for the service endpoint. For more
	// information about these parameters, see VPC Endpoint Service Private DNS
	// Name Verification (https://docs.aws.amazon.com/vpc/latest/userguide/ndpoint-services-dns-validation.html)
	// in the Amazon Virtual Private Cloud User Guide.
	PrivateDNSNameConfiguration *PrivateDNSNameConfiguration `json:"privateDNSNameConfiguration,omitempty"`

	ServiceID *string `json:"serviceID,omitempty"`

	ServiceName *string `json:"serviceName,omitempty"`

	ServiceState *string `json:"serviceState,omitempty"`

	ServiceType []*ServiceTypeDetail `json:"serviceType,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type ServiceDetail struct {
	AcceptanceRequired *bool `json:"acceptanceRequired,omitempty"`

	AvailabilityZones []*string `json:"availabilityZones,omitempty"`

	BaseEndpointDNSNames []*string `json:"baseEndpointDNSNames,omitempty"`

	ManagesVPCEndpoints *bool `json:"managesVPCEndpoints,omitempty"`

	Owner *string `json:"owner,omitempty"`

	PrivateDNSName *string `json:"privateDNSName,omitempty"`

	PrivateDNSNameVerificationState *string `json:"privateDNSNameVerificationState,omitempty"`

	ServiceID *string `json:"serviceID,omitempty"`

	ServiceName *string `json:"serviceName,omitempty"`

	ServiceType []*ServiceTypeDetail `json:"serviceType,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCEndpointPolicySupported *bool `json:"vpcEndpointPolicySupported,omitempty"`
}

// +kubebuilder:skipversion
type ServiceTypeDetail struct {
	ServiceType *string `json:"serviceType,omitempty"`
}

// +kubebuilder:skipversion
type SlotDateTimeRangeRequest struct {
	EarliestTime *metav1.Time `json:"earliestTime,omitempty"`

	LatestTime *metav1.Time `json:"latestTime,omitempty"`
}

// +kubebuilder:skipversion
type SlotStartTimeRangeRequest struct {
	EarliestTime *metav1.Time `json:"earliestTime,omitempty"`

	LatestTime *metav1.Time `json:"latestTime,omitempty"`
}

// +kubebuilder:skipversion
type SnapshotDetail struct {
	Description *string `json:"description,omitempty"`

	DeviceName *string `json:"deviceName,omitempty"`

	DiskImageSize *float64 `json:"diskImageSize,omitempty"`

	Format *string `json:"format,omitempty"`

	Progress *string `json:"progress,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	Status *string `json:"status,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	URL *string `json:"url,omitempty"`
}

// +kubebuilder:skipversion
type SnapshotDiskContainer struct {
	Description *string `json:"description,omitempty"`

	Format *string `json:"format,omitempty"`

	URL *string `json:"url,omitempty"`
}

// +kubebuilder:skipversion
type SnapshotInfo struct {
	Description *string `json:"description,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Progress *string `json:"progress,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	StartTime *metav1.Time `json:"startTime,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VolumeID *string `json:"volumeID,omitempty"`

	VolumeSize *int64 `json:"volumeSize,omitempty"`
}

// +kubebuilder:skipversion
type SnapshotTaskDetail struct {
	Description *string `json:"description,omitempty"`

	DiskImageSize *float64 `json:"diskImageSize,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty"`

	Format *string `json:"format,omitempty"`

	KMSKeyID *string `json:"kmsKeyID,omitempty"`

	Progress *string `json:"progress,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	Status *string `json:"status,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	URL *string `json:"url,omitempty"`
}

// +kubebuilder:skipversion
type SpotCapacityRebalance struct {
	TerminationDelay *int64 `json:"terminationDelay,omitempty"`
}

// +kubebuilder:skipversion
type SpotDatafeedSubscription struct {
	Bucket *string `json:"bucket,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Prefix *string `json:"prefix,omitempty"`
}

// +kubebuilder:skipversion
type SpotFleetLaunchSpecification struct {
	AddressingType *string `json:"addressingType,omitempty"`

	EBSOptimized *bool `json:"ebsOptimized,omitempty"`

	ImageID *string `json:"imageID,omitempty"`
	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple parameters, you get instance types that satisfy
	// all of the specified parameters. If you specify multiple values for a parameter,
	// you get instance types that satisfy any of the specified values.
	//
	// You must specify VCpuCount and MemoryMiB. All other parameters are optional.
	// Any unspecified optional parameter is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	InstanceRequirements *InstanceRequirements `json:"instanceRequirements,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	KernelID *string `json:"kernelID,omitempty"`

	KeyName *string `json:"keyName,omitempty"`

	RamdiskID *string `json:"ramdiskID,omitempty"`

	SpotPrice *string `json:"spotPrice,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	UserData *string `json:"userData,omitempty"`

	WeightedCapacity *float64 `json:"weightedCapacity,omitempty"`
}

// +kubebuilder:skipversion
type SpotFleetMonitoring struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// +kubebuilder:skipversion
type SpotFleetRequestConfig struct {
	CreateTime *metav1.Time `json:"createTime,omitempty"`

	SpotFleetRequestID *string `json:"spotFleetRequestID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type SpotFleetRequestConfigData struct {
	ClientToken *string `json:"clientToken,omitempty"`

	Context *string `json:"context,omitempty"`

	FulfilledCapacity *float64 `json:"fulfilledCapacity,omitempty"`

	IAMFleetRole *string `json:"iamFleetRole,omitempty"`

	InstanceInterruptionBehavior *string `json:"instanceInterruptionBehavior,omitempty"`

	InstancePoolsToUseCount *int64 `json:"instancePoolsToUseCount,omitempty"`

	OnDemandFulfilledCapacity *float64 `json:"onDemandFulfilledCapacity,omitempty"`

	OnDemandMaxTotalPrice *string `json:"onDemandMaxTotalPrice,omitempty"`

	OnDemandTargetCapacity *int64 `json:"onDemandTargetCapacity,omitempty"`

	ReplaceUnhealthyInstances *bool `json:"replaceUnhealthyInstances,omitempty"`

	SpotMaxTotalPrice *string `json:"spotMaxTotalPrice,omitempty"`

	SpotPrice *string `json:"spotPrice,omitempty"`

	TagSpecifications []*TagSpecification `json:"tagSpecifications,omitempty"`

	TargetCapacity *int64 `json:"targetCapacity,omitempty"`

	TerminateInstancesWithExpiration *bool `json:"terminateInstancesWithExpiration,omitempty"`

	ValidFrom *metav1.Time `json:"validFrom,omitempty"`

	ValidUntil *metav1.Time `json:"validUntil,omitempty"`
}

// +kubebuilder:skipversion
type SpotFleetTagSpecification struct {
	ResourceType *string `json:"resourceType,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type SpotInstanceRequest struct {
	ActualBlockHourlyPrice *string `json:"actualBlockHourlyPrice,omitempty"`

	AvailabilityZoneGroup *string `json:"availabilityZoneGroup,omitempty"`

	BlockDurationMinutes *int64 `json:"blockDurationMinutes,omitempty"`

	CreateTime *metav1.Time `json:"createTime,omitempty"`

	InstanceInterruptionBehavior *string `json:"instanceInterruptionBehavior,omitempty"`

	LaunchGroup *string `json:"launchGroup,omitempty"`

	LaunchedAvailabilityZone *string `json:"launchedAvailabilityZone,omitempty"`

	SpotInstanceRequestID *string `json:"spotInstanceRequestID,omitempty"`

	SpotPrice *string `json:"spotPrice,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	Type *string `json:"type_,omitempty"`

	ValidFrom *metav1.Time `json:"validFrom,omitempty"`

	ValidUntil *metav1.Time `json:"validUntil,omitempty"`
}

// +kubebuilder:skipversion
type SpotInstanceStateFault struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type SpotInstanceStatus struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`

	UpdateTime *metav1.Time `json:"updateTime,omitempty"`
}

// +kubebuilder:skipversion
type SpotMarketOptions struct {
	BlockDurationMinutes *int64 `json:"blockDurationMinutes,omitempty"`

	InstanceInterruptionBehavior *string `json:"instanceInterruptionBehavior,omitempty"`

	MaxPrice *string `json:"maxPrice,omitempty"`

	SpotInstanceType *string `json:"spotInstanceType,omitempty"`

	ValidUntil *metav1.Time `json:"validUntil,omitempty"`
}

// +kubebuilder:skipversion
type SpotOptions struct {
	InstancePoolsToUseCount *int64 `json:"instancePoolsToUseCount,omitempty"`

	MaxTotalPrice *string `json:"maxTotalPrice,omitempty"`

	MinTargetCapacity *int64 `json:"minTargetCapacity,omitempty"`

	SingleAvailabilityZone *bool `json:"singleAvailabilityZone,omitempty"`

	SingleInstanceType *bool `json:"singleInstanceType,omitempty"`
}

// +kubebuilder:skipversion
type SpotOptionsRequest struct {
	InstancePoolsToUseCount *int64 `json:"instancePoolsToUseCount,omitempty"`

	MaxTotalPrice *string `json:"maxTotalPrice,omitempty"`

	MinTargetCapacity *int64 `json:"minTargetCapacity,omitempty"`

	SingleAvailabilityZone *bool `json:"singleAvailabilityZone,omitempty"`

	SingleInstanceType *bool `json:"singleInstanceType,omitempty"`
}

// +kubebuilder:skipversion
type SpotPlacement struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	GroupName *string `json:"groupName,omitempty"`

	Tenancy *string `json:"tenancy,omitempty"`
}

// +kubebuilder:skipversion
type SpotPlacementScore struct {
	AvailabilityZoneID *string `json:"availabilityZoneID,omitempty"`

	Region *string `json:"region,omitempty"`

	Score *int64 `json:"score,omitempty"`
}

// +kubebuilder:skipversion
type SpotPrice struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	InstanceType *string `json:"instanceType,omitempty"`

	SpotPrice *string `json:"spotPrice,omitempty"`

	Timestamp *metav1.Time `json:"timestamp,omitempty"`
}

// +kubebuilder:skipversion
type StaleIPPermission struct {
	FromPort *int64 `json:"fromPort,omitempty"`

	IPProtocol *string `json:"ipProtocol,omitempty"`

	ToPort *int64 `json:"toPort,omitempty"`
}

// +kubebuilder:skipversion
type StaleSecurityGroup struct {
	Description *string `json:"description,omitempty"`

	GroupID *string `json:"groupID,omitempty"`

	GroupName *string `json:"groupName,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type StateReason struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type StorageLocation struct {
	Bucket *string `json:"bucket,omitempty"`

	Key *string `json:"key,omitempty"`
}

// +kubebuilder:skipversion
type StoreImageTaskResult struct {
	AMIID *string `json:"amiID,omitempty"`

	Bucket *string `json:"bucket,omitempty"`

	ProgressPercentage *int64 `json:"progressPercentage,omitempty"`

	S3ObjectKey *string `json:"s3ObjectKey,omitempty"`

	StoreTaskFailureReason *string `json:"storeTaskFailureReason,omitempty"`

	StoreTaskState *string `json:"storeTaskState,omitempty"`

	TaskStartTime *metav1.Time `json:"taskStartTime,omitempty"`
}

// +kubebuilder:skipversion
type Subnet struct {
	AssignIPv6AddressOnCreation *bool `json:"assignIPv6AddressOnCreation,omitempty"`

	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	AvailabilityZoneID *string `json:"availabilityZoneID,omitempty"`

	CIDRBlock *string `json:"cidrBlock,omitempty"`

	DefaultForAZ *bool `json:"defaultForAZ,omitempty"`

	MapCustomerOwnedIPOnLaunch *bool `json:"mapCustomerOwnedIPOnLaunch,omitempty"`

	MapPublicIPOnLaunch *bool `json:"mapPublicIPOnLaunch,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	SubnetARN *string `json:"subnetARN,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type SubnetAssociation struct {
	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type SubnetCIDRBlockState struct {
	StatusMessage *string `json:"statusMessage,omitempty"`
}

// +kubebuilder:skipversion
type SubnetCIDRReservation struct {
	CIDR *string `json:"cidr,omitempty"`

	Description *string `json:"description,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type SubnetIPv6CIDRBlockAssociation struct {
	IPv6CIDRBlock *string `json:"ipv6CIDRBlock,omitempty"`
}

// +kubebuilder:skipversion
type SuccessfulInstanceCreditSpecificationItem struct {
	InstanceID *string `json:"instanceID,omitempty"`
}

// +kubebuilder:skipversion
type SuccessfulQueuedPurchaseDeletion struct {
	ReservedInstancesID *string `json:"reservedInstancesID,omitempty"`
}

// +kubebuilder:skipversion
type Tag struct {
	Key *string `json:"key,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type TagDescription struct {
	Key *string `json:"key,omitempty"`

	ResourceID *string `json:"resourceID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type TagSpecification struct {
	ResourceType *string `json:"resourceType,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`
}

// +kubebuilder:skipversion
type TargetCapacitySpecification struct {
	OnDemandTargetCapacity *int64 `json:"onDemandTargetCapacity,omitempty"`

	SpotTargetCapacity *int64 `json:"spotTargetCapacity,omitempty"`

	TotalTargetCapacity *int64 `json:"totalTargetCapacity,omitempty"`
}

// +kubebuilder:skipversion
type TargetCapacitySpecificationRequest struct {
	OnDemandTargetCapacity *int64 `json:"onDemandTargetCapacity,omitempty"`

	SpotTargetCapacity *int64 `json:"spotTargetCapacity,omitempty"`

	TotalTargetCapacity *int64 `json:"totalTargetCapacity,omitempty"`
}

// +kubebuilder:skipversion
type TargetConfiguration struct {
	InstanceCount *int64 `json:"instanceCount,omitempty"`

	OfferingID *string `json:"offeringID,omitempty"`
}

// +kubebuilder:skipversion
type TargetConfigurationRequest struct {
	InstanceCount *int64 `json:"instanceCount,omitempty"`
}

// +kubebuilder:skipversion
type TargetGroup struct {
	ARN *string `json:"arn,omitempty"`
}

// +kubebuilder:skipversion
type TargetNetwork struct {
	AssociationID *string `json:"associationID,omitempty"`

	ClientVPNEndpointID *string `json:"clientVPNEndpointID,omitempty"`

	SecurityGroups []*string `json:"securityGroups,omitempty"`

	TargetNetworkID *string `json:"targetNetworkID,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type TerminateConnectionStatus struct {
	ConnectionID *string `json:"connectionID,omitempty"`
}

// +kubebuilder:skipversion
type TotalLocalStorageGB struct {
	Max *float64 `json:"max,omitempty"`

	Min *float64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type TotalLocalStorageGBRequest struct {
	Max *float64 `json:"max,omitempty"`

	Min *float64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type TrafficMirrorFilter struct {
	Description *string `json:"description,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TrafficMirrorFilterID *string `json:"trafficMirrorFilterID,omitempty"`
}

// +kubebuilder:skipversion
type TrafficMirrorFilterRule struct {
	Description *string `json:"description,omitempty"`

	DestinationCIDRBlock *string `json:"destinationCIDRBlock,omitempty"`

	Protocol *int64 `json:"protocol,omitempty"`

	RuleNumber *int64 `json:"ruleNumber,omitempty"`

	SourceCIDRBlock *string `json:"sourceCIDRBlock,omitempty"`

	TrafficMirrorFilterID *string `json:"trafficMirrorFilterID,omitempty"`

	TrafficMirrorFilterRuleID *string `json:"trafficMirrorFilterRuleID,omitempty"`
}

// +kubebuilder:skipversion
type TrafficMirrorPortRange struct {
	FromPort *int64 `json:"fromPort,omitempty"`

	ToPort *int64 `json:"toPort,omitempty"`
}

// +kubebuilder:skipversion
type TrafficMirrorPortRangeRequest struct {
	FromPort *int64 `json:"fromPort,omitempty"`

	ToPort *int64 `json:"toPort,omitempty"`
}

// +kubebuilder:skipversion
type TrafficMirrorSession struct {
	Description *string `json:"description,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	PacketLength *int64 `json:"packetLength,omitempty"`

	SessionNumber *int64 `json:"sessionNumber,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TrafficMirrorFilterID *string `json:"trafficMirrorFilterID,omitempty"`

	TrafficMirrorSessionID *string `json:"trafficMirrorSessionID,omitempty"`

	TrafficMirrorTargetID *string `json:"trafficMirrorTargetID,omitempty"`

	VirtualNetworkID *int64 `json:"virtualNetworkID,omitempty"`
}

// +kubebuilder:skipversion
type TrafficMirrorTarget struct {
	Description *string `json:"description,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	NetworkLoadBalancerARN *string `json:"networkLoadBalancerARN,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TrafficMirrorTargetID *string `json:"trafficMirrorTargetID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayAssociation struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`

	TransitGatewayRouteTableID *string `json:"transitGatewayRouteTableID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayAttachment struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	ResourceID *string `json:"resourceID,omitempty"`

	ResourceOwnerID *string `json:"resourceOwnerID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`

	TransitGatewayOwnerID *string `json:"transitGatewayOwnerID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayAttachmentAssociation struct {
	TransitGatewayRouteTableID *string `json:"transitGatewayRouteTableID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayAttachmentBGPConfiguration struct {
	PeerAddress *string `json:"peerAddress,omitempty"`

	PeerASN *int64 `json:"peerASN,omitempty"`

	TransitGatewayAddress *string `json:"transitGatewayAddress,omitempty"`

	TransitGatewayASN *int64 `json:"transitGatewayASN,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayAttachmentPropagation struct {
	TransitGatewayRouteTableID *string `json:"transitGatewayRouteTableID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayConnect struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`

	TransportTransitGatewayAttachmentID *string `json:"transportTransitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayConnectPeer struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayConnectPeerConfiguration struct {
	PeerAddress *string `json:"peerAddress,omitempty"`

	TransitGatewayAddress *string `json:"transitGatewayAddress,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayConnectRequestBGPOptions struct {
	PeerASN *int64 `json:"peerASN,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayMulticastDeregisteredGroupMembers struct {
	DeregisteredNetworkInterfaceIDs []*string `json:"deregisteredNetworkInterfaceIDs,omitempty"`

	GroupIPAddress *string `json:"groupIPAddress,omitempty"`

	TransitGatewayMulticastDomainID *string `json:"transitGatewayMulticastDomainID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayMulticastDeregisteredGroupSources struct {
	DeregisteredNetworkInterfaceIDs []*string `json:"deregisteredNetworkInterfaceIDs,omitempty"`

	GroupIPAddress *string `json:"groupIPAddress,omitempty"`

	TransitGatewayMulticastDomainID *string `json:"transitGatewayMulticastDomainID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayMulticastDomain struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`

	TransitGatewayMulticastDomainARN *string `json:"transitGatewayMulticastDomainARN,omitempty"`

	TransitGatewayMulticastDomainID *string `json:"transitGatewayMulticastDomainID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayMulticastDomainAssociation struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceOwnerID *string `json:"resourceOwnerID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayMulticastDomainAssociations struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceOwnerID *string `json:"resourceOwnerID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`

	TransitGatewayMulticastDomainID *string `json:"transitGatewayMulticastDomainID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayMulticastGroup struct {
	GroupIPAddress *string `json:"groupIPAddress,omitempty"`

	GroupMember *bool `json:"groupMember,omitempty"`

	GroupSource *bool `json:"groupSource,omitempty"`

	NetworkInterfaceID *string `json:"networkInterfaceID,omitempty"`

	ResourceID *string `json:"resourceID,omitempty"`

	ResourceOwnerID *string `json:"resourceOwnerID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayMulticastRegisteredGroupMembers struct {
	GroupIPAddress *string `json:"groupIPAddress,omitempty"`

	RegisteredNetworkInterfaceIDs []*string `json:"registeredNetworkInterfaceIDs,omitempty"`

	TransitGatewayMulticastDomainID *string `json:"transitGatewayMulticastDomainID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayMulticastRegisteredGroupSources struct {
	GroupIPAddress *string `json:"groupIPAddress,omitempty"`

	RegisteredNetworkInterfaceIDs []*string `json:"registeredNetworkInterfaceIDs,omitempty"`

	TransitGatewayMulticastDomainID *string `json:"transitGatewayMulticastDomainID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayOptions struct {
	AmazonSideASN *int64 `json:"amazonSideASN,omitempty"`

	AssociationDefaultRouteTableID *string `json:"associationDefaultRouteTableID,omitempty"`

	AutoAcceptSharedAttachments *string `json:"autoAcceptSharedAttachments,omitempty"`

	DefaultRouteTableAssociation *string `json:"defaultRouteTableAssociation,omitempty"`

	DefaultRouteTablePropagation *string `json:"defaultRouteTablePropagation,omitempty"`

	DNSSupport *string `json:"dnsSupport,omitempty"`

	MulticastSupport *string `json:"multicastSupport,omitempty"`

	PropagationDefaultRouteTableID *string `json:"propagationDefaultRouteTableID,omitempty"`

	TransitGatewayCIDRBlocks []*string `json:"transitGatewayCIDRBlocks,omitempty"`

	VPNECMPSupport *string `json:"vpnECMPSupport,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayPeeringAttachment struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayPrefixListAttachment struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayPrefixListReference struct {
	Blackhole *bool `json:"blackhole,omitempty"`

	PrefixListID *string `json:"prefixListID,omitempty"`

	PrefixListOwnerID *string `json:"prefixListOwnerID,omitempty"`

	TransitGatewayRouteTableID *string `json:"transitGatewayRouteTableID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayPropagation struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`

	TransitGatewayRouteTableID *string `json:"transitGatewayRouteTableID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayRequestOptions struct {
	AmazonSideASN *int64 `json:"amazonSideASN,omitempty"`

	AutoAcceptSharedAttachments *string `json:"autoAcceptSharedAttachments,omitempty"`

	DefaultRouteTableAssociation *string `json:"defaultRouteTableAssociation,omitempty"`

	DefaultRouteTablePropagation *string `json:"defaultRouteTablePropagation,omitempty"`

	DNSSupport *string `json:"dnsSupport,omitempty"`

	MulticastSupport *string `json:"multicastSupport,omitempty"`

	TransitGatewayCIDRBlocks []*string `json:"transitGatewayCIDRBlocks,omitempty"`

	VPNECMPSupport *string `json:"vpnECMPSupport,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayRouteAttachment struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayRouteTableAssociation struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayRouteTablePropagation struct {
	ResourceID *string `json:"resourceID,omitempty"`

	ResourceType *string `json:"resourceType,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayRouteTable_SDK struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	DefaultAssociationRouteTable *bool `json:"defaultAssociationRouteTable,omitempty"`

	DefaultPropagationRouteTable *bool `json:"defaultPropagationRouteTable,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`

	TransitGatewayRouteTableID *string `json:"transitGatewayRouteTableID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayRoute_SDK struct {
	DestinationCIDRBlock *string `json:"destinationCIDRBlock,omitempty"`

	PrefixListID *string `json:"prefixListID,omitempty"`

	State *string `json:"state,omitempty"`

	TransitGatewayAttachments []*TransitGatewayRouteAttachment `json:"transitGatewayAttachments,omitempty"`

	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayVPCAttachmentOptions struct {
	ApplianceModeSupport *string `json:"applianceModeSupport,omitempty"`

	DNSSupport *string `json:"dnsSupport,omitempty"`

	IPv6Support *string `json:"ipv6Support,omitempty"`
}

// +kubebuilder:skipversion
type TransitGatewayVPCAttachment_SDK struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`
	// Describes the VPC attachment options.
	Options *TransitGatewayVPCAttachmentOptions `json:"options,omitempty"`

	State *string `json:"state,omitempty"`

	SubnetIDs []*string `json:"subnetIDs,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentID,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`

	VPCOwnerID *string `json:"vpcOwnerID,omitempty"`
}

// +kubebuilder:skipversion
type TransitGateway_SDK struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	Description *string `json:"description,omitempty"`
	// Describes the options for a transit gateway.
	Options *TransitGatewayOptions `json:"options,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayARN *string `json:"transitGatewayARN,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`
}

// +kubebuilder:skipversion
type TrunkInterfaceAssociation struct {
	BranchInterfaceID *string `json:"branchInterfaceID,omitempty"`

	GreKey *int64 `json:"greKey,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TrunkInterfaceID *string `json:"trunkInterfaceID,omitempty"`

	VLANID *int64 `json:"vlanID,omitempty"`
}

// +kubebuilder:skipversion
type TunnelOption struct {
	DPDTimeoutAction *string `json:"dpdTimeoutAction,omitempty"`

	DPDTimeoutSeconds *int64 `json:"dpdTimeoutSeconds,omitempty"`

	OutsideIPAddress *string `json:"outsideIPAddress,omitempty"`

	Phase1LifetimeSeconds *int64 `json:"phase1LifetimeSeconds,omitempty"`

	Phase2LifetimeSeconds *int64 `json:"phase2LifetimeSeconds,omitempty"`

	PreSharedKey *string `json:"preSharedKey,omitempty"`

	RekeyFuzzPercentage *int64 `json:"rekeyFuzzPercentage,omitempty"`

	RekeyMarginTimeSeconds *int64 `json:"rekeyMarginTimeSeconds,omitempty"`

	ReplayWindowSize *int64 `json:"replayWindowSize,omitempty"`

	StartupAction *string `json:"startupAction,omitempty"`

	TunnelInsideCIDR *string `json:"tunnelInsideCIDR,omitempty"`

	TunnelInsideIPv6CIDR *string `json:"tunnelInsideIPv6CIDR,omitempty"`
}

// +kubebuilder:skipversion
type UnsuccessfulInstanceCreditSpecificationItem struct {
	InstanceID *string `json:"instanceID,omitempty"`
}

// +kubebuilder:skipversion
type UnsuccessfulInstanceCreditSpecificationItemError struct {
	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type UnsuccessfulItem struct {
	ResourceID *string `json:"resourceID,omitempty"`
}

// +kubebuilder:skipversion
type UnsuccessfulItemError struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type UserBucket struct {
	S3Bucket *string `json:"s3Bucket,omitempty"`

	S3Key *string `json:"s3Key,omitempty"`
}

// +kubebuilder:skipversion
type UserBucketDetails struct {
	S3Bucket *string `json:"s3Bucket,omitempty"`

	S3Key *string `json:"s3Key,omitempty"`
}

// +kubebuilder:skipversion
type UserData struct {
	Data *string `json:"data,omitempty"`
}

// +kubebuilder:skipversion
type UserIDGroupPair struct {
	Description *string `json:"description,omitempty"`

	GroupID *string `json:"groupID,omitempty"`

	GroupName *string `json:"groupName,omitempty"`

	PeeringStatus *string `json:"peeringStatus,omitempty"`

	UserID *string `json:"userID,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`

	VPCPeeringConnectionID *string `json:"vpcPeeringConnectionID,omitempty"`
}

// +kubebuilder:skipversion
type VCPUCountRange struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type VCPUCountRangeRequest struct {
	Max *int64 `json:"max,omitempty"`

	Min *int64 `json:"min,omitempty"`
}

// +kubebuilder:skipversion
type VGWTelemetry struct {
	AcceptedRouteCount *int64 `json:"acceptedRouteCount,omitempty"`

	CertificateARN *string `json:"certificateARN,omitempty"`

	LastStatusChange *metav1.Time `json:"lastStatusChange,omitempty"`

	OutsideIPAddress *string `json:"outsideIPAddress,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`
}

// +kubebuilder:skipversion
type VPC struct {
	CIDRBlock *string `json:"cidrBlock,omitempty"`

	DHCPOptionsID *string `json:"dhcpOptionsID,omitempty"`

	InstanceTenancy *string `json:"instanceTenancy,omitempty"`

	IsDefault *bool `json:"isDefault,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type VPCAttachment struct {
	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type VPCCIDRBlockAssociation struct {
	AssociationID *string `json:"associationID,omitempty"`

	CIDRBlock *string `json:"cidrBlock,omitempty"`
}

// +kubebuilder:skipversion
type VPCCIDRBlockState struct {
	StatusMessage *string `json:"statusMessage,omitempty"`
}

// +kubebuilder:skipversion
type VPCClassicLink struct {
	ClassicLinkEnabled *bool `json:"classicLinkEnabled,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type VPCEndpointConnection struct {
	CreationTimestamp *metav1.Time `json:"creationTimestamp,omitempty"`

	DNSEntries []*DNSEntry `json:"dnsEntries,omitempty"`

	GatewayLoadBalancerARNs []*string `json:"gatewayLoadBalancerARNs,omitempty"`

	NetworkLoadBalancerARNs []*string `json:"networkLoadBalancerARNs,omitempty"`

	ServiceID *string `json:"serviceID,omitempty"`

	VPCEndpointID *string `json:"vpcEndpointID,omitempty"`

	VPCEndpointOwner *string `json:"vpcEndpointOwner,omitempty"`

	VPCEndpointState *string `json:"vpcEndpointState,omitempty"`
}

// +kubebuilder:skipversion
type VPCEndpoint_SDK struct {
	CreationTimestamp *metav1.Time `json:"creationTimestamp,omitempty"`

	DNSEntries []*DNSEntry `json:"dnsEntries,omitempty"`

	Groups []*SecurityGroupIdentifier `json:"groups,omitempty"`
	// The last error that occurred for a VPC endpoint.
	LastError *LastError `json:"lastError,omitempty"`

	NetworkInterfaceIDs []*string `json:"networkInterfaceIDs,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`

	PolicyDocument *string `json:"policyDocument,omitempty"`

	PrivateDNSEnabled *bool `json:"privateDNSEnabled,omitempty"`

	RequesterManaged *bool `json:"requesterManaged,omitempty"`

	RouteTableIDs []*string `json:"routeTableIDs,omitempty"`

	ServiceName *string `json:"serviceName,omitempty"`

	State *string `json:"state,omitempty"`

	SubnetIDs []*string `json:"subnetIDs,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCEndpointID *string `json:"vpcEndpointID,omitempty"`

	VPCEndpointType *string `json:"vpcEndpointType,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type VPCIPv6CIDRBlockAssociation struct {
	AssociationID *string `json:"associationID,omitempty"`

	IPv6CIDRBlock *string `json:"ipv6CIDRBlock,omitempty"`

	IPv6Pool *string `json:"ipv6Pool,omitempty"`

	NetworkBorderGroup *string `json:"networkBorderGroup,omitempty"`
}

// +kubebuilder:skipversion
type VPCPeeringConnectionOptionsDescription struct {
	AllowDNSResolutionFromRemoteVPC *bool `json:"allowDNSResolutionFromRemoteVPC,omitempty"`

	AllowEgressFromLocalClassicLinkToRemoteVPC *bool `json:"allowEgressFromLocalClassicLinkToRemoteVPC,omitempty"`

	AllowEgressFromLocalVPCToRemoteClassicLink *bool `json:"allowEgressFromLocalVPCToRemoteClassicLink,omitempty"`
}

// +kubebuilder:skipversion
type VPCPeeringConnectionStateReason struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type VPCPeeringConnectionVPCInfo struct {
	CIDRBlock *string `json:"cidrBlock,omitempty"`

	CIDRBlockSet []*CIDRBlock `json:"cidrBlockSet,omitempty"`

	IPv6CIDRBlockSet []*IPv6CIDRBlock `json:"ipv6CIDRBlockSet,omitempty"`

	OwnerID *string `json:"ownerID,omitempty"`
	// Describes the VPC peering connection options.
	PeeringOptions *VPCPeeringConnectionOptionsDescription `json:"peeringOptions,omitempty"`

	Region *string `json:"region,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`
}

// +kubebuilder:skipversion
type VPCPeeringConnection_SDK struct {
	// Describes a VPC in a VPC peering connection.
	AccepterVPCInfo *VPCPeeringConnectionVPCInfo `json:"accepterVPCInfo,omitempty"`

	ExpirationTime *metav1.Time `json:"expirationTime,omitempty"`
	// Describes a VPC in a VPC peering connection.
	RequesterVPCInfo *VPCPeeringConnectionVPCInfo `json:"requesterVPCInfo,omitempty"`
	// Describes the status of a VPC peering connection.
	Status *VPCPeeringConnectionStateReason `json:"status,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPCPeeringConnectionID *string `json:"vpcPeeringConnectionID,omitempty"`
}

// +kubebuilder:skipversion
type VPNConnection struct {
	Category *string `json:"category,omitempty"`

	CoreNetworkARN *string `json:"coreNetworkARN,omitempty"`

	CoreNetworkAttachmentARN *string `json:"coreNetworkAttachmentARN,omitempty"`

	CustomerGatewayConfiguration *string `json:"customerGatewayConfiguration,omitempty"`

	CustomerGatewayID *string `json:"customerGatewayID,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	TransitGatewayID *string `json:"transitGatewayID,omitempty"`

	VPNConnectionID *string `json:"vpnConnectionID,omitempty"`

	VPNGatewayID *string `json:"vpnGatewayID,omitempty"`
}

// +kubebuilder:skipversion
type VPNConnectionDeviceType struct {
	Platform *string `json:"platform,omitempty"`

	Software *string `json:"software,omitempty"`

	Vendor *string `json:"vendor,omitempty"`

	VPNConnectionDeviceTypeID *string `json:"vpnConnectionDeviceTypeID,omitempty"`
}

// +kubebuilder:skipversion
type VPNConnectionOptions struct {
	EnableAcceleration *bool `json:"enableAcceleration,omitempty"`

	LocalIPv4NetworkCIDR *string `json:"localIPv4NetworkCIDR,omitempty"`

	LocalIPv6NetworkCIDR *string `json:"localIPv6NetworkCIDR,omitempty"`

	RemoteIPv4NetworkCIDR *string `json:"remoteIPv4NetworkCIDR,omitempty"`

	RemoteIPv6NetworkCIDR *string `json:"remoteIPv6NetworkCIDR,omitempty"`

	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`
}

// +kubebuilder:skipversion
type VPNConnectionOptionsSpecification struct {
	EnableAcceleration *bool `json:"enableAcceleration,omitempty"`

	LocalIPv4NetworkCIDR *string `json:"localIPv4NetworkCIDR,omitempty"`

	LocalIPv6NetworkCIDR *string `json:"localIPv6NetworkCIDR,omitempty"`

	RemoteIPv4NetworkCIDR *string `json:"remoteIPv4NetworkCIDR,omitempty"`

	RemoteIPv6NetworkCIDR *string `json:"remoteIPv6NetworkCIDR,omitempty"`

	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`
}

// +kubebuilder:skipversion
type VPNGateway struct {
	AmazonSideASN *int64 `json:"amazonSideASN,omitempty"`

	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	VPNGatewayID *string `json:"vpnGatewayID,omitempty"`
}

// +kubebuilder:skipversion
type VPNStaticRoute struct {
	DestinationCIDRBlock *string `json:"destinationCIDRBlock,omitempty"`
}

// +kubebuilder:skipversion
type VPNTunnelOptionsSpecification struct {
	DPDTimeoutAction *string `json:"dpdTimeoutAction,omitempty"`

	DPDTimeoutSeconds *int64 `json:"dpdTimeoutSeconds,omitempty"`

	Phase1LifetimeSeconds *int64 `json:"phase1LifetimeSeconds,omitempty"`

	Phase2LifetimeSeconds *int64 `json:"phase2LifetimeSeconds,omitempty"`

	PreSharedKey *string `json:"preSharedKey,omitempty"`

	RekeyFuzzPercentage *int64 `json:"rekeyFuzzPercentage,omitempty"`

	RekeyMarginTimeSeconds *int64 `json:"rekeyMarginTimeSeconds,omitempty"`

	ReplayWindowSize *int64 `json:"replayWindowSize,omitempty"`

	StartupAction *string `json:"startupAction,omitempty"`

	TunnelInsideCIDR *string `json:"tunnelInsideCIDR,omitempty"`

	TunnelInsideIPv6CIDR *string `json:"tunnelInsideIPv6CIDR,omitempty"`
}

// +kubebuilder:skipversion
type ValidationError struct {
	Code *string `json:"code,omitempty"`

	Message *string `json:"message,omitempty"`
}

// +kubebuilder:skipversion
type ValidationWarning struct {
	Errors []*ValidationError `json:"errors,omitempty"`
}

// +kubebuilder:skipversion
type VolumeAttachment struct {
	AttachTime *metav1.Time `json:"attachTime,omitempty"`

	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	Device *string `json:"device,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	State *string `json:"state,omitempty"`

	VolumeID *string `json:"volumeID,omitempty"`
}

// +kubebuilder:skipversion
type VolumeDetail struct {
	Size *int64 `json:"size,omitempty"`
}

// +kubebuilder:skipversion
type VolumeModification struct {
	EndTime *metav1.Time `json:"endTime,omitempty"`

	ModificationState *string `json:"modificationState,omitempty"`

	OriginalIOPS *int64 `json:"originalIOPS,omitempty"`

	OriginalMultiAttachEnabled *bool `json:"originalMultiAttachEnabled,omitempty"`

	OriginalSize *int64 `json:"originalSize,omitempty"`

	OriginalThroughput *int64 `json:"originalThroughput,omitempty"`

	OriginalVolumeType *string `json:"originalVolumeType,omitempty"`

	Progress *int64 `json:"progress,omitempty"`

	StartTime *metav1.Time `json:"startTime,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty"`

	TargetIOPS *int64 `json:"targetIOPS,omitempty"`

	TargetMultiAttachEnabled *bool `json:"targetMultiAttachEnabled,omitempty"`

	TargetSize *int64 `json:"targetSize,omitempty"`

	TargetThroughput *int64 `json:"targetThroughput,omitempty"`

	TargetVolumeType *string `json:"targetVolumeType,omitempty"`

	VolumeID *string `json:"volumeID,omitempty"`
}

// +kubebuilder:skipversion
type VolumeStatusAction struct {
	Code *string `json:"code,omitempty"`

	Description *string `json:"description,omitempty"`

	EventID *string `json:"eventID,omitempty"`

	EventType *string `json:"eventType,omitempty"`
}

// +kubebuilder:skipversion
type VolumeStatusAttachmentStatus struct {
	InstanceID *string `json:"instanceID,omitempty"`

	IOPerformance *string `json:"ioPerformance,omitempty"`
}

// +kubebuilder:skipversion
type VolumeStatusDetails struct {
	Status *string `json:"status,omitempty"`
}

// +kubebuilder:skipversion
type VolumeStatusEvent struct {
	Description *string `json:"description,omitempty"`

	EventID *string `json:"eventID,omitempty"`

	EventType *string `json:"eventType,omitempty"`

	InstanceID *string `json:"instanceID,omitempty"`

	NotAfter *metav1.Time `json:"notAfter,omitempty"`

	NotBefore *metav1.Time `json:"notBefore,omitempty"`
}

// +kubebuilder:skipversion
type VolumeStatusItem struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`

	VolumeID *string `json:"volumeID,omitempty"`
}

// +kubebuilder:skipversion
type Volume_SDK struct {
	Attachments []*VolumeAttachment `json:"attachments,omitempty"`

	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	CreateTime *metav1.Time `json:"createTime,omitempty"`

	Encrypted *bool `json:"encrypted,omitempty"`

	FastRestored *bool `json:"fastRestored,omitempty"`

	IOPS *int64 `json:"iops,omitempty"`

	KMSKeyID *string `json:"kmsKeyID,omitempty"`

	MultiAttachEnabled *bool `json:"multiAttachEnabled,omitempty"`

	OutpostARN *string `json:"outpostARN,omitempty"`

	Size *int64 `json:"size,omitempty"`

	SnapshotID *string `json:"snapshotID,omitempty"`

	State *string `json:"state,omitempty"`

	Tags []*Tag `json:"tags,omitempty"`

	Throughput *int64 `json:"throughput,omitempty"`

	VolumeID *string `json:"volumeID,omitempty"`

	VolumeType *string `json:"volumeType,omitempty"`
}
