/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// LoadBalancerParameters defines the desired state of LoadBalancer
type LoadBalancerParameters struct {
	// Region is which region the LoadBalancer will be created.
	// +kubebuilder:validation:Required
	Region string `json:"region"`
	// [Application Load Balancers on Outposts] The ID of the customer-owned address
	// pool (CoIP pool).
	CustomerOwnedIPv4Pool *string `json:"customerOwnedIPv4Pool,omitempty"`
	// The type of IP addresses used by the subnets for your load balancer. The
	// possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and
	// IPv6 addresses).
	IPAddressType *string `json:"ipAddressType,omitempty"`
	// The name of the load balancer.
	//
	// This name must be unique per region per account, can have a maximum of 32
	// characters, must contain only alphanumeric characters or hyphens, must not
	// begin or end with a hyphen, and must not begin with "internal-".
	// +kubebuilder:validation:Required
	Name *string `json:"name"`
	// The nodes of an Internet-facing load balancer have public IP addresses. The
	// DNS name of an Internet-facing load balancer is publicly resolvable to the
	// public IP addresses of the nodes. Therefore, Internet-facing load balancers
	// can route requests from clients over the internet.
	//
	// The nodes of an internal load balancer have only private IP addresses. The
	// DNS name of an internal load balancer is publicly resolvable to the private
	// IP addresses of the nodes. Therefore, internal load balancers can route requests
	// only from clients with access to the VPC for the load balancer.
	//
	// The default is an Internet-facing load balancer.
	//
	// You cannot specify a scheme for a Gateway Load Balancer.
	Scheme *string `json:"scheme,omitempty"`
	// [Application Load Balancers] The IDs of the security groups for the load
	// balancer.
	SecurityGroups []*string `json:"securityGroups,omitempty"`
	// The IDs of the public subnets. You can specify only one subnet per Availability
	// Zone. You must specify either subnets or subnet mappings.
	//
	// [Application Load Balancers] You must specify subnets from at least two Availability
	// Zones. You cannot specify Elastic IP addresses for your subnets.
	//
	// [Application Load Balancers on Outposts] You must specify one Outpost subnet.
	//
	// [Application Load Balancers on Local Zones] You can specify subnets from
	// one or more Local Zones.
	//
	// [Network Load Balancers] You can specify subnets from one or more Availability
	// Zones. You can specify one Elastic IP address per subnet if you need static
	// IP addresses for your internet-facing load balancer. For internal load balancers,
	// you can specify one private IP address per subnet from the IPv4 range of
	// the subnet. For internet-facing load balancer, you can specify one IPv6 address
	// per subnet.
	//
	// [Gateway Load Balancers] You can specify subnets from one or more Availability
	// Zones. You cannot specify Elastic IP addresses for your subnets.
	SubnetMappings []*SubnetMapping `json:"subnetMappings,omitempty"`
	// The IDs of the public subnets. You can specify only one subnet per Availability
	// Zone. You must specify either subnets or subnet mappings.
	//
	// [Application Load Balancers] You must specify subnets from at least two Availability
	// Zones.
	//
	// [Application Load Balancers on Outposts] You must specify one Outpost subnet.
	//
	// [Application Load Balancers on Local Zones] You can specify subnets from
	// one or more Local Zones.
	//
	// [Network Load Balancers] You can specify subnets from one or more Availability
	// Zones.
	//
	// [Gateway Load Balancers] You can specify subnets from one or more Availability
	// Zones.
	Subnets []*string `json:"subnets,omitempty"`
	// The tags to assign to the load balancer.
	Tags                         []*Tag `json:"tags,omitempty"`
	CustomLoadBalancerParameters `json:",inline"`
}

// LoadBalancerSpec defines the desired state of LoadBalancer
type LoadBalancerSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       LoadBalancerParameters `json:"forProvider"`
}

// LoadBalancerObservation defines the observed state of LoadBalancer
type LoadBalancerObservation struct {
	// The subnets for the load balancer.
	AvailabilityZones []*AvailabilityZone `json:"availabilityZones,omitempty"`
	// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
	CanonicalHostedZoneID *string `json:"canonicalHostedZoneID,omitempty"`
	// The date and time the load balancer was created.
	CreatedTime *metav1.Time `json:"createdTime,omitempty"`
	// The public DNS name of the load balancer.
	DNSName *string `json:"dnsName,omitempty"`
	// The Amazon Resource Name (ARN) of the load balancer.
	LoadBalancerARN *string `json:"loadBalancerARN,omitempty"`
	// The name of the load balancer.
	LoadBalancerName *string `json:"loadBalancerName,omitempty"`
	// The state of the load balancer.
	State *LoadBalancerState `json:"state,omitempty"`
	// The type of load balancer.
	Type *string `json:"type_,omitempty"`
	// The ID of the VPC for the load balancer.
	VPCID *string `json:"vpcID,omitempty"`
}

// LoadBalancerStatus defines the observed state of LoadBalancer.
type LoadBalancerStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          LoadBalancerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancer is the Schema for the LoadBalancers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type LoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancerSpec   `json:"spec"`
	Status            LoadBalancerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancerList contains a list of LoadBalancers
type LoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancer `json:"items"`
}

// Repository type metadata.
var (
	LoadBalancerKind             = "LoadBalancer"
	LoadBalancerGroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LoadBalancerKind}.String()
	LoadBalancerKindAPIVersion   = LoadBalancerKind + "." + GroupVersion.String()
	LoadBalancerGroupVersionKind = GroupVersion.WithKind(LoadBalancerKind)
)

func init() {
	SchemeBuilder.Register(&LoadBalancer{}, &LoadBalancerList{})
}
