/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// ClusterParameters defines the desired state of Cluster
type ClusterParameters struct {
	// Region is which region the Cluster will be created.
	// +kubebuilder:validation:Required
	Region string `json:"region"`
	// The short name of one or more capacity providers to associate with the cluster.
	// A capacity provider must be associated with a cluster before it can be included
	// as part of the default capacity provider strategy of the cluster or used
	// in a capacity provider strategy when calling the CreateService or RunTask
	// actions.
	//
	// If specifying a capacity provider that uses an Auto Scaling group, the capacity
	// provider must be created but not associated with another cluster. New Auto
	// Scaling group capacity providers can be created with the CreateCapacityProvider
	// API operation.
	//
	// To use a Fargate capacity provider, specify either the FARGATE or FARGATE_SPOT
	// capacity providers. The Fargate capacity providers are available to all accounts
	// and only need to be associated with a cluster to be used.
	//
	// The PutClusterCapacityProviders API operation is used to update the list
	// of available capacity providers for a cluster after the cluster is created.
	CapacityProviders []*string `json:"capacityProviders,omitempty"`
	// The name of your cluster. If you don't specify a name for your cluster, you
	// create a cluster that's named default. Up to 255 letters (uppercase and lowercase),
	// numbers, underscores, and hyphens are allowed.
	ClusterName *string `json:"clusterName,omitempty"`
	// The execute command configuration for the cluster.
	Configuration *ClusterConfiguration `json:"configuration,omitempty"`
	// The capacity provider strategy to set as the default for the cluster. After
	// a default capacity provider strategy is set for a cluster, when you call
	// the RunTask or CreateService APIs with no capacity provider strategy or launch
	// type specified, the default capacity provider strategy for the cluster is
	// used.
	//
	// If a default capacity provider strategy isn't defined for a cluster when
	// it was created, it can be defined later with the PutClusterCapacityProviders
	// API operation.
	DefaultCapacityProviderStrategy []*CapacityProviderStrategyItem `json:"defaultCapacityProviderStrategy,omitempty"`
	// The setting to use when creating a cluster. This parameter is used to turn
	// on CloudWatch Container Insights for a cluster. If this value is specified,
	// it overrides the containerInsights value set with PutAccountSetting or PutAccountSettingDefault.
	Settings []*ClusterSetting `json:"settings,omitempty"`
	// The metadata that you apply to the cluster to help you categorize and organize
	// them. Each tag consists of a key and an optional value. You define both.
	//
	// The following basic restrictions apply to tags:
	//
	//    * Maximum number of tags per resource - 50
	//
	//    * For each resource, each tag key must be unique, and each tag key can
	//    have only one value.
	//
	//    * Maximum key length - 128 Unicode characters in UTF-8
	//
	//    * Maximum value length - 256 Unicode characters in UTF-8
	//
	//    * If your tagging schema is used across multiple services and resources,
	//    remember that other services may have restrictions on allowed characters.
	//    Generally allowed characters are: letters, numbers, and spaces representable
	//    in UTF-8, and the following characters: + - = . _ : / @.
	//
	//    * Tag keys and values are case-sensitive.
	//
	//    * Do not use aws:, AWS:, or any upper or lowercase combination of such
	//    as a prefix for either keys or values as it is reserved for Amazon Web
	//    Services use. You cannot edit or delete tag keys or values with this prefix.
	//    Tags with this prefix do not count against your tags per resource limit.
	Tags                    []*Tag `json:"tags,omitempty"`
	CustomClusterParameters `json:",inline"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       ClusterParameters `json:"forProvider"`
}

// ClusterObservation defines the observed state of Cluster
type ClusterObservation struct {
	// The number of services that are running on the cluster in an ACTIVE state.
	// You can view these services with ListServices.
	ActiveServicesCount *int64 `json:"activeServicesCount,omitempty"`
	// The resources attached to a cluster. When using a capacity provider with
	// a cluster, the Auto Scaling plan that's created is returned as a cluster
	// attachment.
	Attachments []*Attachment `json:"attachments,omitempty"`
	// The status of the capacity providers associated with the cluster. The following
	// are the states that are returned.
	//
	// UPDATE_IN_PROGRESS
	//
	// The available capacity providers for the cluster are updating. This occurs
	// when the Auto Scaling plan is provisioning or deprovisioning.
	//
	// UPDATE_COMPLETE
	//
	// The capacity providers have successfully updated.
	//
	// UPDATE_FAILED
	//
	// The capacity provider updates failed.
	AttachmentsStatus *string `json:"attachmentsStatus,omitempty"`
	// The Amazon Resource Name (ARN) that identifies the cluster. The ARN contains
	// the arn:aws:ecs namespace, followed by the Region of the cluster, the Amazon
	// Web Services account ID of the cluster owner, the cluster namespace, and
	// then the cluster name. For example, arn:aws:ecs:region:012345678910:cluster/test.
	ClusterARN *string `json:"clusterARN,omitempty"`
	// The number of tasks in the cluster that are in the PENDING state.
	PendingTasksCount *int64 `json:"pendingTasksCount,omitempty"`
	// The number of container instances registered into the cluster. This includes
	// container instances in both ACTIVE and DRAINING status.
	RegisteredContainerInstancesCount *int64 `json:"registeredContainerInstancesCount,omitempty"`
	// The number of tasks in the cluster that are in the RUNNING state.
	RunningTasksCount *int64 `json:"runningTasksCount,omitempty"`
	// Additional information about your clusters that are separated by launch type.
	// They include the following:
	//
	//    * runningEC2TasksCount
	//
	//    * RunningFargateTasksCount
	//
	//    * pendingEC2TasksCount
	//
	//    * pendingFargateTasksCount
	//
	//    * activeEC2ServiceCount
	//
	//    * activeFargateServiceCount
	//
	//    * drainingEC2ServiceCount
	//
	//    * drainingFargateServiceCount
	Statistics []*KeyValuePair `json:"statistics,omitempty"`
	// The status of the cluster. The following are the possible states that are
	// returned.
	//
	// ACTIVE
	//
	// The cluster is ready to accept tasks and if applicable you can register container
	// instances with the cluster.
	//
	// PROVISIONING
	//
	// The cluster has capacity providers that are associated with it and the resources
	// needed for the capacity provider are being created.
	//
	// DEPROVISIONING
	//
	// The cluster has capacity providers that are associated with it and the resources
	// needed for the capacity provider are being deleted.
	//
	// FAILED
	//
	// The cluster has capacity providers that are associated with it and the resources
	// needed for the capacity provider have failed to create.
	//
	// INACTIVE
	//
	// The cluster has been deleted. Clusters with an INACTIVE status may remain
	// discoverable in your account for a period of time. However, this behavior
	// is subject to change in the future. We don't recommend that you rely on INACTIVE
	// clusters persisting.
	Status *string `json:"status,omitempty"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	ClusterKind             = "Cluster"
	ClusterGroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ClusterKind}.String()
	ClusterKindAPIVersion   = ClusterKind + "." + GroupVersion.String()
	ClusterGroupVersionKind = GroupVersion.WithKind(ClusterKind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
