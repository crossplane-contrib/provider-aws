/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// ClusterParameters defines the desired state of Cluster
type ClusterParameters struct {
	// Region is which region the Cluster will be created.
	// +kubebuilder:validation:Required
	Region string `json:"region"`
	// The short name of one or more capacity providers to associate with the cluster.
	// A capacity provider must be associated with a cluster before it can be included
	// as part of the default capacity provider strategy of the cluster or used
	// in a capacity provider strategy when calling the CreateService (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html)
	// or RunTask (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html)
	// actions.
	//
	// If specifying a capacity provider that uses an Auto Scaling group, the capacity
	// provider must be created but not associated with another cluster. New Auto
	// Scaling group capacity providers can be created with the CreateCapacityProvider
	// (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateCapacityProvider.html)
	// API operation.
	//
	// To use a Fargate capacity provider, specify either the FARGATE or FARGATE_SPOT
	// capacity providers. The Fargate capacity providers are available to all accounts
	// and only need to be associated with a cluster to be used.
	//
	// The PutCapacityProvider (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutCapacityProvider.html)
	// API operation is used to update the list of available capacity providers
	// for a cluster after the cluster is created.
	CapacityProviders []*string `json:"capacityProviders,omitempty"`
	// The name of your cluster. If you don't specify a name for your cluster, you
	// create a cluster that's named default. Up to 255 letters (uppercase and lowercase),
	// numbers, underscores, and hyphens are allowed.
	ClusterName *string `json:"clusterName,omitempty"`
	// The execute command configuration for the cluster.
	Configuration *ClusterConfiguration `json:"configuration,omitempty"`
	// The capacity provider strategy to set as the default for the cluster. After
	// a default capacity provider strategy is set for a cluster, when you call
	// the CreateService (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html)
	// or RunTask (https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html)
	// APIs with no capacity provider strategy or launch type specified, the default
	// capacity provider strategy for the cluster is used.
	//
	// If a default capacity provider strategy isn't defined for a cluster when
	// it was created, it can be defined later with the PutClusterCapacityProviders
	// API operation.
	DefaultCapacityProviderStrategy []*CapacityProviderStrategyItem `json:"defaultCapacityProviderStrategy,omitempty"`
	// Use this parameter to set a default Service Connect namespace. After you
	// set a default Service Connect namespace, any new services with Service Connect
	// turned on that are created in the cluster are added as client services in
	// the namespace. This setting only applies to new services that set the enabled
	// parameter to true in the ServiceConnectConfiguration. You can set the namespace
	// of each service individually in the ServiceConnectConfiguration to override
	// this default parameter.
	//
	// Tasks that run in a namespace can use short names to connect to services
	// in the namespace. Tasks can connect to services across all of the clusters
	// in the namespace. Tasks connect through a managed proxy container that collects
	// logs and metrics for increased visibility. Only the tasks that Amazon ECS
	// services create are supported with Service Connect. For more information,
	// see Service Connect (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html)
	// in the Amazon Elastic Container Service Developer Guide.
	ServiceConnectDefaults *ClusterServiceConnectDefaultsRequest `json:"serviceConnectDefaults,omitempty"`
	// The setting to use when creating a cluster. This parameter is used to turn
	// on CloudWatch Container Insights for a cluster. If this value is specified,
	// it overrides the containerInsights value set with PutAccountSetting or PutAccountSettingDefault.
	Settings []*ClusterSetting `json:"settings,omitempty"`
	// The metadata that you apply to the cluster to help you categorize and organize
	// them. Each tag consists of a key and an optional value. You define both.
	//
	// The following basic restrictions apply to tags:
	//
	//    * Maximum number of tags per resource - 50
	//
	//    * For each resource, each tag key must be unique, and each tag key can
	//    have only one value.
	//
	//    * Maximum key length - 128 Unicode characters in UTF-8
	//
	//    * Maximum value length - 256 Unicode characters in UTF-8
	//
	//    * If your tagging schema is used across multiple services and resources,
	//    remember that other services may have restrictions on allowed characters.
	//    Generally allowed characters are: letters, numbers, and spaces representable
	//    in UTF-8, and the following characters: + - = . _ : / @.
	//
	//    * Tag keys and values are case-sensitive.
	//
	//    * Do not use aws:, AWS:, or any upper or lowercase combination of such
	//    as a prefix for either keys or values as it is reserved for Amazon Web
	//    Services use. You cannot edit or delete tag keys or values with this prefix.
	//    Tags with this prefix do not count against your tags per resource limit.
	Tags                    []*Tag `json:"tags,omitempty"`
	CustomClusterParameters `json:",inline"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       ClusterParameters `json:"forProvider"`
}

// ClusterObservation defines the observed state of Cluster
type ClusterObservation struct {
	// The number of services that are running on the cluster in an ACTIVE state.
	// You can view these services with ListServices.
	ActiveServicesCount *int64 `json:"activeServicesCount,omitempty"`
	// The resources attached to a cluster. When using a capacity provider with
	// a cluster, the capacity provider and associated resources are returned as
	// cluster attachments.
	Attachments []*Attachment `json:"attachments,omitempty"`
	// The status of the capacity providers associated with the cluster. The following
	// are the states that are returned.
	//
	// UPDATE_IN_PROGRESS
	//
	// The available capacity providers for the cluster are updating.
	//
	// UPDATE_COMPLETE
	//
	// The capacity providers have successfully updated.
	//
	// UPDATE_FAILED
	//
	// The capacity provider updates failed.
	AttachmentsStatus *string `json:"attachmentsStatus,omitempty"`
	// The Amazon Resource Name (ARN) that identifies the cluster. For more information
	// about the ARN format, see Amazon Resource Name (ARN) (https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html#ecs-resource-ids)
	// in the Amazon ECS Developer Guide.
	ClusterARN *string `json:"clusterARN,omitempty"`
	// The number of tasks in the cluster that are in the PENDING state.
	PendingTasksCount *int64 `json:"pendingTasksCount,omitempty"`
	// The number of container instances registered into the cluster. This includes
	// container instances in both ACTIVE and DRAINING status.
	RegisteredContainerInstancesCount *int64 `json:"registeredContainerInstancesCount,omitempty"`
	// The number of tasks in the cluster that are in the RUNNING state.
	RunningTasksCount *int64 `json:"runningTasksCount,omitempty"`
	// Additional information about your clusters that are separated by launch type.
	// They include the following:
	//
	//    * runningEC2TasksCount
	//
	//    * RunningFargateTasksCount
	//
	//    * pendingEC2TasksCount
	//
	//    * pendingFargateTasksCount
	//
	//    * activeEC2ServiceCount
	//
	//    * activeFargateServiceCount
	//
	//    * drainingEC2ServiceCount
	//
	//    * drainingFargateServiceCount
	Statistics []*KeyValuePair `json:"statistics,omitempty"`
	// The status of the cluster. The following are the possible states that are
	// returned.
	//
	// ACTIVE
	//
	// The cluster is ready to accept tasks and if applicable you can register container
	// instances with the cluster.
	//
	// PROVISIONING
	//
	// The cluster has capacity providers that are associated with it and the resources
	// needed for the capacity provider are being created.
	//
	// DEPROVISIONING
	//
	// The cluster has capacity providers that are associated with it and the resources
	// needed for the capacity provider are being deleted.
	//
	// FAILED
	//
	// The cluster has capacity providers that are associated with it and the resources
	// needed for the capacity provider have failed to create.
	//
	// INACTIVE
	//
	// The cluster has been deleted. Clusters with an INACTIVE status may remain
	// discoverable in your account for a period of time. However, this behavior
	// is subject to change in the future. We don't recommend that you rely on INACTIVE
	// clusters persisting.
	Status *string `json:"status,omitempty"`

	CustomClusterObservation `json:",inline"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	ClusterKind             = "Cluster"
	ClusterGroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ClusterKind}.String()
	ClusterKindAPIVersion   = ClusterKind + "." + GroupVersion.String()
	ClusterGroupVersionKind = GroupVersion.WithKind(ClusterKind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
