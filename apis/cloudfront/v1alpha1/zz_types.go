/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Hack to avoid import errors during build...
var (
	_ = &metav1.Time{}
)

type ActiveTrustedKeyGroups struct {
	Enabled *bool `json:"enabled,omitempty"`

	Items []*KGKeyPairIDs `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type ActiveTrustedSigners struct {
	Enabled *bool `json:"enabled,omitempty"`

	Items []*Signer `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type AliasICPRecordal struct {
	CNAME *string `json:"cNAME,omitempty"`

	ICPRecordalStatus *string `json:"iCPRecordalStatus,omitempty"`
}

type Aliases struct {
	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type AllowedMethods struct {
	// A complex type that controls whether CloudFront caches the response to requests
	// using the specified HTTP methods. There are two choices:
	//
	//    * CloudFront caches responses to GET and HEAD requests.
	//
	//    * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
	//
	// If you pick the second choice for your Amazon S3 Origin, you may need to
	// forward Access-Control-Request-Method, Access-Control-Request-Headers, and
	// Origin headers for the responses to be cached correctly.
	CachedMethods *CachedMethods `json:"cachedMethods,omitempty"`

	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type CacheBehavior struct {
	// A complex type that controls which HTTP methods CloudFront processes and
	// forwards to your Amazon S3 bucket or your custom origin. There are three
	// choices:
	//
	//    * CloudFront forwards only GET and HEAD requests.
	//
	//    * CloudFront forwards only GET, HEAD, and OPTIONS requests.
	//
	//    * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE
	//    requests.
	//
	// If you pick the third choice, you may need to restrict access to your Amazon
	// S3 bucket or to your custom origin so users can't perform operations that
	// you don't want them to. For example, you might not want users to have permissions
	// to delete objects from your origin.
	AllowedMethods *AllowedMethods `json:"allowedMethods,omitempty"`

	CachePolicyID *string `json:"cachePolicyID,omitempty"`

	Compress *bool `json:"compress,omitempty"`

	DefaultTTL *int64 `json:"defaultTTL,omitempty"`

	FieldLevelEncryptionID *string `json:"fieldLevelEncryptionID,omitempty"`
	// This field is deprecated. We recommend that you use a cache policy or an
	// origin request policy instead of this field.
	//
	// If you want to include values in the cache key, use a cache policy. For more
	// information, see Creating cache policies (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy)
	// in the Amazon CloudFront Developer Guide.
	//
	// If you want to send values to the origin but not include them in the cache
	// key, use an origin request policy. For more information, see Creating origin
	// request policies (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy)
	// in the Amazon CloudFront Developer Guide.
	//
	// A complex type that specifies how CloudFront handles query strings, cookies,
	// and HTTP headers.
	ForwardedValues *ForwardedValues `json:"forwardedValues,omitempty"`
	// A complex type that specifies a list of Lambda functions associations for
	// a cache behavior.
	//
	// If you want to invoke one or more Lambda functions triggered by requests
	// that match the PathPattern of the cache behavior, specify the applicable
	// values for Quantity and Items. Note that there can be up to 4 LambdaFunctionAssociation
	// items in this list (one for each possible value of EventType) and each EventType
	// can be associated with the Lambda function only once.
	//
	// If you don't want to invoke any Lambda functions for the requests that match
	// PathPattern, specify 0 for Quantity and omit Items.
	LambdaFunctionAssociations *LambdaFunctionAssociations `json:"lambdaFunctionAssociations,omitempty"`

	MaxTTL *int64 `json:"maxTTL,omitempty"`

	MinTTL *int64 `json:"minTTL,omitempty"`

	OriginRequestPolicyID *string `json:"originRequestPolicyID,omitempty"`

	PathPattern *string `json:"pathPattern,omitempty"`

	RealtimeLogConfigARN *string `json:"realtimeLogConfigARN,omitempty"`

	SmoothStreaming *bool `json:"smoothStreaming,omitempty"`

	TargetOriginID *string `json:"targetOriginID,omitempty"`
	// A list of key groups whose public keys CloudFront can use to verify the signatures
	// of signed URLs and signed cookies.
	TrustedKeyGroups *TrustedKeyGroups `json:"trustedKeyGroups,omitempty"`
	// A list of AWS accounts whose public keys CloudFront can use to verify the
	// signatures of signed URLs and signed cookies.
	TrustedSigners *TrustedSigners `json:"trustedSigners,omitempty"`

	ViewerProtocolPolicy *string `json:"viewerProtocolPolicy,omitempty"`
}

type CacheBehaviors struct {
	Items []*CacheBehavior `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type CachePolicy struct {
	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`
}

type CachePolicyConfig struct {
	Comment *string `json:"comment,omitempty"`

	DefaultTTL *int64 `json:"defaultTTL,omitempty"`

	MaxTTL *int64 `json:"maxTTL,omitempty"`

	MinTTL *int64 `json:"minTTL,omitempty"`

	Name *string `json:"name,omitempty"`
}

type CachePolicyCookiesConfig struct {
	// Contains a list of cookie names.
	Cookies *CookieNames `json:"cookies,omitempty"`
}

type CachePolicyHeadersConfig struct {
	// Contains a list of HTTP header names.
	Headers *Headers `json:"headers,omitempty"`
}

type CachePolicyList struct {
	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type CachedMethods struct {
	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type ContentTypeProfile struct {
	ContentType *string `json:"contentType,omitempty"`

	ProfileID *string `json:"profileID,omitempty"`
}

type ContentTypeProfileConfig struct {
	ForwardWhenContentTypeIsUnknown *bool `json:"forwardWhenContentTypeIsUnknown,omitempty"`
}

type ContentTypeProfiles struct {
	Quantity *int64 `json:"quantity,omitempty"`
}

type CookieNames struct {
	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type CookiePreference struct {
	Forward *string `json:"forward,omitempty"`
	// Contains a list of cookie names.
	WhitelistedNames *CookieNames `json:"whitelistedNames,omitempty"`
}

type CustomErrorResponse struct {
	ErrorCachingMinTTL *int64 `json:"errorCachingMinTTL,omitempty"`

	ErrorCode *int64 `json:"errorCode,omitempty"`

	ResponseCode *string `json:"responseCode,omitempty"`

	ResponsePagePath *string `json:"responsePagePath,omitempty"`
}

type CustomErrorResponses struct {
	Items []*CustomErrorResponse `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type CustomHeaders struct {
	Items []*OriginCustomHeader `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type CustomOriginConfig struct {
	HTTPPort *int64 `json:"httpPort,omitempty"`

	HTTPSPort *int64 `json:"httpSPort,omitempty"`

	OriginKeepaliveTimeout *int64 `json:"originKeepaliveTimeout,omitempty"`

	OriginProtocolPolicy *string `json:"originProtocolPolicy,omitempty"`

	OriginReadTimeout *int64 `json:"originReadTimeout,omitempty"`
	// A complex type that contains information about the SSL/TLS protocols that
	// CloudFront can use when establishing an HTTPS connection with your origin.
	OriginSSLProtocols *OriginSSLProtocols `json:"originSSLProtocols,omitempty"`
}

type DefaultCacheBehavior struct {
	// A complex type that controls which HTTP methods CloudFront processes and
	// forwards to your Amazon S3 bucket or your custom origin. There are three
	// choices:
	//
	//    * CloudFront forwards only GET and HEAD requests.
	//
	//    * CloudFront forwards only GET, HEAD, and OPTIONS requests.
	//
	//    * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE
	//    requests.
	//
	// If you pick the third choice, you may need to restrict access to your Amazon
	// S3 bucket or to your custom origin so users can't perform operations that
	// you don't want them to. For example, you might not want users to have permissions
	// to delete objects from your origin.
	AllowedMethods *AllowedMethods `json:"allowedMethods,omitempty"`

	CachePolicyID *string `json:"cachePolicyID,omitempty"`

	Compress *bool `json:"compress,omitempty"`

	DefaultTTL *int64 `json:"defaultTTL,omitempty"`

	FieldLevelEncryptionID *string `json:"fieldLevelEncryptionID,omitempty"`
	// This field is deprecated. We recommend that you use a cache policy or an
	// origin request policy instead of this field.
	//
	// If you want to include values in the cache key, use a cache policy. For more
	// information, see Creating cache policies (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy)
	// in the Amazon CloudFront Developer Guide.
	//
	// If you want to send values to the origin but not include them in the cache
	// key, use an origin request policy. For more information, see Creating origin
	// request policies (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy)
	// in the Amazon CloudFront Developer Guide.
	//
	// A complex type that specifies how CloudFront handles query strings, cookies,
	// and HTTP headers.
	ForwardedValues *ForwardedValues `json:"forwardedValues,omitempty"`
	// A complex type that specifies a list of Lambda functions associations for
	// a cache behavior.
	//
	// If you want to invoke one or more Lambda functions triggered by requests
	// that match the PathPattern of the cache behavior, specify the applicable
	// values for Quantity and Items. Note that there can be up to 4 LambdaFunctionAssociation
	// items in this list (one for each possible value of EventType) and each EventType
	// can be associated with the Lambda function only once.
	//
	// If you don't want to invoke any Lambda functions for the requests that match
	// PathPattern, specify 0 for Quantity and omit Items.
	LambdaFunctionAssociations *LambdaFunctionAssociations `json:"lambdaFunctionAssociations,omitempty"`

	MaxTTL *int64 `json:"maxTTL,omitempty"`

	MinTTL *int64 `json:"minTTL,omitempty"`

	OriginRequestPolicyID *string `json:"originRequestPolicyID,omitempty"`

	RealtimeLogConfigARN *string `json:"realtimeLogConfigARN,omitempty"`

	SmoothStreaming *bool `json:"smoothStreaming,omitempty"`

	TargetOriginID *string `json:"targetOriginID,omitempty"`
	// A list of key groups whose public keys CloudFront can use to verify the signatures
	// of signed URLs and signed cookies.
	TrustedKeyGroups *TrustedKeyGroups `json:"trustedKeyGroups,omitempty"`
	// A list of AWS accounts whose public keys CloudFront can use to verify the
	// signatures of signed URLs and signed cookies.
	TrustedSigners *TrustedSigners `json:"trustedSigners,omitempty"`

	ViewerProtocolPolicy *string `json:"viewerProtocolPolicy,omitempty"`
}

type DistributionConfig struct {
	// A complex type that contains information about CNAMEs (alternate domain names),
	// if any, for this distribution.
	Aliases *Aliases `json:"aliases,omitempty"`
	// A complex type that contains zero or more CacheBehavior elements.
	CacheBehaviors *CacheBehaviors `json:"cacheBehaviors,omitempty"`

	Comment *string `json:"comment,omitempty"`
	// A complex type that controls:
	//
	//    * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range
	//    with custom error messages before returning the response to the viewer.
	//
	//    * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
	//
	// For more information about custom error pages, see Customizing Error Responses
	// (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html)
	// in the Amazon CloudFront Developer Guide.
	CustomErrorResponses *CustomErrorResponses `json:"customErrorResponses,omitempty"`
	// A complex type that describes the default cache behavior if you don’t specify
	// a CacheBehavior element or if request URLs don’t match any of the values
	// of PathPattern in CacheBehavior elements. You must create exactly one default
	// cache behavior.
	DefaultCacheBehavior *DefaultCacheBehavior `json:"defaultCacheBehavior,omitempty"`

	DefaultRootObject *string `json:"defaultRootObject,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`

	HTTPVersion *string `json:"httpVersion,omitempty"`

	IsIPV6Enabled *bool `json:"isIPV6Enabled,omitempty"`
	// A complex type that controls whether access logs are written for the distribution.
	Logging *LoggingConfig `json:"logging,omitempty"`
	// A complex data type for the origin groups specified for a distribution.
	OriginGroups *OriginGroups `json:"originGroups,omitempty"`
	// Contains information about the origins for this distribution.
	Origins *Origins `json:"origins,omitempty"`

	PriceClass *string `json:"priceClass,omitempty"`
	// A complex type that identifies ways in which you want to restrict distribution
	// of your content.
	Restrictions *Restrictions `json:"restrictions,omitempty"`
	// A complex type that determines the distribution’s SSL/TLS configuration
	// for communicating with viewers.
	//
	// If the distribution doesn’t use Aliases (also known as alternate domain
	// names or CNAMEs)—that is, if the distribution uses the CloudFront domain
	// name such as d111111abcdef8.cloudfront.net—set CloudFrontDefaultCertificate
	// to true and leave all other fields empty.
	//
	// If the distribution uses Aliases (alternate domain names or CNAMEs), use
	// the fields in this type to specify the following settings:
	//
	//    * Which viewers the distribution accepts HTTPS connections from: only
	//    viewers that support server name indication (SNI) (https://en.wikipedia.org/wiki/Server_Name_Indication)
	//    (recommended), or all viewers including those that don’t support SNI.
	//    To accept HTTPS connections from only viewers that support SNI, set SSLSupportMethod
	//    to sni-only. This is recommended. Most browsers and clients support SNI.
	//    To accept HTTPS connections from all viewers, including those that don’t
	//    support SNI, set SSLSupportMethod to vip. This is not recommended, and
	//    results in additional monthly charges from CloudFront.
	//
	//    * The minimum SSL/TLS protocol version that the distribution can use to
	//    communicate with viewers. To specify a minimum version, choose a value
	//    for MinimumProtocolVersion. For more information, see Security Policy
	//    (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy)
	//    in the Amazon CloudFront Developer Guide.
	//
	//    * The location of the SSL/TLS certificate, AWS Certificate Manager (ACM)
	//    (https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended)
	//    or AWS Identity and Access Management (AWS IAM) (https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html).
	//    You specify the location by setting a value in one of the following fields
	//    (not both): ACMCertificateArn IAMCertificateId
	//
	// All distributions support HTTPS connections from viewers. To require viewers
	// to use HTTPS only, or to redirect them from HTTP to HTTPS, use ViewerProtocolPolicy
	// in the CacheBehavior or DefaultCacheBehavior. To specify how CloudFront should
	// use SSL/TLS to communicate with your custom origin, use CustomOriginConfig.
	//
	// For more information, see Using HTTPS with CloudFront (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html)
	// and Using Alternate Domain Names and HTTPS (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html)
	// in the Amazon CloudFront Developer Guide.
	ViewerCertificate *ViewerCertificate `json:"viewerCertificate,omitempty"`

	WebACLID *string `json:"webACLID,omitempty"`
}

type DistributionConfigWithTags struct {
	// A distribution configuration.
	DistributionConfig *DistributionConfig `json:"distributionConfig,omitempty"`
}

type DistributionIDList struct {
	IsTruncated *bool `json:"isTruncated,omitempty"`

	Marker *string `json:"marker,omitempty"`

	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type DistributionList_SDK struct {
	IsTruncated *bool `json:"isTruncated,omitempty"`

	Items []*DistributionSummary `json:"items,omitempty"`

	Marker *string `json:"marker,omitempty"`

	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type DistributionSummary struct {
	ARN *string `json:"arn,omitempty"`

	AliasICPRecordals []*AliasICPRecordal `json:"aliasICPRecordals,omitempty"`
	// A complex type that contains information about CNAMEs (alternate domain names),
	// if any, for this distribution.
	Aliases *Aliases `json:"aliases,omitempty"`
	// A complex type that contains zero or more CacheBehavior elements.
	CacheBehaviors *CacheBehaviors `json:"cacheBehaviors,omitempty"`

	Comment *string `json:"comment,omitempty"`
	// A complex type that controls:
	//
	//    * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range
	//    with custom error messages before returning the response to the viewer.
	//
	//    * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
	//
	// For more information about custom error pages, see Customizing Error Responses
	// (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html)
	// in the Amazon CloudFront Developer Guide.
	CustomErrorResponses *CustomErrorResponses `json:"customErrorResponses,omitempty"`
	// A complex type that describes the default cache behavior if you don’t specify
	// a CacheBehavior element or if request URLs don’t match any of the values
	// of PathPattern in CacheBehavior elements. You must create exactly one default
	// cache behavior.
	DefaultCacheBehavior *DefaultCacheBehavior `json:"defaultCacheBehavior,omitempty"`

	DomainName *string `json:"domainName,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`

	HTTPVersion *string `json:"httpVersion,omitempty"`

	ID *string `json:"id,omitempty"`

	IsIPV6Enabled *bool `json:"isIPV6Enabled,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`
	// A complex data type for the origin groups specified for a distribution.
	OriginGroups *OriginGroups `json:"originGroups,omitempty"`
	// Contains information about the origins for this distribution.
	Origins *Origins `json:"origins,omitempty"`

	PriceClass *string `json:"priceClass,omitempty"`
	// A complex type that identifies ways in which you want to restrict distribution
	// of your content.
	Restrictions *Restrictions `json:"restrictions,omitempty"`

	Status *string `json:"status,omitempty"`
	// A complex type that determines the distribution’s SSL/TLS configuration
	// for communicating with viewers.
	//
	// If the distribution doesn’t use Aliases (also known as alternate domain
	// names or CNAMEs)—that is, if the distribution uses the CloudFront domain
	// name such as d111111abcdef8.cloudfront.net—set CloudFrontDefaultCertificate
	// to true and leave all other fields empty.
	//
	// If the distribution uses Aliases (alternate domain names or CNAMEs), use
	// the fields in this type to specify the following settings:
	//
	//    * Which viewers the distribution accepts HTTPS connections from: only
	//    viewers that support server name indication (SNI) (https://en.wikipedia.org/wiki/Server_Name_Indication)
	//    (recommended), or all viewers including those that don’t support SNI.
	//    To accept HTTPS connections from only viewers that support SNI, set SSLSupportMethod
	//    to sni-only. This is recommended. Most browsers and clients support SNI.
	//    To accept HTTPS connections from all viewers, including those that don’t
	//    support SNI, set SSLSupportMethod to vip. This is not recommended, and
	//    results in additional monthly charges from CloudFront.
	//
	//    * The minimum SSL/TLS protocol version that the distribution can use to
	//    communicate with viewers. To specify a minimum version, choose a value
	//    for MinimumProtocolVersion. For more information, see Security Policy
	//    (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy)
	//    in the Amazon CloudFront Developer Guide.
	//
	//    * The location of the SSL/TLS certificate, AWS Certificate Manager (ACM)
	//    (https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended)
	//    or AWS Identity and Access Management (AWS IAM) (https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html).
	//    You specify the location by setting a value in one of the following fields
	//    (not both): ACMCertificateArn IAMCertificateId
	//
	// All distributions support HTTPS connections from viewers. To require viewers
	// to use HTTPS only, or to redirect them from HTTP to HTTPS, use ViewerProtocolPolicy
	// in the CacheBehavior or DefaultCacheBehavior. To specify how CloudFront should
	// use SSL/TLS to communicate with your custom origin, use CustomOriginConfig.
	//
	// For more information, see Using HTTPS with CloudFront (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html)
	// and Using Alternate Domain Names and HTTPS (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html)
	// in the Amazon CloudFront Developer Guide.
	ViewerCertificate *ViewerCertificate `json:"viewerCertificate,omitempty"`

	WebACLID *string `json:"webACLID,omitempty"`
}

type Distribution_SDK struct {
	ARN *string `json:"arn,omitempty"`
	// A list of key groups, and the public keys in each key group, that CloudFront
	// can use to verify the signatures of signed URLs and signed cookies.
	ActiveTrustedKeyGroups *ActiveTrustedKeyGroups `json:"activeTrustedKeyGroups,omitempty"`
	// A list of AWS accounts and the active CloudFront key pairs in each account
	// that CloudFront can use to verify the signatures of signed URLs and signed
	// cookies.
	ActiveTrustedSigners *ActiveTrustedSigners `json:"activeTrustedSigners,omitempty"`

	AliasICPRecordals []*AliasICPRecordal `json:"aliasICPRecordals,omitempty"`
	// A distribution configuration.
	DistributionConfig *DistributionConfig `json:"distributionConfig,omitempty"`

	DomainName *string `json:"domainName,omitempty"`

	ID *string `json:"id,omitempty"`

	InProgressInvalidationBatches *int64 `json:"inProgressInvalidationBatches,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`

	Status *string `json:"status,omitempty"`
}

type EncryptionEntities struct {
	Quantity *int64 `json:"quantity,omitempty"`
}

type EncryptionEntity struct {
	ProviderID *string `json:"providerID,omitempty"`

	PublicKeyID *string `json:"publicKeyID,omitempty"`
}

type EndPoint struct {
	StreamType *string `json:"streamType,omitempty"`
}

type FieldLevelEncryption struct {
	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`
}

type FieldLevelEncryptionConfig struct {
	CallerReference *string `json:"callerReference,omitempty"`

	Comment *string `json:"comment,omitempty"`
}

type FieldLevelEncryptionList struct {
	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type FieldLevelEncryptionProfile struct {
	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`
}

type FieldLevelEncryptionProfileConfig struct {
	CallerReference *string `json:"callerReference,omitempty"`

	Comment *string `json:"comment,omitempty"`

	Name *string `json:"name,omitempty"`
}

type FieldLevelEncryptionProfileList struct {
	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type FieldLevelEncryptionProfileSummary struct {
	Comment *string `json:"comment,omitempty"`

	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`

	Name *string `json:"name,omitempty"`
}

type FieldLevelEncryptionSummary struct {
	Comment *string `json:"comment,omitempty"`

	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`
}

type FieldPatterns struct {
	Quantity *int64 `json:"quantity,omitempty"`
}

type ForwardedValues struct {
	// This field is deprecated. We recommend that you use a cache policy or an
	// origin request policy instead of this field.
	//
	// If you want to include cookies in the cache key, use CookiesConfig in a cache
	// policy. See CachePolicy.
	//
	// If you want to send cookies to the origin but not include them in the cache
	// key, use CookiesConfig in an origin request policy. See OriginRequestPolicy.
	//
	// A complex type that specifies whether you want CloudFront to forward cookies
	// to the origin and, if so, which ones. For more information about forwarding
	// cookies to the origin, see Caching Content Based on Cookies (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html)
	// in the Amazon CloudFront Developer Guide.
	Cookies *CookiePreference `json:"cookies,omitempty"`
	// Contains a list of HTTP header names.
	Headers *Headers `json:"headers,omitempty"`

	QueryString *bool `json:"queryString,omitempty"`
	// This field is deprecated. We recommend that you use a cache policy or an
	// origin request policy instead of this field.
	//
	// If you want to include query strings in the cache key, use QueryStringsConfig
	// in a cache policy. See CachePolicy.
	//
	// If you want to send query strings to the origin but not include them in the
	// cache key, use QueryStringsConfig in an origin request policy. See OriginRequestPolicy.
	//
	// A complex type that contains information about the query string parameters
	// that you want CloudFront to use for caching for a cache behavior.
	QueryStringCacheKeys *QueryStringCacheKeys `json:"queryStringCacheKeys,omitempty"`
}

type GeoRestriction struct {
	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`

	RestrictionType *string `json:"restrictionType,omitempty"`
}

type Headers struct {
	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type Invalidation struct {
	CreateTime *metav1.Time `json:"createTime,omitempty"`

	ID *string `json:"id,omitempty"`

	Status *string `json:"status,omitempty"`
}

type InvalidationBatch struct {
	CallerReference *string `json:"callerReference,omitempty"`
}

type InvalidationList struct {
	IsTruncated *bool `json:"isTruncated,omitempty"`

	Marker *string `json:"marker,omitempty"`

	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type InvalidationSummary struct {
	CreateTime *metav1.Time `json:"createTime,omitempty"`

	ID *string `json:"id,omitempty"`

	Status *string `json:"status,omitempty"`
}

type KGKeyPairIDs struct {
	KeyGroupID *string `json:"keyGroupID,omitempty"`
	// A list of CloudFront key pair identifiers.
	KeyPairIDs *KeyPairIDs `json:"keyPairIDs,omitempty"`
}

type KeyGroup struct {
	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`
}

type KeyGroupConfig struct {
	Comment *string `json:"comment,omitempty"`

	Name *string `json:"name,omitempty"`
}

type KeyGroupList struct {
	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type KeyPairIDs struct {
	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type KinesisStreamConfig struct {
	RoleARN *string `json:"roleARN,omitempty"`

	StreamARN *string `json:"streamARN,omitempty"`
}

type LambdaFunctionAssociation struct {
	EventType *string `json:"eventType,omitempty"`

	IncludeBody *bool `json:"includeBody,omitempty"`

	LambdaFunctionARN *string `json:"lambdaFunctionARN,omitempty"`
}

type LambdaFunctionAssociations struct {
	Items []*LambdaFunctionAssociation `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type LoggingConfig struct {
	Bucket *string `json:"bucket,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`

	IncludeCookies *bool `json:"includeCookies,omitempty"`

	Prefix *string `json:"prefix,omitempty"`
}

type Origin struct {
	ConnectionAttempts *int64 `json:"connectionAttempts,omitempty"`

	ConnectionTimeout *int64 `json:"connectionTimeout,omitempty"`
	// A complex type that contains the list of Custom Headers for each origin.
	CustomHeaders *CustomHeaders `json:"customHeaders,omitempty"`
	// A custom origin. A custom origin is any origin that is not an Amazon S3 bucket,
	// with one exception. An Amazon S3 bucket that is configured with static website
	// hosting (https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html)
	// is a custom origin.
	CustomOriginConfig *CustomOriginConfig `json:"customOriginConfig,omitempty"`

	DomainName *string `json:"domainName,omitempty"`

	ID *string `json:"id,omitempty"`

	OriginPath *string `json:"originPath,omitempty"`
	// CloudFront Origin Shield.
	//
	// Using Origin Shield can help reduce the load on your origin. For more information,
	// see Using Origin Shield (https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html)
	// in the Amazon CloudFront Developer Guide.
	OriginShield *OriginShield `json:"originShield,omitempty"`
	// A complex type that contains information about the Amazon S3 origin. If the
	// origin is a custom origin or an S3 bucket that is configured as a website
	// endpoint, use the CustomOriginConfig element instead.
	S3OriginConfig *S3OriginConfig `json:"s3OriginConfig,omitempty"`
}

type OriginAccessIDentity struct {
	ID *string `json:"id,omitempty"`

	S3CanonicalUserID *string `json:"s3CanonicalUserID,omitempty"`
}

type OriginAccessIDentityConfig struct {
	CallerReference *string `json:"callerReference,omitempty"`

	Comment *string `json:"comment,omitempty"`
}

type OriginAccessIDentityList struct {
	IsTruncated *bool `json:"isTruncated,omitempty"`

	Marker *string `json:"marker,omitempty"`

	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type OriginAccessIDentitySummary struct {
	Comment *string `json:"comment,omitempty"`

	ID *string `json:"id,omitempty"`

	S3CanonicalUserID *string `json:"s3CanonicalUserID,omitempty"`
}

type OriginCustomHeader struct {
	HeaderName *string `json:"headerName,omitempty"`

	HeaderValue *string `json:"headerValue,omitempty"`
}

type OriginGroup struct {
	// A complex data type that includes information about the failover criteria
	// for an origin group, including the status codes for which CloudFront will
	// failover from the primary origin to the second origin.
	FailoverCriteria *OriginGroupFailoverCriteria `json:"failoverCriteria,omitempty"`

	ID *string `json:"id,omitempty"`
	// A complex data type for the origins included in an origin group.
	Members *OriginGroupMembers `json:"members,omitempty"`
}

type OriginGroupFailoverCriteria struct {
	// A complex data type for the status codes that you specify that, when returned
	// by a primary origin, trigger CloudFront to failover to a second origin.
	StatusCodes *StatusCodes `json:"statusCodes,omitempty"`
}

type OriginGroupMember struct {
	OriginID *string `json:"originID,omitempty"`
}

type OriginGroupMembers struct {
	// List of origins in an origin group.
	Items []*OriginGroupMember `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type OriginGroups struct {
	// List of origin groups for a distribution.
	Items []*OriginGroup `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type OriginRequestPolicy struct {
	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`
}

type OriginRequestPolicyConfig struct {
	Comment *string `json:"comment,omitempty"`

	Name *string `json:"name,omitempty"`
}

type OriginRequestPolicyCookiesConfig struct {
	// Contains a list of cookie names.
	Cookies *CookieNames `json:"cookies,omitempty"`
}

type OriginRequestPolicyHeadersConfig struct {
	// Contains a list of HTTP header names.
	Headers *Headers `json:"headers,omitempty"`
}

type OriginRequestPolicyList struct {
	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type OriginSSLProtocols struct {
	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type OriginShield struct {
	Enabled *bool `json:"enabled,omitempty"`

	OriginShieldRegion *string `json:"originShieldRegion,omitempty"`
}

type Origins struct {
	Items []*Origin `json:"items,omitempty"`
}

type ParametersInCacheKeyAndForwardedToOrigin struct {
	EnableAcceptEncodingBrotli *bool `json:"enableAcceptEncodingBrotli,omitempty"`

	EnableAcceptEncodingGzip *bool `json:"enableAcceptEncodingGzip,omitempty"`
}

type Paths struct {
	Quantity *int64 `json:"quantity,omitempty"`
}

type PublicKey struct {
	CreatedTime *metav1.Time `json:"createdTime,omitempty"`

	ID *string `json:"id,omitempty"`
}

type PublicKeyConfig struct {
	CallerReference *string `json:"callerReference,omitempty"`

	Comment *string `json:"comment,omitempty"`

	EncodedKey *string `json:"encodedKey,omitempty"`

	Name *string `json:"name,omitempty"`
}

type PublicKeyList struct {
	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type PublicKeySummary struct {
	Comment *string `json:"comment,omitempty"`

	CreatedTime *metav1.Time `json:"createdTime,omitempty"`

	EncodedKey *string `json:"encodedKey,omitempty"`

	ID *string `json:"id,omitempty"`

	Name *string `json:"name,omitempty"`
}

type QueryArgProfile struct {
	ProfileID *string `json:"profileID,omitempty"`

	QueryArg *string `json:"queryArg,omitempty"`
}

type QueryArgProfileConfig struct {
	ForwardWhenQueryArgProfileIsUnknown *bool `json:"forwardWhenQueryArgProfileIsUnknown,omitempty"`
}

type QueryArgProfiles struct {
	Quantity *int64 `json:"quantity,omitempty"`
}

type QueryStringCacheKeys struct {
	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type QueryStringNames struct {
	Quantity *int64 `json:"quantity,omitempty"`
}

type RealtimeLogConfig struct {
	ARN *string `json:"arn,omitempty"`

	Name *string `json:"name,omitempty"`

	SamplingRate *int64 `json:"samplingRate,omitempty"`
}

type RealtimeLogConfigs struct {
	IsTruncated *bool `json:"isTruncated,omitempty"`

	Marker *string `json:"marker,omitempty"`

	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`
}

type Restrictions struct {
	// A complex type that controls the countries in which your content is distributed.
	// CloudFront determines the location of your users using MaxMind GeoIP databases.
	GeoRestriction *GeoRestriction `json:"geoRestriction,omitempty"`
}

type S3Origin struct {
	DomainName *string `json:"domainName,omitempty"`

	OriginAccessIDentity *string `json:"originAccessIDentity,omitempty"`
}

type S3OriginConfig struct {
	OriginAccessIDentity *string `json:"originAccessIDentity,omitempty"`
}

type Signer struct {
	AWSAccountNumber *string `json:"awsAccountNumber,omitempty"`
	// A list of CloudFront key pair identifiers.
	KeyPairIDs *KeyPairIDs `json:"keyPairIDs,omitempty"`
}

type StatusCodes struct {
	// List of status codes for origin failover.
	Items []*int64 `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type StreamingDistribution struct {
	ARN *string `json:"arn,omitempty"`
	// A list of AWS accounts and the active CloudFront key pairs in each account
	// that CloudFront can use to verify the signatures of signed URLs and signed
	// cookies.
	ActiveTrustedSigners *ActiveTrustedSigners `json:"activeTrustedSigners,omitempty"`

	DomainName *string `json:"domainName,omitempty"`

	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`

	Status *string `json:"status,omitempty"`
}

type StreamingDistributionConfig struct {
	// A complex type that contains information about CNAMEs (alternate domain names),
	// if any, for this distribution.
	Aliases *Aliases `json:"aliases,omitempty"`

	CallerReference *string `json:"callerReference,omitempty"`

	Comment *string `json:"comment,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`

	PriceClass *string `json:"priceClass,omitempty"`
	// A list of AWS accounts whose public keys CloudFront can use to verify the
	// signatures of signed URLs and signed cookies.
	TrustedSigners *TrustedSigners `json:"trustedSigners,omitempty"`
}

type StreamingDistributionList struct {
	IsTruncated *bool `json:"isTruncated,omitempty"`

	Marker *string `json:"marker,omitempty"`

	MaxItems *int64 `json:"maxItems,omitempty"`

	NextMarker *string `json:"nextMarker,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type StreamingDistributionSummary struct {
	ARN *string `json:"arn,omitempty"`
	// A complex type that contains information about CNAMEs (alternate domain names),
	// if any, for this distribution.
	Aliases *Aliases `json:"aliases,omitempty"`

	Comment *string `json:"comment,omitempty"`

	DomainName *string `json:"domainName,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`

	ID *string `json:"id,omitempty"`

	LastModifiedTime *metav1.Time `json:"lastModifiedTime,omitempty"`

	PriceClass *string `json:"priceClass,omitempty"`

	Status *string `json:"status,omitempty"`
	// A list of AWS accounts whose public keys CloudFront can use to verify the
	// signatures of signed URLs and signed cookies.
	TrustedSigners *TrustedSigners `json:"trustedSigners,omitempty"`
}

type StreamingLoggingConfig struct {
	Bucket *string `json:"bucket,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`

	Prefix *string `json:"prefix,omitempty"`
}

type TrustedKeyGroups struct {
	Enabled *bool `json:"enabled,omitempty"`

	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type TrustedSigners struct {
	Enabled *bool `json:"enabled,omitempty"`

	Items []*string `json:"items,omitempty"`

	Quantity *int64 `json:"quantity,omitempty"`
}

type ViewerCertificate struct {
	ACMCertificateARN *string `json:"aCMCertificateARN,omitempty"`

	Certificate *string `json:"certificate,omitempty"`

	CertificateSource *string `json:"certificateSource,omitempty"`

	CloudFrontDefaultCertificate *bool `json:"cloudFrontDefaultCertificate,omitempty"`

	IAMCertificateID *string `json:"iamCertificateID,omitempty"`

	MinimumProtocolVersion *string `json:"minimumProtocolVersion,omitempty"`

	SSLSupportMethod *string `json:"sslSupportMethod,omitempty"`
}
