/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// StreamParameters defines the desired state of Stream
type StreamParameters struct {
	// Region is which region the Stream will be created.
	// +kubebuilder:validation:Required
	Region string `json:"region"`
	// The number of shards that the stream will use. The throughput of the stream
	// is a function of the number of shards; more shards are required for greater
	// provisioned throughput.
	// +kubebuilder:validation:Required
	ShardCount             *int64 `json:"shardCount"`
	CustomStreamParameters `json:",inline"`
}

// StreamSpec defines the desired state of Stream
type StreamSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       StreamParameters `json:"forProvider"`
}

// StreamObservation defines the observed state of Stream
type StreamObservation struct {
	// The server-side encryption type used on the stream. This parameter can be
	// one of the following values:
	//
	//    * NONE: Do not encrypt the records in the stream.
	//
	//    * KMS: Use server-side encryption on the records in the stream using a
	//    customer-managed AWS KMS key.
	EncryptionType *string `json:"encryptionType,omitempty"`
	// Represents the current enhanced monitoring settings of the stream.
	EnhancedMonitoring []*EnhancedMetrics `json:"enhancedMonitoring,omitempty"`
	// If set to true, more shards in the stream are available to describe.
	HasMoreShards *bool `json:"hasMoreShards,omitempty"`
	// The GUID for the customer-managed AWS KMS key to use for encryption. This
	// value can be a globally unique identifier, a fully specified ARN to either
	// an alias or a key, or an alias name prefixed by "alias/".You can also use
	// a master key owned by Kinesis Data Streams by specifying the alias aws/kinesis.
	//
	//    * Key ARN example: arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012
	//
	//    * Alias ARN example: arn:aws:kms:us-east-1:123456789012:alias/MyAliasName
	//
	//    * Globally unique key ID example: 12345678-1234-1234-1234-123456789012
	//
	//    * Alias name example: alias/MyAliasName
	//
	//    * Master key owned by Kinesis Data Streams: alias/aws/kinesis
	KeyID *string `json:"keyID,omitempty"`
	// The current retention period, in hours. Minimum value of 24. Maximum value
	// of 168.
	RetentionPeriodHours *int64 `json:"retentionPeriodHours,omitempty"`
	// The shards that comprise the stream.
	Shards []*Shard `json:"shards,omitempty"`
	// The Amazon Resource Name (ARN) for the stream being described.
	StreamARN *string `json:"streamARN,omitempty"`
	// The current status of the stream being described. The stream status is one
	// of the following states:
	//
	//    * CREATING - The stream is being created. Kinesis Data Streams immediately
	//    returns and sets StreamStatus to CREATING.
	//
	//    * DELETING - The stream is being deleted. The specified stream is in the
	//    DELETING state until Kinesis Data Streams completes the deletion.
	//
	//    * ACTIVE - The stream exists and is ready for read and write operations
	//    or deletion. You should perform read and write operations only on an ACTIVE
	//    stream.
	//
	//    * UPDATING - Shards in the stream are being merged or split. Read and
	//    write operations continue to work while the stream is in the UPDATING
	//    state.
	StreamStatus *string `json:"streamStatus,omitempty"`
}

// StreamStatus defines the observed state of Stream.
type StreamStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          StreamObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Stream is the Schema for the Streams API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type Stream struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              StreamSpec   `json:"spec"`
	Status            StreamStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// StreamList contains a list of Streams
type StreamList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Stream `json:"items"`
}

// Repository type metadata.
var (
	StreamKind             = "Stream"
	StreamGroupKind        = schema.GroupKind{Group: CRDGroup, Kind: StreamKind}.String()
	StreamKindAPIVersion   = StreamKind + "." + GroupVersion.String()
	StreamGroupVersionKind = GroupVersion.WithKind(StreamKind)
)

func init() {
	SchemeBuilder.Register(&Stream{}, &StreamList{})
}
