/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Hack to avoid import errors during build...
var (
	_ = &metav1.Time{}
)

// +kubebuilder:skipversion
type Action struct {
	Arguments map[string]*string `json:"arguments,omitempty"`

	CrawlerName *string `json:"crawlerName,omitempty"`

	JobName *string `json:"jobName,omitempty"`
	// Specifies configuration properties of a notification.
	NotificationProperty *NotificationProperty `json:"notificationProperty,omitempty"`

	SecurityConfiguration *string `json:"securityConfiguration,omitempty"`

	Timeout *int64 `json:"timeout,omitempty"`
}

// +kubebuilder:skipversion
type Aggregate struct {
	Aggs []*AggregateOperation `json:"aggs,omitempty"`

	Groups [][]*string `json:"groups,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type AggregateOperation struct {
	AggFunc *string `json:"aggFunc,omitempty"`

	Column []*string `json:"column,omitempty"`
}

// +kubebuilder:skipversion
type AmazonRedshiftAdvancedOption struct {
	Key *string `json:"key,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type AmazonRedshiftNodeData struct {
	AccessType *string `json:"accessType,omitempty"`

	Action *string `json:"action,omitempty"`

	AdvancedOptions []*AmazonRedshiftAdvancedOption `json:"advancedOptions,omitempty"`
	// Specifies an option value.
	CatalogDatabase *Option `json:"catalogDatabase,omitempty"`

	CatalogRedshiftSchema *string `json:"catalogRedshiftSchema,omitempty"`

	CatalogRedshiftTable *string `json:"catalogRedshiftTable,omitempty"`
	// Specifies an option value.
	CatalogTable *Option `json:"catalogTable,omitempty"`
	// Specifies an option value.
	Connection *Option `json:"connection,omitempty"`

	CrawlerConnection *string `json:"crawlerConnection,omitempty"`
	// Specifies an option value.
	IAMRole *Option `json:"iamRole,omitempty"`

	MergeAction *string `json:"mergeAction,omitempty"`

	MergeClause *string `json:"mergeClause,omitempty"`

	MergeWhenMatched *string `json:"mergeWhenMatched,omitempty"`

	MergeWhenNotMatched *string `json:"mergeWhenNotMatched,omitempty"`

	PostAction *string `json:"postAction,omitempty"`

	PreAction *string `json:"preAction,omitempty"`

	SampleQuery *string `json:"sampleQuery,omitempty"`
	// Specifies an option value.
	Schema *Option `json:"schema,omitempty"`

	SelectedColumns []*Option `json:"selectedColumns,omitempty"`

	SourceType *string `json:"sourceType,omitempty"`

	StagingTable *string `json:"stagingTable,omitempty"`
	// Specifies an option value.
	Table *Option `json:"table,omitempty"`

	TablePrefix *string `json:"tablePrefix,omitempty"`

	TableSchema []*Option `json:"tableSchema,omitempty"`

	TempDir *string `json:"tempDir,omitempty"`

	Upsert *bool `json:"upsert,omitempty"`
}

// +kubebuilder:skipversion
type AmazonRedshiftSource struct {
	// Specifies an Amazon Redshift node.
	Data *AmazonRedshiftNodeData `json:"data,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type AmazonRedshiftTarget struct {
	// Specifies an Amazon Redshift node.
	Data *AmazonRedshiftNodeData `json:"data,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type ApplyMapping struct {
	Inputs []*string `json:"inputs,omitempty"`

	Mapping []*Mapping `json:"mapping,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type AthenaConnectorSource struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	ConnectionTable *string `json:"connectionTable,omitempty"`

	ConnectionType *string `json:"connectionType,omitempty"`

	ConnectorName *string `json:"connectorName,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	SchemaName *string `json:"schemaName,omitempty"`
}

// +kubebuilder:skipversion
type AuditContext struct {
	AllColumnsRequested *bool `json:"allColumnsRequested,omitempty"`
}

// +kubebuilder:skipversion
type BasicCatalogTarget struct {
	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type BatchStopJobRunError struct {
	JobName *string `json:"jobName,omitempty"`
}

// +kubebuilder:skipversion
type BatchStopJobRunSuccessfulSubmission struct {
	JobName *string `json:"jobName,omitempty"`
}

// +kubebuilder:skipversion
type Blueprint struct {
	BlueprintLocation *string `json:"blueprintLocation,omitempty"`

	BlueprintServiceLocation *string `json:"blueprintServiceLocation,omitempty"`

	CreatedOn *metav1.Time `json:"createdOn,omitempty"`

	Description *string `json:"description,omitempty"`

	LastModifiedOn *metav1.Time `json:"lastModifiedOn,omitempty"`
}

// +kubebuilder:skipversion
type BlueprintRun struct {
	CompletedOn *metav1.Time `json:"completedOn,omitempty"`

	StartedOn *metav1.Time `json:"startedOn,omitempty"`

	WorkflowName *string `json:"workflowName,omitempty"`
}

// +kubebuilder:skipversion
type CatalogDeltaSource struct {
	AdditionalDeltaOptions map[string]*string `json:"additionalDeltaOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type CatalogEntry struct {
	DatabaseName *string `json:"databaseName,omitempty"`

	TableName *string `json:"tableName,omitempty"`
}

// +kubebuilder:skipversion
type CatalogHudiSource struct {
	AdditionalHudiOptions map[string]*string `json:"additionalHudiOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type CatalogImportStatus struct {
	ImportCompleted *bool `json:"importCompleted,omitempty"`

	ImportTime *metav1.Time `json:"importTime,omitempty"`

	ImportedBy *string `json:"importedBy,omitempty"`
}

// +kubebuilder:skipversion
type CatalogKafkaSource struct {
	// Specifies options related to data preview for viewing a sample of your data.
	DataPreviewOptions *StreamingDataPreviewOptions `json:"dataPreviewOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	DetectSchema *bool `json:"detectSchema,omitempty"`

	Name *string `json:"name,omitempty"`
	// Additional options for streaming.
	StreamingOptions *KafkaStreamingSourceOptions `json:"streamingOptions,omitempty"`

	Table *string `json:"table,omitempty"`

	WindowSize *int64 `json:"windowSize,omitempty"`
}

// +kubebuilder:skipversion
type CatalogKinesisSource struct {
	// Specifies options related to data preview for viewing a sample of your data.
	DataPreviewOptions *StreamingDataPreviewOptions `json:"dataPreviewOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	DetectSchema *bool `json:"detectSchema,omitempty"`

	Name *string `json:"name,omitempty"`
	// Additional options for the Amazon Kinesis streaming data source.
	StreamingOptions *KinesisStreamingSourceOptions `json:"streamingOptions,omitempty"`

	Table *string `json:"table,omitempty"`

	WindowSize *int64 `json:"windowSize,omitempty"`
}

// +kubebuilder:skipversion
type CatalogSchemaChangePolicy struct {
	EnableUpdateCatalog *bool `json:"enableUpdateCatalog,omitempty"`

	UpdateBehavior *string `json:"updateBehavior,omitempty"`
}

// +kubebuilder:skipversion
type CatalogSource struct {
	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type CatalogTarget struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`

	DlqEventQueueARN *string `json:"dlqEventQueueARN,omitempty"`

	EventQueueARN *string `json:"eventQueueARN,omitempty"`

	Tables []*string `json:"tables,omitempty"`
}

// +kubebuilder:skipversion
type Classifier_SDK struct {
	// A classifier for custom CSV content.
	CsvClassifier *CsvClassifier `json:"csvClassifier,omitempty"`
	// A classifier that uses grok patterns.
	GrokClassifier *GrokClassifier `json:"grokClassifier,omitempty"`
	// A classifier for JSON content.
	JSONClassifier *JSONClassifier `json:"jsonClassifier,omitempty"`
	// A classifier for XML content.
	XMLClassifier *XMLClassifier `json:"xmlClassifier,omitempty"`
}

// +kubebuilder:skipversion
type CloudWatchEncryption struct {
	CloudWatchEncryptionMode *string `json:"cloudWatchEncryptionMode,omitempty"`

	KMSKeyARN *string `json:"kmsKeyARN,omitempty"`
}

// +kubebuilder:skipversion
type CodeGenConfigurationNode struct {
	// Specifies a transform that groups rows by chosen fields and computes the
	// aggregated value by specified function.
	Aggregate *Aggregate `json:"aggregate,omitempty"`
	// Specifies an Amazon Redshift source.
	AmazonRedshiftSource *AmazonRedshiftSource `json:"amazonRedshiftSource,omitempty"`
	// Specifies an Amazon Redshift target.
	AmazonRedshiftTarget *AmazonRedshiftTarget `json:"amazonRedshiftTarget,omitempty"`
	// Specifies a transform that maps data property keys in the data source to
	// data property keys in the data target. You can rename keys, modify the data
	// types for keys, and choose which keys to drop from the dataset.
	ApplyMapping *ApplyMapping `json:"applyMapping,omitempty"`
	// Specifies a connector to an Amazon Athena data source.
	AthenaConnectorSource *AthenaConnectorSource `json:"athenaConnectorSource,omitempty"`
	// Specifies a Delta Lake data source that is registered in the Glue Data Catalog.
	CatalogDeltaSource *CatalogDeltaSource `json:"catalogDeltaSource,omitempty"`
	// Specifies a Hudi data source that is registered in the Glue Data Catalog.
	CatalogHudiSource *CatalogHudiSource `json:"catalogHudiSource,omitempty"`
	// Specifies an Apache Kafka data store in the Data Catalog.
	CatalogKafkaSource *CatalogKafkaSource `json:"catalogKafkaSource,omitempty"`
	// Specifies a Kinesis data source in the Glue Data Catalog.
	CatalogKinesisSource *CatalogKinesisSource `json:"catalogKinesisSource,omitempty"`
	// Specifies a data store in the Glue Data Catalog.
	CatalogSource *CatalogSource `json:"catalogSource,omitempty"`
	// Specifies a target that uses a Glue Data Catalog table.
	CatalogTarget *BasicCatalogTarget `json:"catalogTarget,omitempty"`
	// Specifies a transform that uses custom code you provide to perform the data
	// transformation. The output is a collection of DynamicFrames.
	CustomCode *CustomCode `json:"customCode,omitempty"`
	// Specifies the direct JDBC source connection.
	DirectJDBCSource *DirectJDBCSource `json:"directJDBCSource,omitempty"`
	// Specifies an Apache Kafka data store.
	DirectKafkaSource *DirectKafkaSource `json:"directKafkaSource,omitempty"`
	// Specifies a direct Amazon Kinesis data source.
	DirectKinesisSource *DirectKinesisSource `json:"directKinesisSource,omitempty"`
	// Specifies a transform that removes rows of repeating data from a data set.
	DropDuplicates *DropDuplicates `json:"dropDuplicates,omitempty"`
	// Specifies a transform that chooses the data property keys that you want to
	// drop.
	DropFields *DropFields `json:"dropFields,omitempty"`
	// Specifies a transform that removes columns from the dataset if all values
	// in the column are 'null'. By default, Glue Studio will recognize null objects,
	// but some values such as empty strings, strings that are "null", -1 integers
	// or other placeholders such as zeros, are not automatically recognized as
	// nulls.
	DropNullFields *DropNullFields `json:"dropNullFields,omitempty"`
	// Specifies the set of parameters needed to perform the dynamic transform.
	DynamicTransform *DynamicTransform `json:"dynamicTransform,omitempty"`
	// Specifies a DynamoDB data source in the Glue Data Catalog.
	DynamoDBCatalogSource *DynamoDBCatalogSource `json:"dynamoDBCatalogSource,omitempty"`
	// Specifies your data quality evaluation criteria.
	EvaluateDataQuality *EvaluateDataQuality `json:"evaluateDataQuality,omitempty"`
	// Specifies your data quality evaluation criteria.
	EvaluateDataQualityMultiFrame *EvaluateDataQualityMultiFrame `json:"evaluateDataQualityMultiFrame,omitempty"`
	// Specifies a transform that locates records in the dataset that have missing
	// values and adds a new field with a value determined by imputation. The input
	// data set is used to train the machine learning model that determines what
	// the missing value should be.
	FillMissingValues *FillMissingValues `json:"fillMissingValues,omitempty"`
	// Specifies a transform that splits a dataset into two, based on a filter condition.
	Filter *Filter `json:"filter,omitempty"`
	// Specifies the data store in the governed Glue Data Catalog.
	GovernedCatalogSource *GovernedCatalogSource `json:"governedCatalogSource,omitempty"`
	// Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
	GovernedCatalogTarget *GovernedCatalogTarget `json:"governedCatalogTarget,omitempty"`
	// Specifies a connector to a JDBC data source.
	JDBCConnectorSource *JDBCConnectorSource `json:"jDBCConnectorSource,omitempty"`
	// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar
	// storage.
	JDBCConnectorTarget *JDBCConnectorTarget `json:"jDBCConnectorTarget,omitempty"`
	// Specifies a transform that joins two datasets into one dataset using a comparison
	// phrase on the specified data property keys. You can use inner, outer, left,
	// right, left semi, and left anti joins.
	Join *Join `json:"join,omitempty"`
	// Specifies a transform that merges a DynamicFrame with a staging DynamicFrame
	// based on the specified primary keys to identify records. Duplicate records
	// (records with the same primary keys) are not de-duplicated.
	Merge *Merge `json:"merge,omitempty"`
	// Specifies a Microsoft SQL server data source in the Glue Data Catalog.
	MicrosoftSQLServerCatalogSource *MicrosoftSQLServerCatalogSource `json:"microsoftSQLServerCatalogSource,omitempty"`
	// Specifies a target that uses Microsoft SQL.
	MicrosoftSQLServerCatalogTarget *MicrosoftSQLServerCatalogTarget `json:"microsoftSQLServerCatalogTarget,omitempty"`
	// Specifies a MySQL data source in the Glue Data Catalog.
	MySQLCatalogSource *MySQLCatalogSource `json:"mySQLCatalogSource,omitempty"`
	// Specifies a target that uses MySQL.
	MySQLCatalogTarget *MySQLCatalogTarget `json:"mySQLCatalogTarget,omitempty"`
	// Specifies an Oracle data source in the Glue Data Catalog.
	OracleSQLCatalogSource *OracleSQLCatalogSource `json:"oracleSQLCatalogSource,omitempty"`
	// Specifies a target that uses Oracle SQL.
	OracleSQLCatalogTarget *OracleSQLCatalogTarget `json:"oracleSQLCatalogTarget,omitempty"`
	// Specifies a transform that identifies, removes or masks PII data.
	PIIDetection *PIIDetection `json:"pIIDetection,omitempty"`
	// Specifies a PostgresSQL data source in the Glue Data Catalog.
	PostgreSQLCatalogSource *PostgreSQLCatalogSource `json:"postgreSQLCatalogSource,omitempty"`
	// Specifies a target that uses Postgres SQL.
	PostgreSQLCatalogTarget *PostgreSQLCatalogTarget `json:"postgreSQLCatalogTarget,omitempty"`
	// Specifies an Amazon Redshift data store.
	RedshiftSource *RedshiftSource `json:"redshiftSource,omitempty"`
	// Specifies a target that uses Amazon Redshift.
	RedshiftTarget *RedshiftTarget `json:"redshiftTarget,omitempty"`
	// Specifies a Relational database data source in the Glue Data Catalog.
	RelationalCatalogSource *RelationalCatalogSource `json:"relationalCatalogSource,omitempty"`
	// Specifies a transform that renames a single data property key.
	RenameField *RenameField `json:"renameField,omitempty"`
	// Specifies a Delta Lake data source that is registered in the Glue Data Catalog.
	// The data source must be stored in Amazon S3.
	S3CatalogDeltaSource *S3CatalogDeltaSource `json:"s3CatalogDeltaSource,omitempty"`
	// Specifies a Hudi data source that is registered in the Glue Data Catalog.
	// The Hudi data source must be stored in Amazon S3.
	S3CatalogHudiSource *S3CatalogHudiSource `json:"s3CatalogHudiSource,omitempty"`
	// Specifies an Amazon S3 data store in the Glue Data Catalog.
	S3CatalogSource *S3CatalogSource `json:"s3CatalogSource,omitempty"`
	// Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
	S3CatalogTarget *S3CatalogTarget `json:"s3CatalogTarget,omitempty"`
	// Specifies a command-separated value (CSV) data store stored in Amazon S3.
	S3CsvSource *S3CsvSource `json:"s3CsvSource,omitempty"`
	// Specifies a target that writes to a Delta Lake data source in the Glue Data
	// Catalog.
	S3DeltaCatalogTarget *S3DeltaCatalogTarget `json:"s3DeltaCatalogTarget,omitempty"`
	// Specifies a target that writes to a Delta Lake data source in Amazon S3.
	S3DeltaDirectTarget *S3DeltaDirectTarget `json:"s3DeltaDirectTarget,omitempty"`
	// Specifies a Delta Lake data source stored in Amazon S3.
	S3DeltaSource *S3DeltaSource `json:"s3DeltaSource,omitempty"`
	// Specifies a data target that writes to Amazon S3.
	S3DirectTarget *S3DirectTarget `json:"s3DirectTarget,omitempty"`
	// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar
	// storage.
	S3GlueParquetTarget *S3GlueParquetTarget `json:"s3GlueParquetTarget,omitempty"`
	// Specifies a target that writes to a Hudi data source in the Glue Data Catalog.
	S3HudiCatalogTarget *S3HudiCatalogTarget `json:"s3HudiCatalogTarget,omitempty"`
	// Specifies a target that writes to a Hudi data source in Amazon S3.
	S3HudiDirectTarget *S3HudiDirectTarget `json:"s3HudiDirectTarget,omitempty"`
	// Specifies a Hudi data source stored in Amazon S3.
	S3HudiSource *S3HudiSource `json:"s3HudiSource,omitempty"`
	// Specifies a JSON data store stored in Amazon S3.
	S3JSONSource *S3JSONSource `json:"s3JSONSource,omitempty"`
	// Specifies an Apache Parquet data store stored in Amazon S3.
	S3ParquetSource *S3ParquetSource `json:"s3ParquetSource,omitempty"`
	// Specifies a transform that chooses the data property keys that you want to
	// keep.
	SelectFields *SelectFields `json:"selectFields,omitempty"`
	// Specifies a transform that chooses one DynamicFrame from a collection of
	// DynamicFrames. The output is the selected DynamicFrame
	SelectFromCollection *SelectFromCollection `json:"selectFromCollection,omitempty"`
	// Specifies a connector to an Apache Spark data source.
	SparkConnectorSource *SparkConnectorSource `json:"sparkConnectorSource,omitempty"`
	// Specifies a target that uses an Apache Spark connector.
	SparkConnectorTarget *SparkConnectorTarget `json:"sparkConnectorTarget,omitempty"`
	// Specifies a transform where you enter a SQL query using Spark SQL syntax
	// to transform the data. The output is a single DynamicFrame.
	SparkSQL *SparkSQL `json:"sparkSQL,omitempty"`
	// Specifies a transform that writes samples of the data to an Amazon S3 bucket.
	Spigot *Spigot `json:"spigot,omitempty"`
	// Specifies a transform that splits data property keys into two DynamicFrames.
	// The output is a collection of DynamicFrames: one with selected data property
	// keys, and one with the remaining data property keys.
	SplitFields *SplitFields `json:"splitFields,omitempty"`
	// Specifies a transform that combines the rows from two or more datasets into
	// a single result.
	Union *Union `json:"union,omitempty"`
}

// +kubebuilder:skipversion
type CodeGenNodeArg struct {
	Param *bool `json:"param,omitempty"`
}

// +kubebuilder:skipversion
type Column struct {
	Name *string `json:"name,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`

	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type ColumnError struct {
	ColumnName *string `json:"columnName,omitempty"`
}

// +kubebuilder:skipversion
type ColumnImportance struct {
	ColumnName *string `json:"columnName,omitempty"`
}

// +kubebuilder:skipversion
type ColumnRowFilter struct {
	ColumnName *string `json:"columnName,omitempty"`
}

// +kubebuilder:skipversion
type ColumnStatistics struct {
	AnalyzedTime *metav1.Time `json:"analyzedTime,omitempty"`

	ColumnName *string `json:"columnName,omitempty"`
}

// +kubebuilder:skipversion
type Condition struct {
	CrawlerName *string `json:"crawlerName,omitempty"`

	JobName *string `json:"jobName,omitempty"`
}

// +kubebuilder:skipversion
type ConnectionInput struct {
	ConnectionProperties map[string]*string `json:"connectionProperties,omitempty"`

	ConnectionType *string `json:"connectionType,omitempty"`

	Description *string `json:"description,omitempty"`

	MatchCriteria []*string `json:"matchCriteria,omitempty"`

	Name *string `json:"name,omitempty"`
	// Specifies the physical requirements for a connection.
	PhysicalConnectionRequirements *PhysicalConnectionRequirements `json:"physicalConnectionRequirements,omitempty"`
}

// +kubebuilder:skipversion
type ConnectionPasswordEncryption struct {
	AWSKMSKeyID *string `json:"awsKMSKeyID,omitempty"`

	ReturnConnectionPasswordEncrypted *bool `json:"returnConnectionPasswordEncrypted,omitempty"`
}

// +kubebuilder:skipversion
type Connection_SDK struct {
	ConnectionProperties map[string]*string `json:"connectionProperties,omitempty"`

	ConnectionType *string `json:"connectionType,omitempty"`

	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	Description *string `json:"description,omitempty"`

	LastUpdatedBy *string `json:"lastUpdatedBy,omitempty"`

	LastUpdatedTime *metav1.Time `json:"lastUpdatedTime,omitempty"`

	MatchCriteria []*string `json:"matchCriteria,omitempty"`

	Name *string `json:"name,omitempty"`
	// Specifies the physical requirements for a connection.
	PhysicalConnectionRequirements *PhysicalConnectionRequirements `json:"physicalConnectionRequirements,omitempty"`
}

// +kubebuilder:skipversion
type ConnectionsList struct {
	Connections []*string `json:"connections,omitempty"`
}

// +kubebuilder:skipversion
type Crawl struct {
	CompletedOn *metav1.Time `json:"completedOn,omitempty"`

	ErrorMessage *string `json:"errorMessage,omitempty"`

	LogGroup *string `json:"logGroup,omitempty"`

	LogStream *string `json:"logStream,omitempty"`

	StartedOn *metav1.Time `json:"startedOn,omitempty"`
}

// +kubebuilder:skipversion
type CrawlerHistory struct {
	EndTime *metav1.Time `json:"endTime,omitempty"`

	ErrorMessage *string `json:"errorMessage,omitempty"`

	LogGroup *string `json:"logGroup,omitempty"`

	LogStream *string `json:"logStream,omitempty"`

	MessagePrefix *string `json:"messagePrefix,omitempty"`

	StartTime *metav1.Time `json:"startTime,omitempty"`

	Summary *string `json:"summary,omitempty"`
}

// +kubebuilder:skipversion
type CrawlerMetrics struct {
	CrawlerName *string `json:"crawlerName,omitempty"`

	StillEstimating *bool `json:"stillEstimating,omitempty"`
}

// +kubebuilder:skipversion
type CrawlerTargets struct {
	CatalogTargets []*CatalogTarget `json:"catalogTargets,omitempty"`

	DeltaTargets []*DeltaTarget `json:"deltaTargets,omitempty"`

	DynamoDBTargets []*DynamoDBTarget `json:"dynamoDBTargets,omitempty"`

	JdbcTargets []*JdbcTarget `json:"jdbcTargets,omitempty"`

	MongoDBTargets []*MongoDBTarget `json:"mongoDBTargets,omitempty"`

	S3Targets []*S3Target `json:"s3Targets,omitempty"`
}

// +kubebuilder:skipversion
type Crawler_SDK struct {
	Classifiers []*string `json:"classifiers,omitempty"`

	Configuration *string `json:"configuration,omitempty"`

	CrawlElapsedTime *int64 `json:"crawlElapsedTime,omitempty"`

	CrawlerSecurityConfiguration *string `json:"crawlerSecurityConfiguration,omitempty"`

	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`

	Description *string `json:"description,omitempty"`
	// Specifies Lake Formation configuration settings for the crawler.
	LakeFormationConfiguration *LakeFormationConfiguration `json:"lakeFormationConfiguration,omitempty"`
	// Status and error information about the most recent crawl.
	LastCrawl *LastCrawlInfo `json:"lastCrawl,omitempty"`

	LastUpdated *metav1.Time `json:"lastUpdated,omitempty"`
	// Specifies data lineage configuration settings for the crawler.
	LineageConfiguration *LineageConfiguration `json:"lineageConfiguration,omitempty"`

	Name *string `json:"name,omitempty"`
	// When crawling an Amazon S3 data source after the first crawl is complete,
	// specifies whether to crawl the entire dataset again or to crawl only folders
	// that were added since the last crawler run. For more information, see Incremental
	// Crawls in Glue (https://docs.aws.amazon.com/glue/latest/dg/incremental-crawls.html)
	// in the developer guide.
	RecrawlPolicy *RecrawlPolicy `json:"recrawlPolicy,omitempty"`

	Role *string `json:"role,omitempty"`
	// A scheduling object using a cron statement to schedule an event.
	Schedule *Schedule `json:"schedule,omitempty"`
	// A policy that specifies update and deletion behaviors for the crawler.
	SchemaChangePolicy *SchemaChangePolicy `json:"schemaChangePolicy,omitempty"`

	State *string `json:"state,omitempty"`

	TablePrefix *string `json:"tablePrefix,omitempty"`
	// Specifies data stores to crawl.
	Targets *CrawlerTargets `json:"targets,omitempty"`

	Version *int64 `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type CrawlsFilter struct {
	FieldValue *string `json:"fieldValue,omitempty"`
}

// +kubebuilder:skipversion
type CreateCsvClassifierRequest struct {
	AllowSingleColumn *bool `json:"allowSingleColumn,omitempty"`

	ContainsHeader *string `json:"containsHeader,omitempty"`

	CustomDatatypeConfigured *bool `json:"customDatatypeConfigured,omitempty"`

	CustomDatatypes []*string `json:"customDatatypes,omitempty"`

	Delimiter *string `json:"delimiter,omitempty"`

	DisableValueTrimming *bool `json:"disableValueTrimming,omitempty"`

	Header []*string `json:"header,omitempty"`

	Name *string `json:"name,omitempty"`

	QuoteSymbol *string `json:"quoteSymbol,omitempty"`
}

// +kubebuilder:skipversion
type CreateGrokClassifierRequest struct {
	Classification *string `json:"classification,omitempty"`

	CustomPatterns *string `json:"customPatterns,omitempty"`

	GrokPattern *string `json:"grokPattern,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type CreateJSONClassifierRequest struct {
	JSONPath *string `json:"jsonPath,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type CreateXMLClassifierRequest struct {
	Classification *string `json:"classification,omitempty"`

	Name *string `json:"name,omitempty"`

	RowTag *string `json:"rowTag,omitempty"`
}

// +kubebuilder:skipversion
type CsvClassifier struct {
	AllowSingleColumn *bool `json:"allowSingleColumn,omitempty"`

	ContainsHeader *string `json:"containsHeader,omitempty"`

	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	CustomDatatypeConfigured *bool `json:"customDatatypeConfigured,omitempty"`

	CustomDatatypes []*string `json:"customDatatypes,omitempty"`

	Delimiter *string `json:"delimiter,omitempty"`

	DisableValueTrimming *bool `json:"disableValueTrimming,omitempty"`

	Header []*string `json:"header,omitempty"`

	LastUpdated *metav1.Time `json:"lastUpdated,omitempty"`

	Name *string `json:"name,omitempty"`

	QuoteSymbol *string `json:"quoteSymbol,omitempty"`

	Version *int64 `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type CustomCode struct {
	ClassName *string `json:"className,omitempty"`

	Code *string `json:"code,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`
}

// +kubebuilder:skipversion
type CustomEntityType struct {
	Name *string `json:"name,omitempty"`

	RegexString *string `json:"regexString,omitempty"`
}

// +kubebuilder:skipversion
type DQResultsPublishingOptions struct {
	CloudWatchMetricsEnabled *bool `json:"cloudWatchMetricsEnabled,omitempty"`

	EvaluationContext *string `json:"evaluationContext,omitempty"`

	ResultsPublishingEnabled *bool `json:"resultsPublishingEnabled,omitempty"`

	ResultsS3Prefix *string `json:"resultsS3Prefix,omitempty"`
}

// +kubebuilder:skipversion
type DQStopJobOnFailureOptions struct {
	StopJobOnFailureTiming *string `json:"stopJobOnFailureTiming,omitempty"`
}

// +kubebuilder:skipversion
type DataLakePrincipal struct {
	DataLakePrincipalIdentifier *string `json:"dataLakePrincipalIdentifier,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityEvaluationRunAdditionalRunOptions struct {
	CloudWatchMetricsEnabled *bool `json:"cloudWatchMetricsEnabled,omitempty"`

	ResultsS3Prefix *string `json:"resultsS3Prefix,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityResult struct {
	CompletedOn *metav1.Time `json:"completedOn,omitempty"`

	EvaluationContext *string `json:"evaluationContext,omitempty"`

	JobName *string `json:"jobName,omitempty"`

	RulesetName *string `json:"rulesetName,omitempty"`

	StartedOn *metav1.Time `json:"startedOn,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityResultDescription struct {
	JobName *string `json:"jobName,omitempty"`

	StartedOn *metav1.Time `json:"startedOn,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityResultFilterCriteria struct {
	JobName *string `json:"jobName,omitempty"`

	StartedAfter *metav1.Time `json:"startedAfter,omitempty"`

	StartedBefore *metav1.Time `json:"startedBefore,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityRuleRecommendationRunDescription struct {
	StartedOn *metav1.Time `json:"startedOn,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityRuleRecommendationRunFilter struct {
	StartedAfter *metav1.Time `json:"startedAfter,omitempty"`

	StartedBefore *metav1.Time `json:"startedBefore,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityRuleResult struct {
	Description *string `json:"description,omitempty"`

	EvaluationMessage *string `json:"evaluationMessage,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityRulesetEvaluationRunDescription struct {
	StartedOn *metav1.Time `json:"startedOn,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityRulesetEvaluationRunFilter struct {
	StartedAfter *metav1.Time `json:"startedAfter,omitempty"`

	StartedBefore *metav1.Time `json:"startedBefore,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityRulesetFilterCriteria struct {
	CreatedAfter *metav1.Time `json:"createdAfter,omitempty"`

	CreatedBefore *metav1.Time `json:"createdBefore,omitempty"`

	Description *string `json:"description,omitempty"`

	LastModifiedAfter *metav1.Time `json:"lastModifiedAfter,omitempty"`

	LastModifiedBefore *metav1.Time `json:"lastModifiedBefore,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityRulesetListDetails struct {
	CreatedOn *metav1.Time `json:"createdOn,omitempty"`

	Description *string `json:"description,omitempty"`

	LastModifiedOn *metav1.Time `json:"lastModifiedOn,omitempty"`

	Name *string `json:"name,omitempty"`

	RuleCount *int64 `json:"ruleCount,omitempty"`
}

// +kubebuilder:skipversion
type DataQualityTargetTable struct {
	CatalogID *string `json:"catalogID,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`

	TableName *string `json:"tableName,omitempty"`
}

// +kubebuilder:skipversion
type DatabaseIdentifier struct {
	CatalogID *string `json:"catalogID,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`
}

// +kubebuilder:skipversion
type DatabaseInput struct {
	CreateTableDefaultPermissions []*PrincipalPermissions `json:"createTableDefaultPermissions,omitempty"`

	Description *string `json:"description,omitempty"`
	// A database that points to an entity outside the Glue Data Catalog.
	FederatedDatabase *FederatedDatabase `json:"federatedDatabase,omitempty"`

	LocationURI *string `json:"locationURI,omitempty"`

	Name *string `json:"name,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`
	// A structure that describes a target database for resource linking.
	TargetDatabase *DatabaseIdentifier `json:"targetDatabase,omitempty"`
}

// +kubebuilder:skipversion
type Database_SDK struct {
	CatalogID *string `json:"catalogID,omitempty"`

	CreateTableDefaultPermissions []*PrincipalPermissions `json:"createTableDefaultPermissions,omitempty"`

	CreateTime *metav1.Time `json:"createTime,omitempty"`

	Description *string `json:"description,omitempty"`
	// A database that points to an entity outside the Glue Data Catalog.
	FederatedDatabase *FederatedDatabase `json:"federatedDatabase,omitempty"`

	LocationURI *string `json:"locationURI,omitempty"`

	Name *string `json:"name,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`
	// A structure that describes a target database for resource linking.
	TargetDatabase *DatabaseIdentifier `json:"targetDatabase,omitempty"`
}

// +kubebuilder:skipversion
type Datatype struct {
	ID *string `json:"id,omitempty"`

	Label *string `json:"label,omitempty"`
}

// +kubebuilder:skipversion
type DateColumnStatisticsData struct {
	MaximumValue *metav1.Time `json:"maximumValue,omitempty"`

	MinimumValue *metav1.Time `json:"minimumValue,omitempty"`
}

// +kubebuilder:skipversion
type DeltaTarget struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	CreateNativeDeltaTable *bool `json:"createNativeDeltaTable,omitempty"`

	DeltaTables []*string `json:"deltaTables,omitempty"`

	WriteManifest *bool `json:"writeManifest,omitempty"`
}

// +kubebuilder:skipversion
type DevEndpoint struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	CreatedTimestamp *metav1.Time `json:"createdTimestamp,omitempty"`

	EndpointName *string `json:"endpointName,omitempty"`

	ExtraJarsS3Path *string `json:"extraJarsS3Path,omitempty"`

	ExtraPythonLibsS3Path *string `json:"extraPythonLibsS3Path,omitempty"`

	FailureReason *string `json:"failureReason,omitempty"`

	GlueVersion *string `json:"glueVersion,omitempty"`

	LastModifiedTimestamp *metav1.Time `json:"lastModifiedTimestamp,omitempty"`

	LastUpdateStatus *string `json:"lastUpdateStatus,omitempty"`

	NumberOfNodes *int64 `json:"numberOfNodes,omitempty"`

	NumberOfWorkers *int64 `json:"numberOfWorkers,omitempty"`

	PrivateAddress *string `json:"privateAddress,omitempty"`

	PublicAddress *string `json:"publicAddress,omitempty"`

	PublicKey *string `json:"publicKey,omitempty"`

	SecurityConfiguration *string `json:"securityConfiguration,omitempty"`

	Status *string `json:"status,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`

	VPCID *string `json:"vpcID,omitempty"`

	WorkerType *string `json:"workerType,omitempty"`

	YarnEndpointAddress *string `json:"yarnEndpointAddress,omitempty"`

	ZeppelinRemoteSparkInterpreterPort *int64 `json:"zeppelinRemoteSparkInterpreterPort,omitempty"`
}

// +kubebuilder:skipversion
type DevEndpointCustomLibraries struct {
	ExtraJarsS3Path *string `json:"extraJarsS3Path,omitempty"`

	ExtraPythonLibsS3Path *string `json:"extraPythonLibsS3Path,omitempty"`
}

// +kubebuilder:skipversion
type DirectJDBCSource struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	ConnectionType *string `json:"connectionType,omitempty"`

	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	RedshiftTmpDir *string `json:"redshiftTmpDir,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type DirectKafkaSource struct {
	// Specifies options related to data preview for viewing a sample of your data.
	DataPreviewOptions *StreamingDataPreviewOptions `json:"dataPreviewOptions,omitempty"`

	DetectSchema *bool `json:"detectSchema,omitempty"`

	Name *string `json:"name,omitempty"`
	// Additional options for streaming.
	StreamingOptions *KafkaStreamingSourceOptions `json:"streamingOptions,omitempty"`

	WindowSize *int64 `json:"windowSize,omitempty"`
}

// +kubebuilder:skipversion
type DirectKinesisSource struct {
	// Specifies options related to data preview for viewing a sample of your data.
	DataPreviewOptions *StreamingDataPreviewOptions `json:"dataPreviewOptions,omitempty"`

	DetectSchema *bool `json:"detectSchema,omitempty"`

	Name *string `json:"name,omitempty"`
	// Additional options for the Amazon Kinesis streaming data source.
	StreamingOptions *KinesisStreamingSourceOptions `json:"streamingOptions,omitempty"`

	WindowSize *int64 `json:"windowSize,omitempty"`
}

// +kubebuilder:skipversion
type DirectSchemaChangePolicy struct {
	Database *string `json:"database,omitempty"`

	EnableUpdateCatalog *bool `json:"enableUpdateCatalog,omitempty"`

	Table *string `json:"table,omitempty"`

	UpdateBehavior *string `json:"updateBehavior,omitempty"`
}

// +kubebuilder:skipversion
type DropDuplicates struct {
	Columns [][]*string `json:"columns,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type DropFields struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Paths [][]*string `json:"paths,omitempty"`
}

// +kubebuilder:skipversion
type DropNullFields struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`
	// Represents whether certain values are recognized as null values for removal.
	NullCheckBoxList *NullCheckBoxList `json:"nullCheckBoxList,omitempty"`

	NullTextList []*NullValueField `json:"nullTextList,omitempty"`
}

// +kubebuilder:skipversion
type DynamicTransform struct {
	FunctionName *string `json:"functionName,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Parameters []*TransformConfigParameter `json:"parameters,omitempty"`

	Path *string `json:"path,omitempty"`

	TransformName *string `json:"transformName,omitempty"`

	Version *string `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type DynamoDBCatalogSource struct {
	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type DynamoDBTarget struct {
	Path *string `json:"path,omitempty"`

	ScanAll *bool `json:"scanAll,omitempty"`

	ScanRate *float64 `json:"scanRate,omitempty"`
}

// +kubebuilder:skipversion
type Edge struct {
	DestinationID *string `json:"destinationID,omitempty"`

	SourceID *string `json:"sourceID,omitempty"`
}

// +kubebuilder:skipversion
type EncryptionAtRest struct {
	SSEAWSKMSKeyID *string `json:"sseAWSKMSKeyID,omitempty"`
}

// +kubebuilder:skipversion
type EncryptionConfiguration struct {
	// Specifies how Amazon CloudWatch data should be encrypted.
	CloudWatchEncryption *CloudWatchEncryption `json:"cloudWatchEncryption,omitempty"`
	// Specifies how job bookmark data should be encrypted.
	JobBookmarksEncryption *JobBookmarksEncryption `json:"jobBookmarksEncryption,omitempty"`

	S3Encryption []*S3Encryption `json:"s3Encryption,omitempty"`
}

// +kubebuilder:skipversion
type ErrorDetail struct {
	ErrorCode *string `json:"errorCode,omitempty"`

	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// +kubebuilder:skipversion
type EvaluateDataQuality struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Output *string `json:"output,omitempty"`
	// Options to configure how your data quality evaluation results are published.
	PublishingOptions *DQResultsPublishingOptions `json:"publishingOptions,omitempty"`

	Ruleset *string `json:"ruleset,omitempty"`
	// Options to configure how your job will stop if your data quality evaluation
	// fails.
	StopJobOnFailureOptions *DQStopJobOnFailureOptions `json:"stopJobOnFailureOptions,omitempty"`
}

// +kubebuilder:skipversion
type EvaluateDataQualityMultiFrame struct {
	AdditionalDataSources map[string]*string `json:"additionalDataSources,omitempty"`

	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`
	// Options to configure how your data quality evaluation results are published.
	PublishingOptions *DQResultsPublishingOptions `json:"publishingOptions,omitempty"`

	Ruleset *string `json:"ruleset,omitempty"`
	// Options to configure how your job will stop if your data quality evaluation
	// fails.
	StopJobOnFailureOptions *DQStopJobOnFailureOptions `json:"stopJobOnFailureOptions,omitempty"`
}

// +kubebuilder:skipversion
type ExecutionProperty struct {
	MaxConcurrentRuns *int64 `json:"maxConcurrentRuns,omitempty"`
}

// +kubebuilder:skipversion
type ExportLabelsTaskRunProperties struct {
	OutputS3Path *string `json:"outputS3Path,omitempty"`
}

// +kubebuilder:skipversion
type FederatedDatabase struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	Identifier *string `json:"identifier,omitempty"`
}

// +kubebuilder:skipversion
type FederatedTable struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	DatabaseIdentifier *string `json:"databaseIdentifier,omitempty"`

	Identifier *string `json:"identifier,omitempty"`
}

// +kubebuilder:skipversion
type FillMissingValues struct {
	FilledPath *string `json:"filledPath,omitempty"`

	ImputedPath *string `json:"imputedPath,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type Filter struct {
	Filters []*FilterExpression `json:"filters,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	LogicalOperator *string `json:"logicalOperator,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type FilterExpression struct {
	Negated *bool `json:"negated,omitempty"`

	Operation *string `json:"operation,omitempty"`

	Values []*FilterValue `json:"values,omitempty"`
}

// +kubebuilder:skipversion
type FilterValue struct {
	Type *string `json:"type_,omitempty"`

	Value []*string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type FindMatchesParameters struct {
	EnforceProvidedLabels *bool `json:"enforceProvidedLabels,omitempty"`
}

// +kubebuilder:skipversion
type FindMatchesTaskRunProperties struct {
	JobName *string `json:"jobName,omitempty"`
}

// +kubebuilder:skipversion
type GetConnectionsFilter struct {
	ConnectionType *string `json:"connectionType,omitempty"`

	MatchCriteria []*string `json:"matchCriteria,omitempty"`
}

// +kubebuilder:skipversion
type GluePolicy struct {
	CreateTime *metav1.Time `json:"createTime,omitempty"`

	UpdateTime *metav1.Time `json:"updateTime,omitempty"`
}

// +kubebuilder:skipversion
type GlueSchema struct {
	Columns []*GlueStudioSchemaColumn `json:"columns,omitempty"`
}

// +kubebuilder:skipversion
type GlueStudioSchemaColumn struct {
	Name *string `json:"name,omitempty"`

	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type GovernedCatalogSource struct {
	// Specifies additional connection options for the Amazon S3 data store.
	AdditionalOptions *S3SourceAdditionalOptions `json:"additionalOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionPredicate *string `json:"partitionPredicate,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type GovernedCatalogTarget struct {
	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionKeys [][]*string `json:"partitionKeys,omitempty"`
	// A policy that specifies update behavior for the crawler.
	SchemaChangePolicy *CatalogSchemaChangePolicy `json:"schemaChangePolicy,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type GrokClassifier struct {
	Classification *string `json:"classification,omitempty"`

	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	CustomPatterns *string `json:"customPatterns,omitempty"`

	GrokPattern *string `json:"grokPattern,omitempty"`

	LastUpdated *metav1.Time `json:"lastUpdated,omitempty"`

	Name *string `json:"name,omitempty"`

	Version *int64 `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type ImportLabelsTaskRunProperties struct {
	InputS3Path *string `json:"inputS3Path,omitempty"`
}

// +kubebuilder:skipversion
type JDBCConnectorOptions struct {
	DataTypeMapping map[string]*string `json:"dataTypeMapping,omitempty"`

	FilterPredicate *string `json:"filterPredicate,omitempty"`

	JobBookmarkKeys []*string `json:"jobBookmarkKeys,omitempty"`

	JobBookmarkKeysSortOrder *string `json:"jobBookmarkKeysSortOrder,omitempty"`

	LowerBound *int64 `json:"lowerBound,omitempty"`

	NumPartitions *int64 `json:"numPartitions,omitempty"`

	PartitionColumn *string `json:"partitionColumn,omitempty"`

	UpperBound *int64 `json:"upperBound,omitempty"`
}

// +kubebuilder:skipversion
type JDBCConnectorSource struct {
	// Additional connection options for the connector.
	AdditionalOptions *JDBCConnectorOptions `json:"additionalOptions,omitempty"`

	ConnectionName *string `json:"connectionName,omitempty"`

	ConnectionTable *string `json:"connectionTable,omitempty"`

	ConnectionType *string `json:"connectionType,omitempty"`

	ConnectorName *string `json:"connectorName,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Query *string `json:"query,omitempty"`
}

// +kubebuilder:skipversion
type JDBCConnectorTarget struct {
	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	ConnectionName *string `json:"connectionName,omitempty"`

	ConnectionTable *string `json:"connectionTable,omitempty"`

	ConnectionType *string `json:"connectionType,omitempty"`

	ConnectorName *string `json:"connectorName,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`
}

// +kubebuilder:skipversion
type JSONClassifier struct {
	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	JSONPath *string `json:"jsonPath,omitempty"`

	LastUpdated *metav1.Time `json:"lastUpdated,omitempty"`

	Name *string `json:"name,omitempty"`

	Version *int64 `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type JdbcTarget struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	EnableAdditionalMetadata []*string `json:"enableAdditionalMetadata,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty"`

	Path *string `json:"path,omitempty"`
}

// +kubebuilder:skipversion
type JobBookmarkEntry struct {
	Attempt *int64 `json:"attempt,omitempty"`

	Run *int64 `json:"run,omitempty"`

	Version *int64 `json:"version,omitempty"`
}

// +kubebuilder:skipversion
type JobBookmarksEncryption struct {
	JobBookmarksEncryptionMode *string `json:"jobBookmarksEncryptionMode,omitempty"`

	KMSKeyARN *string `json:"kmsKeyARN,omitempty"`
}

// +kubebuilder:skipversion
type JobCommand struct {
	Name *string `json:"name,omitempty"`

	PythonVersion *string `json:"pythonVersion,omitempty"`

	Runtime *string `json:"runtime,omitempty"`

	ScriptLocation *string `json:"scriptLocation,omitempty"`
}

// +kubebuilder:skipversion
type JobRun struct {
	AllocatedCapacity *int64 `json:"allocatedCapacity,omitempty"`

	Arguments map[string]*string `json:"arguments,omitempty"`

	CompletedOn *metav1.Time `json:"completedOn,omitempty"`

	DPUSeconds *float64 `json:"dPUSeconds,omitempty"`

	ExecutionClass *string `json:"executionClass,omitempty"`

	GlueVersion *string `json:"glueVersion,omitempty"`

	JobName *string `json:"jobName,omitempty"`

	LastModifiedOn *metav1.Time `json:"lastModifiedOn,omitempty"`

	LogGroupName *string `json:"logGroupName,omitempty"`

	MaxCapacity *float64 `json:"maxCapacity,omitempty"`
	// Specifies configuration properties of a notification.
	NotificationProperty *NotificationProperty `json:"notificationProperty,omitempty"`

	NumberOfWorkers *int64 `json:"numberOfWorkers,omitempty"`

	SecurityConfiguration *string `json:"securityConfiguration,omitempty"`

	StartedOn *metav1.Time `json:"startedOn,omitempty"`

	Timeout *int64 `json:"timeout,omitempty"`

	TriggerName *string `json:"triggerName,omitempty"`

	WorkerType *string `json:"workerType,omitempty"`
}

// +kubebuilder:skipversion
type JobUpdate struct {
	AllocatedCapacity *int64 `json:"allocatedCapacity,omitempty"`

	CodeGenConfigurationNodes map[string]*CodeGenConfigurationNode `json:"codeGenConfigurationNodes,omitempty"`
	// Specifies code that runs when a job is run.
	Command *JobCommand `json:"command,omitempty"`
	// Specifies the connections used by a job.
	Connections *ConnectionsList `json:"connections,omitempty"`

	DefaultArguments map[string]*string `json:"defaultArguments,omitempty"`

	Description *string `json:"description,omitempty"`

	ExecutionClass *string `json:"executionClass,omitempty"`
	// An execution property of a job.
	ExecutionProperty *ExecutionProperty `json:"executionProperty,omitempty"`

	GlueVersion *string `json:"glueVersion,omitempty"`

	LogURI *string `json:"logURI,omitempty"`

	MaxCapacity *float64 `json:"maxCapacity,omitempty"`

	MaxRetries *int64 `json:"maxRetries,omitempty"`

	NonOverridableArguments map[string]*string `json:"nonOverridableArguments,omitempty"`
	// Specifies configuration properties of a notification.
	NotificationProperty *NotificationProperty `json:"notificationProperty,omitempty"`

	NumberOfWorkers *int64 `json:"numberOfWorkers,omitempty"`

	Role *string `json:"role,omitempty"`

	SecurityConfiguration *string `json:"securityConfiguration,omitempty"`
	// The details for a source control configuration for a job, allowing synchronization
	// of job artifacts to or from a remote repository.
	SourceControlDetails *SourceControlDetails `json:"sourceControlDetails,omitempty"`

	Timeout *int64 `json:"timeout,omitempty"`

	WorkerType *string `json:"workerType,omitempty"`
}

// +kubebuilder:skipversion
type Job_SDK struct {
	AllocatedCapacity *int64 `json:"allocatedCapacity,omitempty"`

	CodeGenConfigurationNodes map[string]*CodeGenConfigurationNode `json:"codeGenConfigurationNodes,omitempty"`
	// Specifies code that runs when a job is run.
	Command *JobCommand `json:"command,omitempty"`
	// Specifies the connections used by a job.
	Connections *ConnectionsList `json:"connections,omitempty"`

	CreatedOn *metav1.Time `json:"createdOn,omitempty"`

	DefaultArguments map[string]*string `json:"defaultArguments,omitempty"`

	Description *string `json:"description,omitempty"`

	ExecutionClass *string `json:"executionClass,omitempty"`
	// An execution property of a job.
	ExecutionProperty *ExecutionProperty `json:"executionProperty,omitempty"`

	GlueVersion *string `json:"glueVersion,omitempty"`

	LastModifiedOn *metav1.Time `json:"lastModifiedOn,omitempty"`

	LogURI *string `json:"logURI,omitempty"`

	MaxCapacity *float64 `json:"maxCapacity,omitempty"`

	MaxRetries *int64 `json:"maxRetries,omitempty"`

	Name *string `json:"name,omitempty"`

	NonOverridableArguments map[string]*string `json:"nonOverridableArguments,omitempty"`
	// Specifies configuration properties of a notification.
	NotificationProperty *NotificationProperty `json:"notificationProperty,omitempty"`

	NumberOfWorkers *int64 `json:"numberOfWorkers,omitempty"`

	Role *string `json:"role,omitempty"`

	SecurityConfiguration *string `json:"securityConfiguration,omitempty"`
	// The details for a source control configuration for a job, allowing synchronization
	// of job artifacts to or from a remote repository.
	SourceControlDetails *SourceControlDetails `json:"sourceControlDetails,omitempty"`

	Timeout *int64 `json:"timeout,omitempty"`

	WorkerType *string `json:"workerType,omitempty"`
}

// +kubebuilder:skipversion
type Join struct {
	Columns []*JoinColumn `json:"columns,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	JoinType *string `json:"joinType,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type JoinColumn struct {
	From *string `json:"from,omitempty"`

	Keys [][]*string `json:"keys,omitempty"`
}

// +kubebuilder:skipversion
type KafkaStreamingSourceOptions struct {
	AddRecordTimestamp *string `json:"addRecordTimestamp,omitempty"`

	Assign *string `json:"assign,omitempty"`

	BootstrapServers *string `json:"bootstrapServers,omitempty"`

	Classification *string `json:"classification,omitempty"`

	ConnectionName *string `json:"connectionName,omitempty"`

	Delimiter *string `json:"delimiter,omitempty"`

	EmitConsumerLagMetrics *string `json:"emitConsumerLagMetrics,omitempty"`

	EndingOffsets *string `json:"endingOffsets,omitempty"`

	IncludeHeaders *bool `json:"includeHeaders,omitempty"`

	MaxOffsetsPerTrigger *int64 `json:"maxOffsetsPerTrigger,omitempty"`

	MinPartitions *int64 `json:"minPartitions,omitempty"`

	NumRetries *int64 `json:"numRetries,omitempty"`

	PollTimeoutMs *int64 `json:"pollTimeoutMs,omitempty"`

	RetryIntervalMs *int64 `json:"retryIntervalMs,omitempty"`

	SecurityProtocol *string `json:"securityProtocol,omitempty"`

	StartingOffsets *string `json:"startingOffsets,omitempty"`

	SubscribePattern *string `json:"subscribePattern,omitempty"`

	TopicName *string `json:"topicName,omitempty"`
}

// +kubebuilder:skipversion
type KeySchemaElement struct {
	Name *string `json:"name,omitempty"`

	Type *string `json:"type_,omitempty"`
}

// +kubebuilder:skipversion
type KinesisStreamingSourceOptions struct {
	AddIdleTimeBetweenReads *bool `json:"addIdleTimeBetweenReads,omitempty"`

	AddRecordTimestamp *string `json:"addRecordTimestamp,omitempty"`

	AvoidEmptyBatches *bool `json:"avoidEmptyBatches,omitempty"`

	Classification *string `json:"classification,omitempty"`

	Delimiter *string `json:"delimiter,omitempty"`

	DescribeShardInterval *int64 `json:"describeShardInterval,omitempty"`

	EmitConsumerLagMetrics *string `json:"emitConsumerLagMetrics,omitempty"`

	EndpointURL *string `json:"endpointURL,omitempty"`

	IdleTimeBetweenReadsInMs *int64 `json:"idleTimeBetweenReadsInMs,omitempty"`

	MaxFetchRecordsPerShard *int64 `json:"maxFetchRecordsPerShard,omitempty"`

	MaxFetchTimeInMs *int64 `json:"maxFetchTimeInMs,omitempty"`

	MaxRecordPerRead *int64 `json:"maxRecordPerRead,omitempty"`

	MaxRetryIntervalMs *int64 `json:"maxRetryIntervalMs,omitempty"`

	NumRetries *int64 `json:"numRetries,omitempty"`

	RetryIntervalMs *int64 `json:"retryIntervalMs,omitempty"`

	RoleARN *string `json:"roleARN,omitempty"`

	RoleSessionName *string `json:"roleSessionName,omitempty"`

	StartingPosition *string `json:"startingPosition,omitempty"`

	StreamARN *string `json:"streamARN,omitempty"`

	StreamName *string `json:"streamName,omitempty"`
}

// +kubebuilder:skipversion
type LabelingSetGenerationTaskRunProperties struct {
	OutputS3Path *string `json:"outputS3Path,omitempty"`
}

// +kubebuilder:skipversion
type LakeFormationConfiguration struct {
	AccountID *string `json:"accountID,omitempty"`

	UseLakeFormationCredentials *bool `json:"useLakeFormationCredentials,omitempty"`
}

// +kubebuilder:skipversion
type LastActiveDefinition struct {
	BlueprintLocation *string `json:"blueprintLocation,omitempty"`

	BlueprintServiceLocation *string `json:"blueprintServiceLocation,omitempty"`

	Description *string `json:"description,omitempty"`

	LastModifiedOn *metav1.Time `json:"lastModifiedOn,omitempty"`
}

// +kubebuilder:skipversion
type LastCrawlInfo struct {
	ErrorMessage *string `json:"errorMessage,omitempty"`

	LogGroup *string `json:"logGroup,omitempty"`

	LogStream *string `json:"logStream,omitempty"`

	MessagePrefix *string `json:"messagePrefix,omitempty"`

	StartTime *metav1.Time `json:"startTime,omitempty"`

	Status *string `json:"status,omitempty"`
}

// +kubebuilder:skipversion
type LineageConfiguration struct {
	CrawlerLineageSettings *string `json:"crawlerLineageSettings,omitempty"`
}

// +kubebuilder:skipversion
type MLTransform struct {
	CreatedOn *metav1.Time `json:"createdOn,omitempty"`

	Description *string `json:"description,omitempty"`

	GlueVersion *string `json:"glueVersion,omitempty"`

	LastModifiedOn *metav1.Time `json:"lastModifiedOn,omitempty"`

	MaxCapacity *float64 `json:"maxCapacity,omitempty"`

	MaxRetries *int64 `json:"maxRetries,omitempty"`

	Name *string `json:"name,omitempty"`

	NumberOfWorkers *int64 `json:"numberOfWorkers,omitempty"`

	Role *string `json:"role,omitempty"`

	Timeout *int64 `json:"timeout,omitempty"`

	WorkerType *string `json:"workerType,omitempty"`
}

// +kubebuilder:skipversion
type MLUserDataEncryption struct {
	KMSKeyID *string `json:"kmsKeyID,omitempty"`
}

// +kubebuilder:skipversion
type Mapping struct {
	Dropped *bool `json:"dropped,omitempty"`

	FromPath []*string `json:"fromPath,omitempty"`

	FromType *string `json:"fromType,omitempty"`

	ToKey *string `json:"toKey,omitempty"`

	ToType *string `json:"toType,omitempty"`
}

// +kubebuilder:skipversion
type Merge struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PrimaryKeys [][]*string `json:"primaryKeys,omitempty"`

	Source *string `json:"source,omitempty"`
}

// +kubebuilder:skipversion
type MicrosoftSQLServerCatalogSource struct {
	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type MicrosoftSQLServerCatalogTarget struct {
	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type MongoDBTarget struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	Path *string `json:"path,omitempty"`

	ScanAll *bool `json:"scanAll,omitempty"`
}

// +kubebuilder:skipversion
type MySQLCatalogSource struct {
	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type MySQLCatalogTarget struct {
	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type Node struct {
	Name *string `json:"name,omitempty"`

	UniqueID *string `json:"uniqueID,omitempty"`
}

// +kubebuilder:skipversion
type NotificationProperty struct {
	NotifyDelayAfter *int64 `json:"notifyDelayAfter,omitempty"`
}

// +kubebuilder:skipversion
type NullCheckBoxList struct {
	IsEmpty *bool `json:"isEmpty,omitempty"`

	IsNegOne *bool `json:"isNegOne,omitempty"`

	IsNullString *bool `json:"isNullString,omitempty"`
}

// +kubebuilder:skipversion
type NullValueField struct {
	// A structure representing the datatype of the value.
	Datatype *Datatype `json:"datatype,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type Option struct {
	Description *string `json:"description,omitempty"`

	Label *string `json:"label,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type OracleSQLCatalogSource struct {
	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type OracleSQLCatalogTarget struct {
	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type Order struct {
	Column *string `json:"column,omitempty"`
}

// +kubebuilder:skipversion
type PIIDetection struct {
	EntityTypesToDetect []*string `json:"entityTypesToDetect,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	MaskValue *string `json:"maskValue,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputColumnName *string `json:"outputColumnName,omitempty"`

	PiiType *string `json:"piiType,omitempty"`

	SampleFraction *float64 `json:"sampleFraction,omitempty"`

	ThresholdFraction *float64 `json:"thresholdFraction,omitempty"`
}

// +kubebuilder:skipversion
type Partition struct {
	CatalogID *string `json:"catalogID,omitempty"`

	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`

	LastAccessTime *metav1.Time `json:"lastAccessTime,omitempty"`

	LastAnalyzedTime *metav1.Time `json:"lastAnalyzedTime,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`

	TableName *string `json:"tableName,omitempty"`
}

// +kubebuilder:skipversion
type PartitionIndex struct {
	IndexName *string `json:"indexName,omitempty"`
}

// +kubebuilder:skipversion
type PartitionIndexDescriptor struct {
	IndexName *string `json:"indexName,omitempty"`
}

// +kubebuilder:skipversion
type PartitionInput struct {
	LastAccessTime *metav1.Time `json:"lastAccessTime,omitempty"`

	LastAnalyzedTime *metav1.Time `json:"lastAnalyzedTime,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`
}

// +kubebuilder:skipversion
type PhysicalConnectionRequirements struct {
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	SecurityGroupIDList []*string `json:"securityGroupIDList,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// +kubebuilder:skipversion
type PostgreSQLCatalogSource struct {
	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type PostgreSQLCatalogTarget struct {
	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type Predecessor struct {
	JobName *string `json:"jobName,omitempty"`
}

// +kubebuilder:skipversion
type PrincipalPermissions struct {
	Permissions []*string `json:"permissions,omitempty"`
	// The Lake Formation principal.
	Principal *DataLakePrincipal `json:"principal,omitempty"`
}

// +kubebuilder:skipversion
type PropertyPredicate struct {
	Key *string `json:"key,omitempty"`

	Value *string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type RecrawlPolicy struct {
	RecrawlBehavior *string `json:"recrawlBehavior,omitempty"`
}

// +kubebuilder:skipversion
type RedshiftSource struct {
	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	RedshiftTmpDir *string `json:"redshiftTmpDir,omitempty"`

	Table *string `json:"table,omitempty"`

	TmpDirIAMRole *string `json:"tmpDirIAMRole,omitempty"`
}

// +kubebuilder:skipversion
type RedshiftTarget struct {
	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	RedshiftTmpDir *string `json:"redshiftTmpDir,omitempty"`

	Table *string `json:"table,omitempty"`

	TmpDirIAMRole *string `json:"tmpDirIAMRole,omitempty"`
	// The options to configure an upsert operation when writing to a Redshift target .
	UpsertRedshiftOptions *UpsertRedshiftTargetOptions `json:"upsertRedshiftOptions,omitempty"`
}

// +kubebuilder:skipversion
type RegistryListItem struct {
	Description *string `json:"description,omitempty"`
}

// +kubebuilder:skipversion
type RelationalCatalogSource struct {
	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type RenameField struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	SourcePath []*string `json:"sourcePath,omitempty"`

	TargetPath []*string `json:"targetPath,omitempty"`
}

// +kubebuilder:skipversion
type ResourceURI struct {
	URI *string `json:"uri,omitempty"`
}

// +kubebuilder:skipversion
type S3CatalogDeltaSource struct {
	AdditionalDeltaOptions map[string]*string `json:"additionalDeltaOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type S3CatalogHudiSource struct {
	AdditionalHudiOptions map[string]*string `json:"additionalHudiOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type S3CatalogSource struct {
	// Specifies additional connection options for the Amazon S3 data store.
	AdditionalOptions *S3SourceAdditionalOptions `json:"additionalOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionPredicate *string `json:"partitionPredicate,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type S3CatalogTarget struct {
	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionKeys [][]*string `json:"partitionKeys,omitempty"`
	// A policy that specifies update behavior for the crawler.
	SchemaChangePolicy *CatalogSchemaChangePolicy `json:"schemaChangePolicy,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type S3CsvSource struct {
	// Specifies additional connection options for the Amazon S3 data store.
	AdditionalOptions *S3DirectSourceAdditionalOptions `json:"additionalOptions,omitempty"`

	CompressionType *string `json:"compressionType,omitempty"`

	Escaper *string `json:"escaper,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty"`

	GroupFiles *string `json:"groupFiles,omitempty"`

	GroupSize *string `json:"groupSize,omitempty"`

	MaxBand *int64 `json:"maxBand,omitempty"`

	MaxFilesInBand *int64 `json:"maxFilesInBand,omitempty"`

	Multiline *bool `json:"multiline,omitempty"`

	Name *string `json:"name,omitempty"`

	OptimizePerformance *bool `json:"optimizePerformance,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Paths []*string `json:"paths,omitempty"`

	QuoteChar *string `json:"quoteChar,omitempty"`

	Recurse *bool `json:"recurse,omitempty"`

	Separator *string `json:"separator,omitempty"`

	SkipFirst *bool `json:"skipFirst,omitempty"`

	WithHeader *bool `json:"withHeader,omitempty"`

	WriteHeader *bool `json:"writeHeader,omitempty"`
}

// +kubebuilder:skipversion
type S3DeltaCatalogTarget struct {
	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionKeys [][]*string `json:"partitionKeys,omitempty"`
	// A policy that specifies update behavior for the crawler.
	SchemaChangePolicy *CatalogSchemaChangePolicy `json:"schemaChangePolicy,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type S3DeltaDirectTarget struct {
	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	Compression *string `json:"compression,omitempty"`

	Format *string `json:"format,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionKeys [][]*string `json:"partitionKeys,omitempty"`

	Path *string `json:"path,omitempty"`
	// A policy that specifies update behavior for the crawler.
	SchemaChangePolicy *DirectSchemaChangePolicy `json:"schemaChangePolicy,omitempty"`
}

// +kubebuilder:skipversion
type S3DeltaSource struct {
	AdditionalDeltaOptions map[string]*string `json:"additionalDeltaOptions,omitempty"`
	// Specifies additional connection options for the Amazon S3 data store.
	AdditionalOptions *S3DirectSourceAdditionalOptions `json:"additionalOptions,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Paths []*string `json:"paths,omitempty"`
}

// +kubebuilder:skipversion
type S3DirectSourceAdditionalOptions struct {
	BoundedFiles *int64 `json:"boundedFiles,omitempty"`

	BoundedSize *int64 `json:"boundedSize,omitempty"`

	EnableSamplePath *bool `json:"enableSamplePath,omitempty"`

	SamplePath *string `json:"samplePath,omitempty"`
}

// +kubebuilder:skipversion
type S3DirectTarget struct {
	Compression *string `json:"compression,omitempty"`

	Format *string `json:"format,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionKeys [][]*string `json:"partitionKeys,omitempty"`

	Path *string `json:"path,omitempty"`
	// A policy that specifies update behavior for the crawler.
	SchemaChangePolicy *DirectSchemaChangePolicy `json:"schemaChangePolicy,omitempty"`
}

// +kubebuilder:skipversion
type S3Encryption struct {
	KMSKeyARN *string `json:"kmsKeyARN,omitempty"`

	S3EncryptionMode *string `json:"s3EncryptionMode,omitempty"`
}

// +kubebuilder:skipversion
type S3GlueParquetTarget struct {
	Compression *string `json:"compression,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionKeys [][]*string `json:"partitionKeys,omitempty"`

	Path *string `json:"path,omitempty"`
	// A policy that specifies update behavior for the crawler.
	SchemaChangePolicy *DirectSchemaChangePolicy `json:"schemaChangePolicy,omitempty"`
}

// +kubebuilder:skipversion
type S3HudiCatalogTarget struct {
	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	Database *string `json:"database,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionKeys [][]*string `json:"partitionKeys,omitempty"`
	// A policy that specifies update behavior for the crawler.
	SchemaChangePolicy *CatalogSchemaChangePolicy `json:"schemaChangePolicy,omitempty"`

	Table *string `json:"table,omitempty"`
}

// +kubebuilder:skipversion
type S3HudiDirectTarget struct {
	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	Compression *string `json:"compression,omitempty"`

	Format *string `json:"format,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	PartitionKeys [][]*string `json:"partitionKeys,omitempty"`

	Path *string `json:"path,omitempty"`
	// A policy that specifies update behavior for the crawler.
	SchemaChangePolicy *DirectSchemaChangePolicy `json:"schemaChangePolicy,omitempty"`
}

// +kubebuilder:skipversion
type S3HudiSource struct {
	AdditionalHudiOptions map[string]*string `json:"additionalHudiOptions,omitempty"`
	// Specifies additional connection options for the Amazon S3 data store.
	AdditionalOptions *S3DirectSourceAdditionalOptions `json:"additionalOptions,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Paths []*string `json:"paths,omitempty"`
}

// +kubebuilder:skipversion
type S3JSONSource struct {
	// Specifies additional connection options for the Amazon S3 data store.
	AdditionalOptions *S3DirectSourceAdditionalOptions `json:"additionalOptions,omitempty"`

	CompressionType *string `json:"compressionType,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty"`

	GroupFiles *string `json:"groupFiles,omitempty"`

	GroupSize *string `json:"groupSize,omitempty"`

	JSONPath *string `json:"jsonPath,omitempty"`

	MaxBand *int64 `json:"maxBand,omitempty"`

	MaxFilesInBand *int64 `json:"maxFilesInBand,omitempty"`

	Multiline *bool `json:"multiline,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Paths []*string `json:"paths,omitempty"`

	Recurse *bool `json:"recurse,omitempty"`
}

// +kubebuilder:skipversion
type S3ParquetSource struct {
	// Specifies additional connection options for the Amazon S3 data store.
	AdditionalOptions *S3DirectSourceAdditionalOptions `json:"additionalOptions,omitempty"`

	CompressionType *string `json:"compressionType,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty"`

	GroupFiles *string `json:"groupFiles,omitempty"`

	GroupSize *string `json:"groupSize,omitempty"`

	MaxBand *int64 `json:"maxBand,omitempty"`

	MaxFilesInBand *int64 `json:"maxFilesInBand,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	Paths []*string `json:"paths,omitempty"`

	Recurse *bool `json:"recurse,omitempty"`
}

// +kubebuilder:skipversion
type S3SourceAdditionalOptions struct {
	BoundedFiles *int64 `json:"boundedFiles,omitempty"`

	BoundedSize *int64 `json:"boundedSize,omitempty"`
}

// +kubebuilder:skipversion
type S3Target struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	DlqEventQueueARN *string `json:"dlqEventQueueARN,omitempty"`

	EventQueueARN *string `json:"eventQueueARN,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty"`

	Path *string `json:"path,omitempty"`

	SampleSize *int64 `json:"sampleSize,omitempty"`
}

// +kubebuilder:skipversion
type SQLAlias struct {
	Alias *string `json:"alias,omitempty"`

	From *string `json:"from,omitempty"`
}

// +kubebuilder:skipversion
type Schedule struct {
	ScheduleExpression *string `json:"scheduleExpression,omitempty"`

	State *string `json:"state,omitempty"`
}

// +kubebuilder:skipversion
type SchemaChangePolicy struct {
	DeleteBehavior *string `json:"deleteBehavior,omitempty"`

	UpdateBehavior *string `json:"updateBehavior,omitempty"`
}

// +kubebuilder:skipversion
type SchemaColumn struct {
	DataType *string `json:"dataType,omitempty"`
}

// +kubebuilder:skipversion
type SchemaListItem struct {
	Description *string `json:"description,omitempty"`
}

// +kubebuilder:skipversion
type SecurityConfiguration_SDK struct {
	CreatedTimeStamp *metav1.Time `json:"createdTimeStamp,omitempty"`
	// Specifies an encryption configuration.
	EncryptionConfiguration *EncryptionConfiguration `json:"encryptionConfiguration,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type SelectFields struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Paths [][]*string `json:"paths,omitempty"`
}

// +kubebuilder:skipversion
type SelectFromCollection struct {
	Index *int64 `json:"index,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type SerDeInfo struct {
	Name *string `json:"name,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`

	SerializationLibrary *string `json:"serializationLibrary,omitempty"`
}

// +kubebuilder:skipversion
type Session struct {
	// Specifies the connections used by a job.
	Connections *ConnectionsList `json:"connections,omitempty"`

	CreatedOn *metav1.Time `json:"createdOn,omitempty"`

	Description *string `json:"description,omitempty"`

	ErrorMessage *string `json:"errorMessage,omitempty"`

	GlueVersion *string `json:"glueVersion,omitempty"`

	ID *string `json:"id,omitempty"`

	MaxCapacity *float64 `json:"maxCapacity,omitempty"`

	SecurityConfiguration *string `json:"securityConfiguration,omitempty"`
}

// +kubebuilder:skipversion
type SessionCommand struct {
	Name *string `json:"name,omitempty"`

	PythonVersion *string `json:"pythonVersion,omitempty"`
}

// +kubebuilder:skipversion
type SortCriterion struct {
	FieldName *string `json:"fieldName,omitempty"`
}

// +kubebuilder:skipversion
type SourceControlDetails struct {
	AuthStrategy *string `json:"authStrategy,omitempty"`

	AuthToken *string `json:"authToken,omitempty"`

	Branch *string `json:"branch,omitempty"`

	Folder *string `json:"folder,omitempty"`

	LastCommitID *string `json:"lastCommitID,omitempty"`

	Owner *string `json:"owner,omitempty"`

	Provider *string `json:"provider,omitempty"`

	Repository *string `json:"repository,omitempty"`
}

// +kubebuilder:skipversion
type SparkConnectorSource struct {
	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	ConnectionName *string `json:"connectionName,omitempty"`

	ConnectionType *string `json:"connectionType,omitempty"`

	ConnectorName *string `json:"connectorName,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`
}

// +kubebuilder:skipversion
type SparkConnectorTarget struct {
	AdditionalOptions map[string]*string `json:"additionalOptions,omitempty"`

	ConnectionName *string `json:"connectionName,omitempty"`

	ConnectionType *string `json:"connectionType,omitempty"`

	ConnectorName *string `json:"connectorName,omitempty"`

	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`
}

// +kubebuilder:skipversion
type SparkSQL struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	OutputSchemas []*GlueSchema `json:"outputSchemas,omitempty"`

	SQLAliases []*SQLAlias `json:"sqlAliases,omitempty"`

	SQLQuery *string `json:"sqlQuery,omitempty"`
}

// +kubebuilder:skipversion
type Spigot struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Path *string `json:"path,omitempty"`

	Prob *float64 `json:"prob,omitempty"`

	Topk *int64 `json:"topk,omitempty"`
}

// +kubebuilder:skipversion
type SplitFields struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	Paths [][]*string `json:"paths,omitempty"`
}

// +kubebuilder:skipversion
type StartingEventBatchCondition struct {
	BatchSize *int64 `json:"batchSize,omitempty"`

	BatchWindow *int64 `json:"batchWindow,omitempty"`
}

// +kubebuilder:skipversion
type Statement struct {
	Code *string `json:"code,omitempty"`

	ID *int64 `json:"id,omitempty"`
}

// +kubebuilder:skipversion
type StatementOutput struct {
	ErrorName *string `json:"errorName,omitempty"`

	ErrorValue *string `json:"errorValue,omitempty"`

	ExecutionCount *int64 `json:"executionCount,omitempty"`

	Traceback []*string `json:"traceback,omitempty"`
}

// +kubebuilder:skipversion
type StatementOutputData struct {
	TextPlain *string `json:"textPlain,omitempty"`
}

// +kubebuilder:skipversion
type StorageDescriptor struct {
	Compressed *bool `json:"compressed,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`

	StoredAsSubDirectories *bool `json:"storedAsSubDirectories,omitempty"`
}

// +kubebuilder:skipversion
type StreamingDataPreviewOptions struct {
	PollingTime *int64 `json:"pollingTime,omitempty"`

	RecordPollingLimit *int64 `json:"recordPollingLimit,omitempty"`
}

// +kubebuilder:skipversion
type Table struct {
	CatalogID *string `json:"catalogID,omitempty"`

	ConnectionName *string `json:"connectionName,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`

	TableName *string `json:"tableName,omitempty"`
}

// +kubebuilder:skipversion
type TableData struct {
	CatalogID *string `json:"catalogID,omitempty"`

	CreateTime *metav1.Time `json:"createTime,omitempty"`

	CreatedBy *string `json:"createdBy,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`

	Description *string `json:"description,omitempty"`

	IsRegisteredWithLakeFormation *bool `json:"isRegisteredWithLakeFormation,omitempty"`

	LastAccessTime *metav1.Time `json:"lastAccessTime,omitempty"`

	LastAnalyzedTime *metav1.Time `json:"lastAnalyzedTime,omitempty"`

	Name *string `json:"name,omitempty"`

	Owner *string `json:"owner,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`

	UpdateTime *metav1.Time `json:"updateTime,omitempty"`
}

// +kubebuilder:skipversion
type TableError struct {
	TableName *string `json:"tableName,omitempty"`
}

// +kubebuilder:skipversion
type TableIdentifier struct {
	CatalogID *string `json:"catalogID,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type TableInput struct {
	Description *string `json:"description,omitempty"`

	LastAccessTime *metav1.Time `json:"lastAccessTime,omitempty"`

	LastAnalyzedTime *metav1.Time `json:"lastAnalyzedTime,omitempty"`

	Name *string `json:"name,omitempty"`

	Owner *string `json:"owner,omitempty"`

	Parameters map[string]*string `json:"parameters,omitempty"`
}

// +kubebuilder:skipversion
type TableVersionError struct {
	TableName *string `json:"tableName,omitempty"`
}

// +kubebuilder:skipversion
type TaskRun struct {
	CompletedOn *metav1.Time `json:"completedOn,omitempty"`

	ErrorString *string `json:"errorString,omitempty"`

	LastModifiedOn *metav1.Time `json:"lastModifiedOn,omitempty"`

	LogGroupName *string `json:"logGroupName,omitempty"`

	StartedOn *metav1.Time `json:"startedOn,omitempty"`
}

// +kubebuilder:skipversion
type TaskRunFilterCriteria struct {
	StartedAfter *metav1.Time `json:"startedAfter,omitempty"`

	StartedBefore *metav1.Time `json:"startedBefore,omitempty"`
}

// +kubebuilder:skipversion
type TransformConfigParameter struct {
	IsOptional *bool `json:"isOptional,omitempty"`

	ListType *string `json:"listType,omitempty"`

	Name *string `json:"name,omitempty"`

	Type *string `json:"type_,omitempty"`

	ValidationMessage *string `json:"validationMessage,omitempty"`

	ValidationRule *string `json:"validationRule,omitempty"`

	Value []*string `json:"value,omitempty"`
}

// +kubebuilder:skipversion
type TransformEncryption struct {
	TaskRunSecurityConfigurationName *string `json:"taskRunSecurityConfigurationName,omitempty"`
}

// +kubebuilder:skipversion
type TransformFilterCriteria struct {
	CreatedAfter *metav1.Time `json:"createdAfter,omitempty"`

	CreatedBefore *metav1.Time `json:"createdBefore,omitempty"`

	GlueVersion *string `json:"glueVersion,omitempty"`

	LastModifiedAfter *metav1.Time `json:"lastModifiedAfter,omitempty"`

	LastModifiedBefore *metav1.Time `json:"lastModifiedBefore,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type Trigger struct {
	Description *string `json:"description,omitempty"`

	Name *string `json:"name,omitempty"`

	Schedule *string `json:"schedule,omitempty"`

	WorkflowName *string `json:"workflowName,omitempty"`
}

// +kubebuilder:skipversion
type TriggerUpdate struct {
	Description *string `json:"description,omitempty"`

	Name *string `json:"name,omitempty"`

	Schedule *string `json:"schedule,omitempty"`
}

// +kubebuilder:skipversion
type UnfilteredPartition struct {
	IsRegisteredWithLakeFormation *bool `json:"isRegisteredWithLakeFormation,omitempty"`
}

// +kubebuilder:skipversion
type Union struct {
	Inputs []*string `json:"inputs,omitempty"`

	Name *string `json:"name,omitempty"`

	UnionType *string `json:"unionType,omitempty"`
}

// +kubebuilder:skipversion
type UpdateCsvClassifierRequest struct {
	AllowSingleColumn *bool `json:"allowSingleColumn,omitempty"`

	ContainsHeader *string `json:"containsHeader,omitempty"`

	CustomDatatypeConfigured *bool `json:"customDatatypeConfigured,omitempty"`

	CustomDatatypes []*string `json:"customDatatypes,omitempty"`

	Delimiter *string `json:"delimiter,omitempty"`

	DisableValueTrimming *bool `json:"disableValueTrimming,omitempty"`

	Header []*string `json:"header,omitempty"`

	Name *string `json:"name,omitempty"`

	QuoteSymbol *string `json:"quoteSymbol,omitempty"`
}

// +kubebuilder:skipversion
type UpdateGrokClassifierRequest struct {
	Classification *string `json:"classification,omitempty"`

	CustomPatterns *string `json:"customPatterns,omitempty"`

	GrokPattern *string `json:"grokPattern,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type UpdateJSONClassifierRequest struct {
	JSONPath *string `json:"jsonPath,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type UpdateXMLClassifierRequest struct {
	Classification *string `json:"classification,omitempty"`

	Name *string `json:"name,omitempty"`

	RowTag *string `json:"rowTag,omitempty"`
}

// +kubebuilder:skipversion
type UpsertRedshiftTargetOptions struct {
	ConnectionName *string `json:"connectionName,omitempty"`

	TableLocation *string `json:"tableLocation,omitempty"`

	UpsertKeys []*string `json:"upsertKeys,omitempty"`
}

// +kubebuilder:skipversion
type UserDefinedFunction struct {
	CatalogID *string `json:"catalogID,omitempty"`

	ClassName *string `json:"className,omitempty"`

	CreateTime *metav1.Time `json:"createTime,omitempty"`

	DatabaseName *string `json:"databaseName,omitempty"`

	FunctionName *string `json:"functionName,omitempty"`

	OwnerName *string `json:"ownerName,omitempty"`
}

// +kubebuilder:skipversion
type UserDefinedFunctionInput struct {
	ClassName *string `json:"className,omitempty"`

	FunctionName *string `json:"functionName,omitempty"`

	OwnerName *string `json:"ownerName,omitempty"`
}

// +kubebuilder:skipversion
type Workflow struct {
	CreatedOn *metav1.Time `json:"createdOn,omitempty"`

	Description *string `json:"description,omitempty"`

	LastModifiedOn *metav1.Time `json:"lastModifiedOn,omitempty"`

	MaxConcurrentRuns *int64 `json:"maxConcurrentRuns,omitempty"`

	Name *string `json:"name,omitempty"`
}

// +kubebuilder:skipversion
type WorkflowRun struct {
	CompletedOn *metav1.Time `json:"completedOn,omitempty"`

	Name *string `json:"name,omitempty"`

	StartedOn *metav1.Time `json:"startedOn,omitempty"`
}

// +kubebuilder:skipversion
type WorkflowRunStatistics struct {
	ErroredActions *int64 `json:"erroredActions,omitempty"`

	FailedActions *int64 `json:"failedActions,omitempty"`

	RunningActions *int64 `json:"runningActions,omitempty"`

	StoppedActions *int64 `json:"stoppedActions,omitempty"`

	SucceededActions *int64 `json:"succeededActions,omitempty"`

	TimeoutActions *int64 `json:"timeoutActions,omitempty"`

	TotalActions *int64 `json:"totalActions,omitempty"`

	WaitingActions *int64 `json:"waitingActions,omitempty"`
}

// +kubebuilder:skipversion
type XMLClassifier struct {
	Classification *string `json:"classification,omitempty"`

	CreationTime *metav1.Time `json:"creationTime,omitempty"`

	LastUpdated *metav1.Time `json:"lastUpdated,omitempty"`

	Name *string `json:"name,omitempty"`

	RowTag *string `json:"rowTag,omitempty"`

	Version *int64 `json:"version,omitempty"`
}
