package taskdefinition

import (
	"context"

	"github.com/aws/aws-sdk-go/aws"
	svcsdk "github.com/aws/aws-sdk-go/service/ecs"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/connection"
	"github.com/crossplane/crossplane-runtime/pkg/controller"
	"github.com/crossplane/crossplane-runtime/pkg/event"
	"github.com/crossplane/crossplane-runtime/pkg/meta"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	ctrl "sigs.k8s.io/controller-runtime"

	svcapitypes "github.com/crossplane-contrib/provider-aws/apis/ecs/v1alpha1"
	"github.com/crossplane-contrib/provider-aws/apis/v1alpha1"
	"github.com/crossplane-contrib/provider-aws/pkg/features"
	custommanaged "github.com/crossplane-contrib/provider-aws/pkg/utils/reconciler/managed"
)

// SetupTaskDefinition adds a controller that reconciles TaskDefinition.
func SetupTaskDefinition(mgr ctrl.Manager, o controller.Options) error {
	name := managed.ControllerName(svcapitypes.TaskDefinitionGroupKind)

	cps := []managed.ConnectionPublisher{managed.NewAPISecretPublisher(mgr.GetClient(), mgr.GetScheme())}
	if o.Features.Enabled(features.EnableAlphaExternalSecretStores) {
		cps = append(cps, connection.NewDetailsManager(mgr.GetClient(), v1alpha1.StoreConfigGroupVersionKind))
	}

	opts := []option{
		func(e *external) {
			e.preObserve = preObserve
			e.postObserve = postObserve
			e.preCreate = preCreate
			e.postCreate = postCreate
			e.preDelete = preDelete
		},
	}

	reconcilerOpts := []managed.ReconcilerOption{
		managed.WithCriticalAnnotationUpdater(custommanaged.NewRetryingCriticalAnnotationUpdater(mgr.GetClient())),
		managed.WithExternalConnecter(&connector{kube: mgr.GetClient(), opts: opts}),
		managed.WithInitializers(),
		managed.WithPollInterval(o.PollInterval),
		managed.WithLogger(o.Logger.WithValues("controller", name)),
		managed.WithRecorder(event.NewAPIRecorder(mgr.GetEventRecorderFor(name))),
		managed.WithConnectionPublishers(cps...),
	}

	if o.Features.Enabled(features.EnableAlphaManagementPolicies) {
		reconcilerOpts = append(reconcilerOpts, managed.WithManagementPolicies())
	}

	r := managed.NewReconciler(mgr,
		resource.ManagedKind(svcapitypes.TaskDefinitionGroupVersionKind),
		reconcilerOpts...)

	return ctrl.NewControllerManagedBy(mgr).
		Named(name).
		WithOptions(o.ForControllerRuntime()).
		WithEventFilter(resource.DesiredStateChanged()).
		For(&svcapitypes.TaskDefinition{}).
		Complete(r)
}

func preObserve(_ context.Context, cr *svcapitypes.TaskDefinition, obj *svcsdk.DescribeTaskDefinitionInput) error {
	obj.SetTaskDefinition(meta.GetExternalName(cr))

	if err := obj.Validate(); err != nil {
		return err
	}
	return nil
}

func postObserve(_ context.Context, cr *svcapitypes.TaskDefinition, resp *svcsdk.DescribeTaskDefinitionOutput, obs managed.ExternalObservation, err error) (managed.ExternalObservation, error) {
	if err != nil {
		return obs, err
	}
	if aws.StringValue(resp.TaskDefinition.Status) == "ACTIVE" {
		cr.SetConditions(xpv1.Available())
	}
	if aws.StringValue(resp.TaskDefinition.Status) == "INACTIVE" {
		// Deleted services can still be described in the API and show up with
		// an INACTIVE status.
		obs.ResourceExists = false
		cr.SetConditions(xpv1.Unavailable())
	}
	return obs, nil
}

func preCreate(_ context.Context, cr *svcapitypes.TaskDefinition, obj *svcsdk.RegisterTaskDefinitionInput) error {
	obj.ExecutionRoleArn = cr.Spec.ForProvider.ExecutionRoleARN
	obj.TaskRoleArn = cr.Spec.ForProvider.TaskRoleARN
	obj.Volumes = generateVolumes(cr)

	if err := obj.Validate(); err != nil {
		return err
	}
	return nil
}

func postCreate(_ context.Context, cr *svcapitypes.TaskDefinition, resp *svcsdk.RegisterTaskDefinitionOutput, cre managed.ExternalCreation, err error) (managed.ExternalCreation, error) {
	if err != nil {
		return managed.ExternalCreation{}, err
	}
	meta.SetExternalName(cr, aws.StringValue(resp.TaskDefinition.TaskDefinitionArn))
	return cre, nil
}

func preDelete(_ context.Context, cr *svcapitypes.TaskDefinition, obj *svcsdk.DeregisterTaskDefinitionInput) (bool, error) {
	obj.SetTaskDefinition(meta.GetExternalName(cr))

	if err := obj.Validate(); err != nil {
		return false, err
	}
	return false, nil
}

// Helper func to copy CustomVolume types into AWS SDK types
// Mostly copied from the autogenerated conversion code before
// ignoring the API in generator-config.yaml
func generateVolumes(cr *svcapitypes.TaskDefinition) []*svcsdk.Volume { //nolint:gocyclo
	volumes := []*svcsdk.Volume{}

	if cr.Spec.ForProvider.Volumes == nil {
		return volumes
	}

	for _, volumesiter := range cr.Spec.ForProvider.Volumes {
		volumeselem := &svcsdk.Volume{}
		if volumesiter.DockerVolumeConfiguration != nil {
			volumeselemf0 := &svcsdk.DockerVolumeConfiguration{}
			if volumesiter.DockerVolumeConfiguration.Autoprovision != nil {
				volumeselemf0.SetAutoprovision(*volumesiter.DockerVolumeConfiguration.Autoprovision)
			}
			if volumesiter.DockerVolumeConfiguration.Driver != nil {
				volumeselemf0.SetDriver(*volumesiter.DockerVolumeConfiguration.Driver)
			}
			if volumesiter.DockerVolumeConfiguration.DriverOpts != nil {
				volumeselemf0f2 := map[string]*string{}
				for volumeselemf0f2key, volumeselemf0f2valiter := range volumesiter.DockerVolumeConfiguration.DriverOpts {
					volumeselemf0f2val := *volumeselemf0f2valiter
					volumeselemf0f2[volumeselemf0f2key] = &volumeselemf0f2val
				}
				volumeselemf0.SetDriverOpts(volumeselemf0f2)
			}
			if volumesiter.DockerVolumeConfiguration.Labels != nil {
				volumeselemf0f3 := map[string]*string{}
				for volumeselemf0f3key, volumeselemf0f3valiter := range volumesiter.DockerVolumeConfiguration.Labels {
					volumeselemf0f3val := *volumeselemf0f3valiter
					volumeselemf0f3[volumeselemf0f3key] = &volumeselemf0f3val
				}
				volumeselemf0.SetLabels(volumeselemf0f3)
			}
			if volumesiter.DockerVolumeConfiguration.Scope != nil {
				volumeselemf0.SetScope(*volumesiter.DockerVolumeConfiguration.Scope)
			}
			volumeselem.SetDockerVolumeConfiguration(volumeselemf0)
		}
		if volumesiter.EFSVolumeConfiguration != nil {
			volumeselemf1 := &svcsdk.EFSVolumeConfiguration{}
			if volumesiter.EFSVolumeConfiguration.AuthorizationConfig != nil {
				volumeselemf1f0 := &svcsdk.EFSAuthorizationConfig{}
				if volumesiter.EFSVolumeConfiguration.AuthorizationConfig.AccessPointID != nil {
					volumeselemf1f0.SetAccessPointId(*volumesiter.EFSVolumeConfiguration.AuthorizationConfig.AccessPointID)
				}
				if volumesiter.EFSVolumeConfiguration.AuthorizationConfig.IAM != nil {
					volumeselemf1f0.SetIam(*volumesiter.EFSVolumeConfiguration.AuthorizationConfig.IAM)
				}
				volumeselemf1.SetAuthorizationConfig(volumeselemf1f0)
			}
			if volumesiter.EFSVolumeConfiguration.FileSystemID != nil {
				volumeselemf1.SetFileSystemId(*volumesiter.EFSVolumeConfiguration.FileSystemID)
			}
			if volumesiter.EFSVolumeConfiguration.RootDirectory != nil {
				volumeselemf1.SetRootDirectory(*volumesiter.EFSVolumeConfiguration.RootDirectory)
			}
			if volumesiter.EFSVolumeConfiguration.TransitEncryption != nil {
				volumeselemf1.SetTransitEncryption(*volumesiter.EFSVolumeConfiguration.TransitEncryption)
			}
			if volumesiter.EFSVolumeConfiguration.TransitEncryptionPort != nil {
				volumeselemf1.SetTransitEncryptionPort(*volumesiter.EFSVolumeConfiguration.TransitEncryptionPort)
			}
			volumeselem.SetEfsVolumeConfiguration(volumeselemf1)
		}
		if volumesiter.FsxWindowsFileServerVolumeConfiguration != nil {
			volumeselemf2 := &svcsdk.FSxWindowsFileServerVolumeConfiguration{}
			if volumesiter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig != nil {
				volumeselemf2f0 := &svcsdk.FSxWindowsFileServerAuthorizationConfig{}
				if volumesiter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter != nil {
					volumeselemf2f0.SetCredentialsParameter(*volumesiter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.CredentialsParameter)
				}
				if volumesiter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain != nil {
					volumeselemf2f0.SetDomain(*volumesiter.FsxWindowsFileServerVolumeConfiguration.AuthorizationConfig.Domain)
				}
				volumeselemf2.SetAuthorizationConfig(volumeselemf2f0)
			}
			if volumesiter.FsxWindowsFileServerVolumeConfiguration.FileSystemID != nil {
				volumeselemf2.SetFileSystemId(*volumesiter.FsxWindowsFileServerVolumeConfiguration.FileSystemID)
			}
			if volumesiter.FsxWindowsFileServerVolumeConfiguration.RootDirectory != nil {
				volumeselemf2.SetRootDirectory(*volumesiter.FsxWindowsFileServerVolumeConfiguration.RootDirectory)
			}
			volumeselem.SetFsxWindowsFileServerVolumeConfiguration(volumeselemf2)
		}
		if volumesiter.Host != nil {
			volumeselemf3 := &svcsdk.HostVolumeProperties{}
			if volumesiter.Host.SourcePath != nil {
				volumeselemf3.SetSourcePath(*volumesiter.Host.SourcePath)
			}
			volumeselem.SetHost(volumeselemf3)
		}
		if volumesiter.Name != nil {
			volumeselem.SetName(*volumesiter.Name)
		}
		volumes = append(volumes, volumeselem)
	}
	return volumes
}
