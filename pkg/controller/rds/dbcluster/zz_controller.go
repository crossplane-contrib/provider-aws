/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by ack-generate. DO NOT EDIT.

package dbcluster

import (
	"context"

	svcapi "github.com/aws/aws-sdk-go/service/rds"
	svcsdk "github.com/aws/aws-sdk-go/service/rds"
	svcsdkapi "github.com/aws/aws-sdk-go/service/rds/rdsiface"
	"github.com/google/go-cmp/cmp"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/meta"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	cpresource "github.com/crossplane/crossplane-runtime/pkg/resource"

	svcapitypes "github.com/crossplane-contrib/provider-aws/apis/rds/v1alpha1"
	connectaws "github.com/crossplane-contrib/provider-aws/pkg/utils/connect/aws"
	errorutils "github.com/crossplane-contrib/provider-aws/pkg/utils/errors"
)

const (
	errUnexpectedObject = "managed resource is not an DBCluster resource"

	errCreateSession = "cannot create a new session"
	errCreate        = "cannot create DBCluster in AWS"
	errUpdate        = "cannot update DBCluster in AWS"
	errDescribe      = "failed to describe DBCluster"
	errDelete        = "failed to delete DBCluster"
)

type connector struct {
	kube client.Client
	opts []option
}

func (c *connector) Connect(ctx context.Context, cr *svcapitypes.DBCluster) (managed.TypedExternalClient[*svcapitypes.DBCluster], error) {
	sess, err := connectaws.GetConfigV1(ctx, c.kube, cr, cr.Spec.ForProvider.Region)
	if err != nil {
		return nil, errors.Wrap(err, errCreateSession)
	}
	return newExternal(c.kube, svcapi.New(sess), c.opts), nil
}

func (e *external) Observe(ctx context.Context, cr *svcapitypes.DBCluster) (managed.ExternalObservation, error) {
	if meta.GetExternalName(cr) == "" {
		return managed.ExternalObservation{
			ResourceExists: false,
		}, nil
	}
	input := GenerateDescribeDBClustersInput(cr)
	if err := e.preObserve(ctx, cr, input); err != nil {
		return managed.ExternalObservation{}, errors.Wrap(err, "pre-observe failed")
	}
	resp, err := e.client.DescribeDBClustersWithContext(ctx, input)
	if err != nil {
		return managed.ExternalObservation{ResourceExists: false}, errorutils.Wrap(cpresource.Ignore(IsNotFound, err), errDescribe)
	}
	resp = e.filterList(cr, resp)
	if len(resp.DBClusters) == 0 {
		return managed.ExternalObservation{ResourceExists: false}, nil
	}
	currentSpec := cr.Spec.ForProvider.DeepCopy()
	if err := e.lateInitialize(&cr.Spec.ForProvider, resp); err != nil {
		return managed.ExternalObservation{}, errors.Wrap(err, "late-init failed")
	}
	GenerateDBCluster(resp).Status.AtProvider.DeepCopyInto(&cr.Status.AtProvider)
	upToDate := true
	diff := ""
	if !meta.WasDeleted(cr) { // There is no need to run isUpToDate if the resource is deleted
		upToDate, diff, err = e.isUpToDate(ctx, cr, resp)
		if err != nil {
			return managed.ExternalObservation{}, errors.Wrap(err, "isUpToDate check failed")
		}
	}
	return e.postObserve(ctx, cr, resp, managed.ExternalObservation{
		ResourceExists:          true,
		ResourceUpToDate:        upToDate,
		Diff:                    diff,
		ResourceLateInitialized: !cmp.Equal(&cr.Spec.ForProvider, currentSpec),
	}, nil)
}

func (e *external) Create(ctx context.Context, cr *svcapitypes.DBCluster) (managed.ExternalCreation, error) {
	cr.Status.SetConditions(xpv1.Creating())
	input := GenerateCreateDBClusterInput(cr)
	if err := e.preCreate(ctx, cr, input); err != nil {
		return managed.ExternalCreation{}, errors.Wrap(err, "pre-create failed")
	}
	resp, err := e.client.CreateDBClusterWithContext(ctx, input)
	if err != nil {
		return managed.ExternalCreation{}, errorutils.Wrap(err, errCreate)
	}

	if resp.DBCluster.ActivityStreamKinesisStreamName != nil {
		cr.Status.AtProvider.ActivityStreamKinesisStreamName = resp.DBCluster.ActivityStreamKinesisStreamName
	} else {
		cr.Status.AtProvider.ActivityStreamKinesisStreamName = nil
	}
	if resp.DBCluster.ActivityStreamKmsKeyId != nil {
		cr.Status.AtProvider.ActivityStreamKMSKeyID = resp.DBCluster.ActivityStreamKmsKeyId
	} else {
		cr.Status.AtProvider.ActivityStreamKMSKeyID = nil
	}
	if resp.DBCluster.ActivityStreamMode != nil {
		cr.Status.AtProvider.ActivityStreamMode = resp.DBCluster.ActivityStreamMode
	} else {
		cr.Status.AtProvider.ActivityStreamMode = nil
	}
	if resp.DBCluster.ActivityStreamStatus != nil {
		cr.Status.AtProvider.ActivityStreamStatus = resp.DBCluster.ActivityStreamStatus
	} else {
		cr.Status.AtProvider.ActivityStreamStatus = nil
	}
	if resp.DBCluster.AllocatedStorage != nil {
		cr.Spec.ForProvider.AllocatedStorage = resp.DBCluster.AllocatedStorage
	} else {
		cr.Spec.ForProvider.AllocatedStorage = nil
	}
	if resp.DBCluster.AssociatedRoles != nil {
		f5 := []*svcapitypes.DBClusterRole{}
		for _, f5iter := range resp.DBCluster.AssociatedRoles {
			f5elem := &svcapitypes.DBClusterRole{}
			if f5iter.FeatureName != nil {
				f5elem.FeatureName = f5iter.FeatureName
			}
			if f5iter.RoleArn != nil {
				f5elem.RoleARN = f5iter.RoleArn
			}
			if f5iter.Status != nil {
				f5elem.Status = f5iter.Status
			}
			f5 = append(f5, f5elem)
		}
		cr.Status.AtProvider.AssociatedRoles = f5
	} else {
		cr.Status.AtProvider.AssociatedRoles = nil
	}
	if resp.DBCluster.AutoMinorVersionUpgrade != nil {
		cr.Spec.ForProvider.AutoMinorVersionUpgrade = resp.DBCluster.AutoMinorVersionUpgrade
	} else {
		cr.Spec.ForProvider.AutoMinorVersionUpgrade = nil
	}
	if resp.DBCluster.AutomaticRestartTime != nil {
		cr.Status.AtProvider.AutomaticRestartTime = &metav1.Time{*resp.DBCluster.AutomaticRestartTime}
	} else {
		cr.Status.AtProvider.AutomaticRestartTime = nil
	}
	if resp.DBCluster.AvailabilityZones != nil {
		f8 := []*string{}
		for _, f8iter := range resp.DBCluster.AvailabilityZones {
			var f8elem string
			f8elem = *f8iter
			f8 = append(f8, &f8elem)
		}
		cr.Spec.ForProvider.AvailabilityZones = f8
	} else {
		cr.Spec.ForProvider.AvailabilityZones = nil
	}
	if resp.DBCluster.AwsBackupRecoveryPointArn != nil {
		cr.Status.AtProvider.AWSBackupRecoveryPointARN = resp.DBCluster.AwsBackupRecoveryPointArn
	} else {
		cr.Status.AtProvider.AWSBackupRecoveryPointARN = nil
	}
	if resp.DBCluster.BacktrackConsumedChangeRecords != nil {
		cr.Status.AtProvider.BacktrackConsumedChangeRecords = resp.DBCluster.BacktrackConsumedChangeRecords
	} else {
		cr.Status.AtProvider.BacktrackConsumedChangeRecords = nil
	}
	if resp.DBCluster.BacktrackWindow != nil {
		cr.Spec.ForProvider.BacktrackWindow = resp.DBCluster.BacktrackWindow
	} else {
		cr.Spec.ForProvider.BacktrackWindow = nil
	}
	if resp.DBCluster.BackupRetentionPeriod != nil {
		cr.Spec.ForProvider.BackupRetentionPeriod = resp.DBCluster.BackupRetentionPeriod
	} else {
		cr.Spec.ForProvider.BackupRetentionPeriod = nil
	}
	if resp.DBCluster.Capacity != nil {
		cr.Status.AtProvider.Capacity = resp.DBCluster.Capacity
	} else {
		cr.Status.AtProvider.Capacity = nil
	}
	if resp.DBCluster.CharacterSetName != nil {
		cr.Spec.ForProvider.CharacterSetName = resp.DBCluster.CharacterSetName
	} else {
		cr.Spec.ForProvider.CharacterSetName = nil
	}
	if resp.DBCluster.CloneGroupId != nil {
		cr.Status.AtProvider.CloneGroupID = resp.DBCluster.CloneGroupId
	} else {
		cr.Status.AtProvider.CloneGroupID = nil
	}
	if resp.DBCluster.ClusterCreateTime != nil {
		cr.Status.AtProvider.ClusterCreateTime = &metav1.Time{*resp.DBCluster.ClusterCreateTime}
	} else {
		cr.Status.AtProvider.ClusterCreateTime = nil
	}
	if resp.DBCluster.CopyTagsToSnapshot != nil {
		cr.Spec.ForProvider.CopyTagsToSnapshot = resp.DBCluster.CopyTagsToSnapshot
	} else {
		cr.Spec.ForProvider.CopyTagsToSnapshot = nil
	}
	if resp.DBCluster.CrossAccountClone != nil {
		cr.Status.AtProvider.CrossAccountClone = resp.DBCluster.CrossAccountClone
	} else {
		cr.Status.AtProvider.CrossAccountClone = nil
	}
	if resp.DBCluster.CustomEndpoints != nil {
		f19 := []*string{}
		for _, f19iter := range resp.DBCluster.CustomEndpoints {
			var f19elem string
			f19elem = *f19iter
			f19 = append(f19, &f19elem)
		}
		cr.Status.AtProvider.CustomEndpoints = f19
	} else {
		cr.Status.AtProvider.CustomEndpoints = nil
	}
	if resp.DBCluster.DBClusterArn != nil {
		cr.Status.AtProvider.DBClusterARN = resp.DBCluster.DBClusterArn
	} else {
		cr.Status.AtProvider.DBClusterARN = nil
	}
	if resp.DBCluster.DBClusterIdentifier != nil {
		cr.Status.AtProvider.DBClusterIdentifier = resp.DBCluster.DBClusterIdentifier
	} else {
		cr.Status.AtProvider.DBClusterIdentifier = nil
	}
	if resp.DBCluster.DBClusterInstanceClass != nil {
		cr.Spec.ForProvider.DBClusterInstanceClass = resp.DBCluster.DBClusterInstanceClass
	} else {
		cr.Spec.ForProvider.DBClusterInstanceClass = nil
	}
	if resp.DBCluster.DBClusterMembers != nil {
		f23 := []*svcapitypes.DBClusterMember{}
		for _, f23iter := range resp.DBCluster.DBClusterMembers {
			f23elem := &svcapitypes.DBClusterMember{}
			if f23iter.DBClusterParameterGroupStatus != nil {
				f23elem.DBClusterParameterGroupStatus = f23iter.DBClusterParameterGroupStatus
			}
			if f23iter.DBInstanceIdentifier != nil {
				f23elem.DBInstanceIdentifier = f23iter.DBInstanceIdentifier
			}
			if f23iter.IsClusterWriter != nil {
				f23elem.IsClusterWriter = f23iter.IsClusterWriter
			}
			if f23iter.PromotionTier != nil {
				f23elem.PromotionTier = f23iter.PromotionTier
			}
			f23 = append(f23, f23elem)
		}
		cr.Status.AtProvider.DBClusterMembers = f23
	} else {
		cr.Status.AtProvider.DBClusterMembers = nil
	}
	if resp.DBCluster.DBClusterOptionGroupMemberships != nil {
		f24 := []*svcapitypes.DBClusterOptionGroupStatus{}
		for _, f24iter := range resp.DBCluster.DBClusterOptionGroupMemberships {
			f24elem := &svcapitypes.DBClusterOptionGroupStatus{}
			if f24iter.DBClusterOptionGroupName != nil {
				f24elem.DBClusterOptionGroupName = f24iter.DBClusterOptionGroupName
			}
			if f24iter.Status != nil {
				f24elem.Status = f24iter.Status
			}
			f24 = append(f24, f24elem)
		}
		cr.Status.AtProvider.DBClusterOptionGroupMemberships = f24
	} else {
		cr.Status.AtProvider.DBClusterOptionGroupMemberships = nil
	}
	if resp.DBCluster.DBClusterParameterGroup != nil {
		cr.Status.AtProvider.DBClusterParameterGroup = resp.DBCluster.DBClusterParameterGroup
	} else {
		cr.Status.AtProvider.DBClusterParameterGroup = nil
	}
	if resp.DBCluster.DBSubnetGroup != nil {
		cr.Status.AtProvider.DBSubnetGroup = resp.DBCluster.DBSubnetGroup
	} else {
		cr.Status.AtProvider.DBSubnetGroup = nil
	}
	if resp.DBCluster.DBSystemId != nil {
		cr.Spec.ForProvider.DBSystemID = resp.DBCluster.DBSystemId
	} else {
		cr.Spec.ForProvider.DBSystemID = nil
	}
	if resp.DBCluster.DatabaseName != nil {
		cr.Spec.ForProvider.DatabaseName = resp.DBCluster.DatabaseName
	} else {
		cr.Spec.ForProvider.DatabaseName = nil
	}
	if resp.DBCluster.DbClusterResourceId != nil {
		cr.Status.AtProvider.DBClusterResourceID = resp.DBCluster.DbClusterResourceId
	} else {
		cr.Status.AtProvider.DBClusterResourceID = nil
	}
	if resp.DBCluster.DeletionProtection != nil {
		cr.Spec.ForProvider.DeletionProtection = resp.DBCluster.DeletionProtection
	} else {
		cr.Spec.ForProvider.DeletionProtection = nil
	}
	if resp.DBCluster.DomainMemberships != nil {
		f31 := []*svcapitypes.DomainMembership{}
		for _, f31iter := range resp.DBCluster.DomainMemberships {
			f31elem := &svcapitypes.DomainMembership{}
			if f31iter.AuthSecretArn != nil {
				f31elem.AuthSecretARN = f31iter.AuthSecretArn
			}
			if f31iter.DnsIps != nil {
				f31elemf1 := []*string{}
				for _, f31elemf1iter := range f31iter.DnsIps {
					var f31elemf1elem string
					f31elemf1elem = *f31elemf1iter
					f31elemf1 = append(f31elemf1, &f31elemf1elem)
				}
				f31elem.DNSIPs = f31elemf1
			}
			if f31iter.Domain != nil {
				f31elem.Domain = f31iter.Domain
			}
			if f31iter.FQDN != nil {
				f31elem.FQDN = f31iter.FQDN
			}
			if f31iter.IAMRoleName != nil {
				f31elem.IAMRoleName = f31iter.IAMRoleName
			}
			if f31iter.OU != nil {
				f31elem.OU = f31iter.OU
			}
			if f31iter.Status != nil {
				f31elem.Status = f31iter.Status
			}
			f31 = append(f31, f31elem)
		}
		cr.Status.AtProvider.DomainMemberships = f31
	} else {
		cr.Status.AtProvider.DomainMemberships = nil
	}
	if resp.DBCluster.EarliestBacktrackTime != nil {
		cr.Status.AtProvider.EarliestBacktrackTime = &metav1.Time{*resp.DBCluster.EarliestBacktrackTime}
	} else {
		cr.Status.AtProvider.EarliestBacktrackTime = nil
	}
	if resp.DBCluster.EarliestRestorableTime != nil {
		cr.Status.AtProvider.EarliestRestorableTime = &metav1.Time{*resp.DBCluster.EarliestRestorableTime}
	} else {
		cr.Status.AtProvider.EarliestRestorableTime = nil
	}
	if resp.DBCluster.EnabledCloudwatchLogsExports != nil {
		f34 := []*string{}
		for _, f34iter := range resp.DBCluster.EnabledCloudwatchLogsExports {
			var f34elem string
			f34elem = *f34iter
			f34 = append(f34, &f34elem)
		}
		cr.Status.AtProvider.EnabledCloudwatchLogsExports = f34
	} else {
		cr.Status.AtProvider.EnabledCloudwatchLogsExports = nil
	}
	if resp.DBCluster.Endpoint != nil {
		cr.Status.AtProvider.Endpoint = resp.DBCluster.Endpoint
	} else {
		cr.Status.AtProvider.Endpoint = nil
	}
	if resp.DBCluster.Engine != nil {
		cr.Spec.ForProvider.Engine = resp.DBCluster.Engine
	} else {
		cr.Spec.ForProvider.Engine = nil
	}
	if resp.DBCluster.EngineMode != nil {
		cr.Spec.ForProvider.EngineMode = resp.DBCluster.EngineMode
	} else {
		cr.Spec.ForProvider.EngineMode = nil
	}
	if resp.DBCluster.EngineVersion != nil {
		cr.Status.AtProvider.EngineVersion = resp.DBCluster.EngineVersion
	} else {
		cr.Status.AtProvider.EngineVersion = nil
	}
	if resp.DBCluster.GlobalWriteForwardingRequested != nil {
		cr.Status.AtProvider.GlobalWriteForwardingRequested = resp.DBCluster.GlobalWriteForwardingRequested
	} else {
		cr.Status.AtProvider.GlobalWriteForwardingRequested = nil
	}
	if resp.DBCluster.GlobalWriteForwardingStatus != nil {
		cr.Status.AtProvider.GlobalWriteForwardingStatus = resp.DBCluster.GlobalWriteForwardingStatus
	} else {
		cr.Status.AtProvider.GlobalWriteForwardingStatus = nil
	}
	if resp.DBCluster.HostedZoneId != nil {
		cr.Status.AtProvider.HostedZoneID = resp.DBCluster.HostedZoneId
	} else {
		cr.Status.AtProvider.HostedZoneID = nil
	}
	if resp.DBCluster.HttpEndpointEnabled != nil {
		cr.Status.AtProvider.HTTPEndpointEnabled = resp.DBCluster.HttpEndpointEnabled
	} else {
		cr.Status.AtProvider.HTTPEndpointEnabled = nil
	}
	if resp.DBCluster.IAMDatabaseAuthenticationEnabled != nil {
		cr.Status.AtProvider.IAMDatabaseAuthenticationEnabled = resp.DBCluster.IAMDatabaseAuthenticationEnabled
	} else {
		cr.Status.AtProvider.IAMDatabaseAuthenticationEnabled = nil
	}
	if resp.DBCluster.IOOptimizedNextAllowedModificationTime != nil {
		cr.Status.AtProvider.IOOptimizedNextAllowedModificationTime = &metav1.Time{*resp.DBCluster.IOOptimizedNextAllowedModificationTime}
	} else {
		cr.Status.AtProvider.IOOptimizedNextAllowedModificationTime = nil
	}
	if resp.DBCluster.Iops != nil {
		cr.Spec.ForProvider.IOPS = resp.DBCluster.Iops
	} else {
		cr.Spec.ForProvider.IOPS = nil
	}
	if resp.DBCluster.KmsKeyId != nil {
		cr.Spec.ForProvider.KMSKeyID = resp.DBCluster.KmsKeyId
	} else {
		cr.Spec.ForProvider.KMSKeyID = nil
	}
	if resp.DBCluster.LatestRestorableTime != nil {
		cr.Status.AtProvider.LatestRestorableTime = &metav1.Time{*resp.DBCluster.LatestRestorableTime}
	} else {
		cr.Status.AtProvider.LatestRestorableTime = nil
	}
	if resp.DBCluster.LocalWriteForwardingStatus != nil {
		cr.Status.AtProvider.LocalWriteForwardingStatus = resp.DBCluster.LocalWriteForwardingStatus
	} else {
		cr.Status.AtProvider.LocalWriteForwardingStatus = nil
	}
	if resp.DBCluster.MasterUserSecret != nil {
		f49 := &svcapitypes.MasterUserSecret{}
		if resp.DBCluster.MasterUserSecret.KmsKeyId != nil {
			f49.KMSKeyID = resp.DBCluster.MasterUserSecret.KmsKeyId
		}
		if resp.DBCluster.MasterUserSecret.SecretArn != nil {
			f49.SecretARN = resp.DBCluster.MasterUserSecret.SecretArn
		}
		if resp.DBCluster.MasterUserSecret.SecretStatus != nil {
			f49.SecretStatus = resp.DBCluster.MasterUserSecret.SecretStatus
		}
		cr.Status.AtProvider.MasterUserSecret = f49
	} else {
		cr.Status.AtProvider.MasterUserSecret = nil
	}
	if resp.DBCluster.MasterUsername != nil {
		cr.Spec.ForProvider.MasterUsername = resp.DBCluster.MasterUsername
	} else {
		cr.Spec.ForProvider.MasterUsername = nil
	}
	if resp.DBCluster.MonitoringInterval != nil {
		cr.Spec.ForProvider.MonitoringInterval = resp.DBCluster.MonitoringInterval
	} else {
		cr.Spec.ForProvider.MonitoringInterval = nil
	}
	if resp.DBCluster.MonitoringRoleArn != nil {
		cr.Spec.ForProvider.MonitoringRoleARN = resp.DBCluster.MonitoringRoleArn
	} else {
		cr.Spec.ForProvider.MonitoringRoleARN = nil
	}
	if resp.DBCluster.MultiAZ != nil {
		cr.Status.AtProvider.MultiAZ = resp.DBCluster.MultiAZ
	} else {
		cr.Status.AtProvider.MultiAZ = nil
	}
	if resp.DBCluster.NetworkType != nil {
		cr.Spec.ForProvider.NetworkType = resp.DBCluster.NetworkType
	} else {
		cr.Spec.ForProvider.NetworkType = nil
	}
	if resp.DBCluster.PercentProgress != nil {
		cr.Status.AtProvider.PercentProgress = resp.DBCluster.PercentProgress
	} else {
		cr.Status.AtProvider.PercentProgress = nil
	}
	if resp.DBCluster.PerformanceInsightsEnabled != nil {
		cr.Status.AtProvider.PerformanceInsightsEnabled = resp.DBCluster.PerformanceInsightsEnabled
	} else {
		cr.Status.AtProvider.PerformanceInsightsEnabled = nil
	}
	if resp.DBCluster.PerformanceInsightsKMSKeyId != nil {
		cr.Spec.ForProvider.PerformanceInsightsKMSKeyID = resp.DBCluster.PerformanceInsightsKMSKeyId
	} else {
		cr.Spec.ForProvider.PerformanceInsightsKMSKeyID = nil
	}
	if resp.DBCluster.PerformanceInsightsRetentionPeriod != nil {
		cr.Spec.ForProvider.PerformanceInsightsRetentionPeriod = resp.DBCluster.PerformanceInsightsRetentionPeriod
	} else {
		cr.Spec.ForProvider.PerformanceInsightsRetentionPeriod = nil
	}
	if resp.DBCluster.Port != nil {
		cr.Spec.ForProvider.Port = resp.DBCluster.Port
	} else {
		cr.Spec.ForProvider.Port = nil
	}
	if resp.DBCluster.PreferredBackupWindow != nil {
		cr.Spec.ForProvider.PreferredBackupWindow = resp.DBCluster.PreferredBackupWindow
	} else {
		cr.Spec.ForProvider.PreferredBackupWindow = nil
	}
	if resp.DBCluster.PreferredMaintenanceWindow != nil {
		cr.Spec.ForProvider.PreferredMaintenanceWindow = resp.DBCluster.PreferredMaintenanceWindow
	} else {
		cr.Spec.ForProvider.PreferredMaintenanceWindow = nil
	}
	if resp.DBCluster.PubliclyAccessible != nil {
		cr.Spec.ForProvider.PubliclyAccessible = resp.DBCluster.PubliclyAccessible
	} else {
		cr.Spec.ForProvider.PubliclyAccessible = nil
	}
	if resp.DBCluster.RdsCustomClusterConfiguration != nil {
		f63 := &svcapitypes.RdsCustomClusterConfiguration{}
		if resp.DBCluster.RdsCustomClusterConfiguration.InterconnectSubnetId != nil {
			f63.InterconnectSubnetID = resp.DBCluster.RdsCustomClusterConfiguration.InterconnectSubnetId
		}
		if resp.DBCluster.RdsCustomClusterConfiguration.ReplicaMode != nil {
			f63.ReplicaMode = resp.DBCluster.RdsCustomClusterConfiguration.ReplicaMode
		}
		if resp.DBCluster.RdsCustomClusterConfiguration.TransitGatewayMulticastDomainId != nil {
			f63.TransitGatewayMulticastDomainID = resp.DBCluster.RdsCustomClusterConfiguration.TransitGatewayMulticastDomainId
		}
		cr.Spec.ForProvider.RdsCustomClusterConfiguration = f63
	} else {
		cr.Spec.ForProvider.RdsCustomClusterConfiguration = nil
	}
	if resp.DBCluster.ReadReplicaIdentifiers != nil {
		f64 := []*string{}
		for _, f64iter := range resp.DBCluster.ReadReplicaIdentifiers {
			var f64elem string
			f64elem = *f64iter
			f64 = append(f64, &f64elem)
		}
		cr.Status.AtProvider.ReadReplicaIdentifiers = f64
	} else {
		cr.Status.AtProvider.ReadReplicaIdentifiers = nil
	}
	if resp.DBCluster.ReaderEndpoint != nil {
		cr.Status.AtProvider.ReaderEndpoint = resp.DBCluster.ReaderEndpoint
	} else {
		cr.Status.AtProvider.ReaderEndpoint = nil
	}
	if resp.DBCluster.ReplicationSourceIdentifier != nil {
		cr.Spec.ForProvider.ReplicationSourceIdentifier = resp.DBCluster.ReplicationSourceIdentifier
	} else {
		cr.Spec.ForProvider.ReplicationSourceIdentifier = nil
	}
	if resp.DBCluster.ScalingConfigurationInfo != nil {
		f67 := &svcapitypes.ScalingConfigurationInfo{}
		if resp.DBCluster.ScalingConfigurationInfo.AutoPause != nil {
			f67.AutoPause = resp.DBCluster.ScalingConfigurationInfo.AutoPause
		}
		if resp.DBCluster.ScalingConfigurationInfo.MaxCapacity != nil {
			f67.MaxCapacity = resp.DBCluster.ScalingConfigurationInfo.MaxCapacity
		}
		if resp.DBCluster.ScalingConfigurationInfo.MinCapacity != nil {
			f67.MinCapacity = resp.DBCluster.ScalingConfigurationInfo.MinCapacity
		}
		if resp.DBCluster.ScalingConfigurationInfo.SecondsBeforeTimeout != nil {
			f67.SecondsBeforeTimeout = resp.DBCluster.ScalingConfigurationInfo.SecondsBeforeTimeout
		}
		if resp.DBCluster.ScalingConfigurationInfo.SecondsUntilAutoPause != nil {
			f67.SecondsUntilAutoPause = resp.DBCluster.ScalingConfigurationInfo.SecondsUntilAutoPause
		}
		if resp.DBCluster.ScalingConfigurationInfo.TimeoutAction != nil {
			f67.TimeoutAction = resp.DBCluster.ScalingConfigurationInfo.TimeoutAction
		}
		cr.Status.AtProvider.ScalingConfigurationInfo = f67
	} else {
		cr.Status.AtProvider.ScalingConfigurationInfo = nil
	}
	if resp.DBCluster.ServerlessV2ScalingConfiguration != nil {
		f68 := &svcapitypes.ServerlessV2ScalingConfiguration{}
		if resp.DBCluster.ServerlessV2ScalingConfiguration.MaxCapacity != nil {
			f68.MaxCapacity = resp.DBCluster.ServerlessV2ScalingConfiguration.MaxCapacity
		}
		if resp.DBCluster.ServerlessV2ScalingConfiguration.MinCapacity != nil {
			f68.MinCapacity = resp.DBCluster.ServerlessV2ScalingConfiguration.MinCapacity
		}
		cr.Spec.ForProvider.ServerlessV2ScalingConfiguration = f68
	} else {
		cr.Spec.ForProvider.ServerlessV2ScalingConfiguration = nil
	}
	if resp.DBCluster.Status != nil {
		cr.Status.AtProvider.Status = resp.DBCluster.Status
	} else {
		cr.Status.AtProvider.Status = nil
	}
	if resp.DBCluster.StatusInfos != nil {
		f70 := []*svcapitypes.DBClusterStatusInfo{}
		for _, f70iter := range resp.DBCluster.StatusInfos {
			f70elem := &svcapitypes.DBClusterStatusInfo{}
			if f70iter.Message != nil {
				f70elem.Message = f70iter.Message
			}
			if f70iter.Normal != nil {
				f70elem.Normal = f70iter.Normal
			}
			if f70iter.Status != nil {
				f70elem.Status = f70iter.Status
			}
			if f70iter.StatusType != nil {
				f70elem.StatusType = f70iter.StatusType
			}
			f70 = append(f70, f70elem)
		}
		cr.Status.AtProvider.StatusInfos = f70
	} else {
		cr.Status.AtProvider.StatusInfos = nil
	}
	if resp.DBCluster.StorageEncrypted != nil {
		cr.Spec.ForProvider.StorageEncrypted = resp.DBCluster.StorageEncrypted
	} else {
		cr.Spec.ForProvider.StorageEncrypted = nil
	}
	if resp.DBCluster.StorageType != nil {
		cr.Spec.ForProvider.StorageType = resp.DBCluster.StorageType
	} else {
		cr.Spec.ForProvider.StorageType = nil
	}
	if resp.DBCluster.TagList != nil {
		f73 := []*svcapitypes.Tag{}
		for _, f73iter := range resp.DBCluster.TagList {
			f73elem := &svcapitypes.Tag{}
			if f73iter.Key != nil {
				f73elem.Key = f73iter.Key
			}
			if f73iter.Value != nil {
				f73elem.Value = f73iter.Value
			}
			f73 = append(f73, f73elem)
		}
		cr.Status.AtProvider.TagList = f73
	} else {
		cr.Status.AtProvider.TagList = nil
	}
	if resp.DBCluster.VpcSecurityGroups != nil {
		f74 := []*svcapitypes.VPCSecurityGroupMembership{}
		for _, f74iter := range resp.DBCluster.VpcSecurityGroups {
			f74elem := &svcapitypes.VPCSecurityGroupMembership{}
			if f74iter.Status != nil {
				f74elem.Status = f74iter.Status
			}
			if f74iter.VpcSecurityGroupId != nil {
				f74elem.VPCSecurityGroupID = f74iter.VpcSecurityGroupId
			}
			f74 = append(f74, f74elem)
		}
		cr.Status.AtProvider.VPCSecurityGroups = f74
	} else {
		cr.Status.AtProvider.VPCSecurityGroups = nil
	}

	return e.postCreate(ctx, cr, resp, managed.ExternalCreation{}, err)
}

func (e *external) Update(ctx context.Context, cr *svcapitypes.DBCluster) (managed.ExternalUpdate, error) {
	input := GenerateModifyDBClusterInput(cr)
	if err := e.preUpdate(ctx, cr, input); err != nil {
		return managed.ExternalUpdate{}, errors.Wrap(err, "pre-update failed")
	}
	resp, err := e.client.ModifyDBClusterWithContext(ctx, input)
	return e.postUpdate(ctx, cr, resp, managed.ExternalUpdate{}, errorutils.Wrap(err, errUpdate))
}

func (e *external) Delete(ctx context.Context, cr *svcapitypes.DBCluster) (managed.ExternalDelete, error) {
	cr.Status.SetConditions(xpv1.Deleting())
	input := GenerateDeleteDBClusterInput(cr)
	ignore, err := e.preDelete(ctx, cr, input)
	if err != nil {
		return managed.ExternalDelete{}, errors.Wrap(err, "pre-delete failed")
	}
	if ignore {
		return managed.ExternalDelete{}, nil
	}
	resp, err := e.client.DeleteDBClusterWithContext(ctx, input)
	return e.postDelete(ctx, cr, resp, errorutils.Wrap(cpresource.Ignore(IsNotFound, err), errDelete))
}

func (e *external) Disconnect(ctx context.Context) error {
	// Unimplemented, required by newer versions of crossplane-runtime
	return nil
}

type option func(*external)

func newExternal(kube client.Client, client svcsdkapi.RDSAPI, opts []option) *external {
	e := &external{
		kube:           kube,
		client:         client,
		preObserve:     nopPreObserve,
		postObserve:    nopPostObserve,
		lateInitialize: nopLateInitialize,
		isUpToDate:     alwaysUpToDate,
		filterList:     nopFilterList,
		preCreate:      nopPreCreate,
		postCreate:     nopPostCreate,
		preDelete:      nopPreDelete,
		postDelete:     nopPostDelete,
		preUpdate:      nopPreUpdate,
		postUpdate:     nopPostUpdate,
	}
	for _, f := range opts {
		f(e)
	}
	return e
}

type external struct {
	kube           client.Client
	client         svcsdkapi.RDSAPI
	preObserve     func(context.Context, *svcapitypes.DBCluster, *svcsdk.DescribeDBClustersInput) error
	postObserve    func(context.Context, *svcapitypes.DBCluster, *svcsdk.DescribeDBClustersOutput, managed.ExternalObservation, error) (managed.ExternalObservation, error)
	filterList     func(*svcapitypes.DBCluster, *svcsdk.DescribeDBClustersOutput) *svcsdk.DescribeDBClustersOutput
	lateInitialize func(*svcapitypes.DBClusterParameters, *svcsdk.DescribeDBClustersOutput) error
	isUpToDate     func(context.Context, *svcapitypes.DBCluster, *svcsdk.DescribeDBClustersOutput) (bool, string, error)
	preCreate      func(context.Context, *svcapitypes.DBCluster, *svcsdk.CreateDBClusterInput) error
	postCreate     func(context.Context, *svcapitypes.DBCluster, *svcsdk.CreateDBClusterOutput, managed.ExternalCreation, error) (managed.ExternalCreation, error)
	preDelete      func(context.Context, *svcapitypes.DBCluster, *svcsdk.DeleteDBClusterInput) (bool, error)
	postDelete     func(context.Context, *svcapitypes.DBCluster, *svcsdk.DeleteDBClusterOutput, error) (managed.ExternalDelete, error)
	preUpdate      func(context.Context, *svcapitypes.DBCluster, *svcsdk.ModifyDBClusterInput) error
	postUpdate     func(context.Context, *svcapitypes.DBCluster, *svcsdk.ModifyDBClusterOutput, managed.ExternalUpdate, error) (managed.ExternalUpdate, error)
}

func nopPreObserve(context.Context, *svcapitypes.DBCluster, *svcsdk.DescribeDBClustersInput) error {
	return nil
}
func nopPostObserve(_ context.Context, _ *svcapitypes.DBCluster, _ *svcsdk.DescribeDBClustersOutput, obs managed.ExternalObservation, err error) (managed.ExternalObservation, error) {
	return obs, err
}
func nopFilterList(_ *svcapitypes.DBCluster, list *svcsdk.DescribeDBClustersOutput) *svcsdk.DescribeDBClustersOutput {
	return list
}

func nopLateInitialize(*svcapitypes.DBClusterParameters, *svcsdk.DescribeDBClustersOutput) error {
	return nil
}
func alwaysUpToDate(context.Context, *svcapitypes.DBCluster, *svcsdk.DescribeDBClustersOutput) (bool, string, error) {
	return true, "", nil
}

func nopPreCreate(context.Context, *svcapitypes.DBCluster, *svcsdk.CreateDBClusterInput) error {
	return nil
}
func nopPostCreate(_ context.Context, _ *svcapitypes.DBCluster, _ *svcsdk.CreateDBClusterOutput, cre managed.ExternalCreation, err error) (managed.ExternalCreation, error) {
	return cre, err
}
func nopPreDelete(context.Context, *svcapitypes.DBCluster, *svcsdk.DeleteDBClusterInput) (bool, error) {
	return false, nil
}
func nopPostDelete(_ context.Context, _ *svcapitypes.DBCluster, _ *svcsdk.DeleteDBClusterOutput, err error) (managed.ExternalDelete, error) {
	return managed.ExternalDelete{}, err
}
func nopPreUpdate(context.Context, *svcapitypes.DBCluster, *svcsdk.ModifyDBClusterInput) error {
	return nil
}
func nopPostUpdate(_ context.Context, _ *svcapitypes.DBCluster, _ *svcsdk.ModifyDBClusterOutput, upd managed.ExternalUpdate, err error) (managed.ExternalUpdate, error) {
	return upd, err
}
